

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ch_pipeline.analysis.flagging &mdash; ch_pipeline  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            ch_pipeline
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev.html">Development Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference.html">Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ch_pipeline</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">ch_pipeline.analysis.flagging</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for ch_pipeline.analysis.flagging</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Tasks for Flagging Data.</span>

<span class="sd">Tasks for calculating flagging out unwanted data. This includes RFI removal, and</span>
<span class="sd">data quality flagging on timestream data; sun excision on sidereal data; and</span>
<span class="sd">pre-map making flagging on m-modes.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">caput.time</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ctime</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.constants</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">caput</span><span class="w"> </span><span class="kn">import</span> <span class="n">config</span><span class="p">,</span> <span class="n">interferometry</span><span class="p">,</span> <span class="n">memh5</span><span class="p">,</span> <span class="n">mpiarray</span><span class="p">,</span> <span class="n">mpiutil</span><span class="p">,</span> <span class="n">pipeline</span><span class="p">,</span> <span class="n">tod</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ch_ephem</span><span class="w"> </span><span class="kn">import</span> <span class="n">sources</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ch_ephem.observers</span><span class="w"> </span><span class="kn">import</span> <span class="n">chime</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ch_util</span><span class="w"> </span><span class="kn">import</span> <span class="n">andata</span><span class="p">,</span> <span class="n">cal_utils</span><span class="p">,</span> <span class="n">data_quality</span><span class="p">,</span> <span class="n">finder</span><span class="p">,</span> <span class="n">rfi</span><span class="p">,</span> <span class="n">tools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">chimedb</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataflag</span> <span class="k">as</span> <span class="n">df</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">chimedb.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">connect</span> <span class="k">as</span> <span class="n">connect_database</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">draco.analysis</span><span class="w"> </span><span class="kn">import</span> <span class="n">flagging</span> <span class="k">as</span> <span class="n">dflagging</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">draco.analysis.ringmapmaker</span><span class="w"> </span><span class="kn">import</span> <span class="n">find_grid_indices</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">draco.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">containers</span> <span class="k">as</span> <span class="n">dcontainers</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">draco.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">io</span><span class="p">,</span> <span class="n">task</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">KDTree</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">..core</span><span class="w"> </span><span class="kn">import</span> <span class="n">containers</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..core.dataquery</span><span class="w"> </span><span class="kn">import</span> <span class="n">_DEFAULT_NODE_SPOOF</span>


<div class="viewcode-block" id="RFIFilter">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.RFIFilter">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">RFIFilter</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Identify data contaminated by RFI.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    stack: bool</span>
<span class="sd">        Average over all autocorrelations before constructing the mask.</span>
<span class="sd">    normalize : bool</span>
<span class="sd">        Normalize by the median value over time prior to stacking.</span>
<span class="sd">    flag1d : bool</span>
<span class="sd">        Only apply the MAD cut in the time direction.</span>
<span class="sd">        Useful if the frequency coverage is sparse.</span>
<span class="sd">    rolling : bool</span>
<span class="sd">        Use a rolling window instead of distinct blocks.</span>
<span class="sd">        This is slower, but recommended if stack is True</span>
<span class="sd">        or the number of feeds is small.</span>
<span class="sd">    apply_static_mask : bool</span>
<span class="sd">        Mask out frequencies known to be contaminated by persistent</span>
<span class="sd">        sources of RFI.  Mask is obtained from `ch_util.rfi.frequency_mask`.</span>
<span class="sd">        This is done before computing the median absolute deviation.</span>
<span class="sd">    keep_auto : bool</span>
<span class="sd">        Save the autocorrelations that were used to construct</span>
<span class="sd">        the mask in the output container.</span>
<span class="sd">    keep_ndev : bool</span>
<span class="sd">        Save the number of deviations that were used to construct</span>
<span class="sd">        the mask in the output container.</span>
<span class="sd">    freq_width : float</span>
<span class="sd">        Frequency interval in *MHz* to compare across.</span>
<span class="sd">    time_width : float</span>
<span class="sd">        Time interval in *seconds* to compare across.</span>
<span class="sd">    threshold_mad : float</span>
<span class="sd">        Threshold above which we mask the data.</span>
<span class="sd">    use_draco_container : bool</span>
<span class="sd">        If True, output container is a nondistributed draco RFIMask.</span>
<span class="sd">        Otherwise, return a distributed RFIMask from ch_pipeline</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">stack</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">normalize</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">flag1d</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">rolling</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">apply_static_mask</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">keep_auto</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">keep_ndev</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">freq_width</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">10.0</span><span class="p">)</span>
    <span class="n">time_width</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">420.0</span><span class="p">)</span>
    <span class="n">threshold_mad</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">6.0</span><span class="p">)</span>
    <span class="n">use_draco_container</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="RFIFilter.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.RFIFilter.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">containers</span><span class="o">.</span><span class="n">RFIMask</span> <span class="o">|</span> <span class="n">dcontainers</span><span class="o">.</span><span class="n">RFIMask</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a mask by identifying outliers in the autocorrelation data.</span>

<span class="sd">        This mask can be used to zero out frequencies and time samples that are</span>
<span class="sd">        contaminated by RFI.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : ch_util.andata.CorrData</span>
<span class="sd">            Generate the mask from the autocorrelation data</span>
<span class="sd">            in this container.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : containers.RFIMask or dcontainers.RFIMask</span>
<span class="sd">            Boolean mask that can be applied to a timestream container</span>
<span class="sd">            with the task `ApplyCorrInputMask` to mask contaminated</span>
<span class="sd">            frequencies and time samples.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Redistribute across frequency</span>
        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Construct RFI mask</span>
        <span class="n">auto_index</span><span class="p">,</span> <span class="n">auto</span><span class="p">,</span> <span class="n">ndev</span> <span class="o">=</span> <span class="n">rfi</span><span class="o">.</span><span class="n">number_deviations</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">apply_static_mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">apply_static_mask</span><span class="p">,</span>
            <span class="n">freq_width</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">freq_width</span><span class="p">,</span>
            <span class="n">time_width</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_width</span><span class="p">,</span>
            <span class="n">flag1d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flag1d</span><span class="p">,</span>
            <span class="n">rolling</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rolling</span><span class="p">,</span>
            <span class="n">stack</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">,</span>
            <span class="n">normalize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">normalize</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Reorder output based on input chan_id</span>
        <span class="n">minput</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">][</span><span class="n">auto_index</span><span class="p">]</span>
        <span class="n">isort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">minput</span><span class="p">[</span><span class="s2">&quot;chan_id&quot;</span><span class="p">])</span>

        <span class="n">minput</span> <span class="o">=</span> <span class="n">minput</span><span class="p">[</span><span class="n">isort</span><span class="p">]</span>
        <span class="n">auto</span> <span class="o">=</span> <span class="n">auto</span><span class="p">[:,</span> <span class="n">isort</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">ndev</span> <span class="o">=</span> <span class="n">ndev</span><span class="p">[:,</span> <span class="n">isort</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># Place cut on the number of deviations.  Note that we are</span>
        <span class="c1"># only flagging positive excursions corresponding to an</span>
        <span class="c1"># increase in measured power relative to the local median.</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">ndev</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold_mad</span>

        <span class="c1"># Create container to hold output</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_draco_container</span><span class="p">:</span>
            <span class="c1"># draco RFIMask container is not distributed</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">dcontainers</span><span class="o">.</span><span class="n">RFIMask</span><span class="p">(</span><span class="n">axes_from</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">attrs_from</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">allgather</span><span class="p">()[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">RFIMask</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">minput</span><span class="p">,</span> <span class="n">axes_from</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">attrs_from</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>
            <span class="c1"># Change flag convention</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">keep_ndev</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;ndev&quot;</span><span class="p">)</span>
                <span class="n">out</span><span class="o">.</span><span class="n">ndev</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">ndev</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">keep_auto</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;auto&quot;</span><span class="p">)</span>
                <span class="n">out</span><span class="o">.</span><span class="n">auto</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">auto</span>

        <span class="c1"># Save mask to output container</span>
        <span class="n">out</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">mask</span>

        <span class="c1"># Return output container</span>
        <span class="k">return</span> <span class="n">out</span></div>
</div>



<div class="viewcode-block" id="RFINarrowbandVisMask">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.RFINarrowbandVisMask">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">RFINarrowbandVisMask</span><span class="p">(</span><span class="n">dflagging</span><span class="o">.</span><span class="n">RFINarrowbandVisMask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;CHIME version of RFIFourierMask.</span>

<span class="sd">    This has a static mask for the local environment and will use the MAD</span>
<span class="sd">    algorithm (over SumThreshold) when bright sources are visible.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    transit_width : float, optional</span>
<span class="sd">        Ignore any times that occur within this number of sigma from</span>
<span class="sd">        the transit of a bright source.  Here sigma refers to the standard</span>
<span class="sd">        deviation of a a Gaussian approximation to the primary beam.</span>
<span class="sd">        Default is 2.0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">transit_width</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_static_rfi_mask_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">timestamp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Use the static CHIME RFI mask.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq : np.ndarray[nfreq]</span>
<span class="sd">            1D array of frequencies in the data (in MHz).</span>

<span class="sd">        timestamp : np.array[float]</span>
<span class="sd">            Start observing time (in unix time)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask : np.ndarray[nfreq]</span>
<span class="sd">            Mask array. True will mask a frequency channel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">rfi</span><span class="o">.</span><span class="n">frequency_mask</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">timestamp</span><span class="o">=</span><span class="n">timestamp</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_source_flag_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Flag times where bright sources are transiting or sun is up.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        times : np.ndarray[float]</span>
<span class="sd">            Array of timestamps associated with the full dataset.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask : np.ndarray[float]</span>
<span class="sd">            Mask array. True will flag a time sample.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">moon</span> <span class="o">=</span> <span class="n">ctime</span><span class="o">.</span><span class="n">skyfield_wrapper</span><span class="o">.</span><span class="n">ephemeris</span><span class="p">[</span><span class="s2">&quot;moon&quot;</span><span class="p">]</span>
        <span class="n">sun</span> <span class="o">=</span> <span class="n">ctime</span><span class="o">.</span><span class="n">skyfield_wrapper</span><span class="o">.</span><span class="n">ephemeris</span><span class="p">[</span><span class="s2">&quot;sun&quot;</span><span class="p">]</span>
        <span class="n">body</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">sources</span><span class="o">.</span><span class="n">source_dictionary</span><span class="p">[</span><span class="n">src</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;CAS_A&quot;</span><span class="p">,</span> <span class="s2">&quot;CYG_A&quot;</span><span class="p">,</span> <span class="s2">&quot;TAU_A&quot;</span><span class="p">,</span> <span class="s2">&quot;VIR_A&quot;</span><span class="p">]</span>
        <span class="p">]</span>
        <span class="n">body</span> <span class="o">+=</span> <span class="p">[</span><span class="n">sun</span><span class="p">,</span> <span class="n">moon</span><span class="p">]</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">b_</span> <span class="ow">in</span> <span class="n">body</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">|=</span> <span class="n">transit_flag</span><span class="p">(</span><span class="n">b_</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">nsigma</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transit_width</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">|=</span> <span class="n">daytime_flag</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mask</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_solar_transit_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Override to flag solar transit times.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        times : np.ndarray[float]</span>
<span class="sd">            Array of timestamps.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask : np.ndarray[float]</span>
<span class="sd">            Mask array. True will mask out a time sample.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sun</span> <span class="o">=</span> <span class="n">ctime</span><span class="o">.</span><span class="n">skyfield_wrapper</span><span class="o">.</span><span class="n">ephemeris</span><span class="p">[</span><span class="s2">&quot;sun&quot;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">transit_flag</span><span class="p">(</span><span class="n">sun</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">nsigma</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transit_width</span><span class="p">)</span></div>



<div class="viewcode-block" id="RFIMaskChisqHighDelay">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.RFIMaskChisqHighDelay">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">RFIMaskChisqHighDelay</span><span class="p">(</span><span class="n">dflagging</span><span class="o">.</span><span class="n">RFIMaskChisqHighDelay</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;CHIME version of RFIMaskChisqHighDelay.</span>

<span class="sd">    Ignores times that occur during the day or when bright point sources</span>
<span class="sd">    or pulsars are transiting through the primary beam.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    sources : list of str</span>
<span class="sd">        Bright sources to consider when constructing the mask.</span>
<span class="sd">    transit_width : float</span>
<span class="sd">        Ignore any times that occur within this number of sigma from</span>
<span class="sd">        the transit of a bright source.  Here sigma refers to the standard</span>
<span class="sd">        deviation of a a Gaussian approximation to the primary beam.</span>
<span class="sd">        Default is 1.0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">sources</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span>
        <span class="n">proptype</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;CAS_A&quot;</span><span class="p">,</span> <span class="s2">&quot;CYG_A&quot;</span><span class="p">,</span> <span class="s2">&quot;TAU_A&quot;</span><span class="p">,</span> <span class="s2">&quot;VIR_A&quot;</span><span class="p">,</span> <span class="s2">&quot;B0329+54&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">transit_width</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_source_flag_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">freq</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mask times when bright sources are transiting.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        times : np.ndarray[ntime]</span>
<span class="sd">            Array of timestamps.</span>
<span class="sd">        freq : np.ndarray[nfreq]</span>
<span class="sd">            Array of frequencies.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask : np.ndarray[nfreq, ntime]</span>
<span class="sd">            Mask array. True will mask out a time sample.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">body</span> <span class="o">=</span> <span class="p">[</span><span class="n">sources</span><span class="o">.</span><span class="n">source_dictionary</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sources</span><span class="p">]</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">freq</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">times</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">b_</span> <span class="ow">in</span> <span class="n">body</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">|=</span> <span class="n">transit_flag</span><span class="p">(</span><span class="n">b_</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">nsigma</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transit_width</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mask</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_day_flag_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mask times during the day.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        times : np.ndarray[ntime]</span>
<span class="sd">            Array of timestamps.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask : np.ndarray[ntime]</span>
<span class="sd">            Mask array. True will mask out a time sample.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">daytime_flag</span><span class="p">(</span><span class="n">times</span><span class="p">)</span></div>



<div class="viewcode-block" id="RFISensitivityMask">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.RFISensitivityMask">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">RFISensitivityMask</span><span class="p">(</span><span class="n">dflagging</span><span class="o">.</span><span class="n">RFISensitivityMask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;CHIME version of RFISensitivityMask.</span>

<span class="sd">    This has a static mask for the local environment and will use the MAD</span>
<span class="sd">    algorithm (over SumThreshold) when bright sources are visible.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    sources : list of str</span>
<span class="sd">        Bright sources to consider when constructing the mask.</span>
<span class="sd">    transit_width_source : float</span>
<span class="sd">        Use MAD for any times that occur within this number of sigma from</span>
<span class="sd">        the transit of a bright source.  Here sigma refers to the standard</span>
<span class="sd">        deviation of a a Gaussian approximation to the primary beam.</span>
<span class="sd">        Default is 1.0.</span>
<span class="sd">    transit_width_sun : float</span>
<span class="sd">        Use MAD for any times that occur within this number of sigma from</span>
<span class="sd">        the transit of the sun.  Here sigma refers to the standard</span>
<span class="sd">        deviation of a a Gaussian approximation to the primary beam.</span>
<span class="sd">        Default is 3.0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">sources</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span>
        <span class="n">proptype</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;CAS_A&quot;</span><span class="p">,</span> <span class="s2">&quot;CYG_A&quot;</span><span class="p">,</span> <span class="s2">&quot;TAU_A&quot;</span><span class="p">,</span> <span class="s2">&quot;B0329+54&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">transit_width_source</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">transit_width_sun</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">3.0</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_combine_st_mad_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">freq</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Use the MAD mask (over SumThreshold) whenever a bright source is overhead.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        times : np.ndarray[ntime]</span>
<span class="sd">            Array of Unix timestamps.</span>
<span class="sd">        freq : np.ndarray[nfreq]</span>
<span class="sd">            Array of frequencies.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        combine : np.ndarray[nfreq, ntime]</span>
<span class="sd">            Mixing array as a function of time. If `True` that sample will be</span>
<span class="sd">            filled from the MAD, if `False` use the SumThreshold algorithm.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">body</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">sources</span><span class="o">.</span><span class="n">source_dictionary</span><span class="p">[</span><span class="n">src</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">transit_width_source</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sources</span>
        <span class="p">]</span>
        <span class="n">body</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ctime</span><span class="o">.</span><span class="n">skyfield_wrapper</span><span class="o">.</span><span class="n">ephemeris</span><span class="p">[</span><span class="s2">&quot;sun&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">transit_width_sun</span><span class="p">))</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">freq</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">times</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">b_</span><span class="p">,</span> <span class="n">n_</span> <span class="ow">in</span> <span class="n">body</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">|=</span> <span class="n">transit_flag</span><span class="p">(</span><span class="n">b_</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">nsigma</span><span class="o">=</span><span class="n">n_</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mask</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_static_rfi_mask_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">timestamp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Use the static CHIME RFI mask.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq : np.ndarray[nfreq]</span>
<span class="sd">            1D array of frequencies in the data (in MHz).</span>

<span class="sd">        timestamp : float</span>
<span class="sd">            Start observing time (in unix time)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask : np.ndarray[nfreq]</span>
<span class="sd">            Mask array. True will include a frequency channel, False masks it out.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="o">~</span><span class="n">rfi</span><span class="o">.</span><span class="n">frequency_mask</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">timestamp</span><span class="o">=</span><span class="n">timestamp</span><span class="p">)</span></div>



<div class="viewcode-block" id="RFIStaticMask">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.RFIStaticMask">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">RFIStaticMask</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the static mask for the time period covered by the data.</span>

<span class="sd">    This is the same static mask used in :class:`RFIFilter` and</span>
<span class="sd">    :class:`RFISensitivityMask`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RFIStaticMask.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.RFIStaticMask.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a mask with all static frequency bands for a given day.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data</span>
<span class="sd">            container with data to mask. Should have either a time-like axis</span>
<span class="sd">            or a `lsd` attribute which can be converted to a UNIX timestamp.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask</span>
<span class="sd">            boolean mask that can be applied to the input container</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Redistribute across frequency</span>
        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Create mask container. draco RFIMask is not distributed.</span>
        <span class="k">if</span> <span class="s2">&quot;ra&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
            <span class="n">csd</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;lsd&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;csd&quot;</span><span class="p">))</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="n">chime</span><span class="o">.</span><span class="n">lsd_to_unix</span><span class="p">(</span><span class="n">csd</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">dcontainers</span><span class="o">.</span><span class="n">SiderealRFIMask</span><span class="p">(</span><span class="n">attrs_from</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">axes_from</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">dcontainers</span><span class="o">.</span><span class="n">RFIMask</span><span class="p">(</span><span class="n">attrs_from</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">axes_from</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No definition for `time` or `ra` axes.&quot;</span><span class="p">)</span>

        <span class="c1"># Expand 1D mask to proper shape</span>
        <span class="n">out</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">rfi</span><span class="o">.</span><span class="n">frequency_mask</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span> <span class="n">timestamp</span><span class="o">=</span><span class="n">timestamp</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">out</span></div>
</div>



<div class="viewcode-block" id="ChannelFlagger">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.ChannelFlagger">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ChannelFlagger</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mask out channels that appear weird in some way.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    test_freq : list</span>
<span class="sd">        Frequencies to test the data at.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">test_freq</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">[</span><span class="mf">610.0</span><span class="p">])</span>

    <span class="n">ignore_fit</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">ignore_noise</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">ignore_gains</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">known_bad</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">[])</span>

<div class="viewcode-block" id="ChannelFlagger.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.ChannelFlagger.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestream</span><span class="p">,</span> <span class="n">inputmap</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Flag bad channels in timestream.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestream : andata.CorrData</span>
<span class="sd">            Timestream to flag.</span>
<span class="sd">        inputmap</span>
<span class="sd">            associate inputs with CHIME inputs</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        timestream : andata.CorrData</span>
<span class="sd">            Returns the same timestream object with a modified weight dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Redistribute over the frequency direction</span>
        <span class="n">timestream</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Find the indices for frequencies in this timestream nearest</span>
        <span class="c1"># to the given physical frequencies</span>
        <span class="n">freq_ind</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">timestream</span><span class="o">.</span><span class="n">freq</span> <span class="o">-</span> <span class="n">freq</span><span class="p">))</span> <span class="k">for</span> <span class="n">freq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">test_freq</span>
        <span class="p">]</span>

        <span class="c1"># Create a global channel weight (channels are bad by default)</span>
        <span class="n">chan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">timestream</span><span class="o">.</span><span class="n">ninput</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

        <span class="c1"># Mark any powered CHIME channels as good</span>
        <span class="n">chan_mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">is_chime_on</span><span class="p">(</span><span class="n">inputmap</span><span class="p">)</span>

        <span class="c1"># Calculate start and end frequencies</span>
        <span class="n">sf</span> <span class="o">=</span> <span class="n">timestream</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">local_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ef</span> <span class="o">=</span> <span class="n">sf</span> <span class="o">+</span> <span class="n">timestream</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">local_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Iterate over frequencies and find bad channels</span>
        <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">freq_ind</span><span class="p">:</span>
            <span class="c1"># Only run good_channels if frequency is local</span>
            <span class="k">if</span> <span class="n">fi</span> <span class="o">&gt;=</span> <span class="n">sf</span> <span class="ow">and</span> <span class="n">fi</span> <span class="o">&lt;</span> <span class="n">ef</span><span class="p">:</span>
                <span class="c1"># Run good channels code and unpack arguments</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">data_quality</span><span class="o">.</span><span class="n">good_channels</span><span class="p">(</span>
                    <span class="n">timestream</span><span class="p">,</span> <span class="n">test_freq</span><span class="o">=</span><span class="n">fi</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="n">inputmap</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>
                <span class="n">good_gains</span><span class="p">,</span> <span class="n">good_noise</span><span class="p">,</span> <span class="n">good_fit</span><span class="p">,</span> <span class="n">test_channels</span> <span class="o">=</span> <span class="n">res</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">&quot;Frequency </span><span class="si">%i</span><span class="s2"> bad channels: blank </span><span class="si">%i</span><span class="s2">; gains </span><span class="si">%i</span><span class="s2">; noise </span><span class="si">%i</span><span class="s2">; fit </span><span class="si">%i</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">fi</span><span class="p">,</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">chan_mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">good_gains</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">good_noise</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">good_fit</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span>
                    <span class="s2">&quot;[ignored]&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_fit</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">good_noise</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">good_noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">test_channels</span><span class="p">)</span>

                <span class="c1"># Construct the overall channel mask for this</span>
                <span class="c1"># frequency (explicit cast to int or numpy complains,</span>
                <span class="c1"># this should really be done upstream).</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_gains</span><span class="p">:</span>
                    <span class="n">chan_mask</span><span class="p">[</span><span class="n">test_channels</span><span class="p">]</span> <span class="o">*=</span> <span class="n">good_gains</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_noise</span><span class="p">:</span>
                    <span class="n">chan_mask</span><span class="p">[</span><span class="n">test_channels</span><span class="p">]</span> <span class="o">*=</span> <span class="n">good_noise</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_fit</span><span class="p">:</span>
                    <span class="n">chan_mask</span><span class="p">[</span><span class="n">test_channels</span><span class="p">]</span> <span class="o">*=</span> <span class="n">good_fit</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

        <span class="c1"># Gather the channel flags from all nodes, and combine into a</span>
        <span class="c1"># single flag (checking that all tests pass)</span>
        <span class="n">chan_mask_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="n">timestream</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">timestream</span><span class="o">.</span><span class="n">ninput</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span>
        <span class="p">)</span>
        <span class="n">timestream</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Allgather</span><span class="p">(</span><span class="n">chan_mask</span><span class="p">,</span> <span class="n">chan_mask_all</span><span class="p">)</span>
        <span class="n">chan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">chan_mask_all</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Mark already known bad channels</span>
        <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">known_bad</span><span class="p">:</span>
            <span class="n">chan_mask</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Apply weights to files weight array</span>
        <span class="n">chan_mask</span> <span class="o">=</span> <span class="n">chan_mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">timestream</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span>
        <span class="n">tools</span><span class="o">.</span><span class="n">apply_gain</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">chan_mask</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">timestream</span></div>
</div>



<div class="viewcode-block" id="MonitorCorrInput">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.MonitorCorrInput">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MonitorCorrInput</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Monitor good correlator inputs over several sidereal days.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_day_min : int</span>
<span class="sd">        Do not apply a sidereal day flag if the number of days</span>
<span class="sd">        in the pass is less than n_day_min.  Default is 3.</span>

<span class="sd">    n_cut : int</span>
<span class="sd">        Flag a sidereal day as bad if the number of correlator</span>
<span class="sd">        inputs that are bad ONLY on this day is greater than n_cut.</span>
<span class="sd">        Default is 5.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_day_min</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">n_cut</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<div class="viewcode-block" id="MonitorCorrInput.setup">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.MonitorCorrInput.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Divide list of files up into sidereal days.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        files : list</span>
<span class="sd">            List of filenames to monitor good correlator inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.sidereal</span><span class="w"> </span><span class="kn">import</span> <span class="n">_days_in_csd</span><span class="p">,</span> <span class="n">get_times</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">files</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">files</span><span class="p">)</span>

        <span class="c1"># Initialize variables</span>
        <span class="n">timemap</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">input_map</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># If rank0, then create a map from csd to time range</span>
        <span class="c1"># and determine correlator inputs and frequencies</span>
        <span class="k">if</span> <span class="n">mpiutil</span><span class="o">.</span><span class="n">rank0</span><span class="p">:</span>
            <span class="c1"># Determine the days in each file and the days in all files</span>
            <span class="n">se_times</span> <span class="o">=</span> <span class="n">get_times</span><span class="p">(</span><span class="n">files</span><span class="p">)</span>
            <span class="n">se_csd</span> <span class="o">=</span> <span class="n">chime</span><span class="o">.</span><span class="n">unix_to_lsd</span><span class="p">(</span><span class="n">se_times</span><span class="p">)</span>
            <span class="n">days</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">se_csd</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">))</span>

            <span class="c1"># Determine the relevant files for each day</span>
            <span class="n">filemap</span> <span class="o">=</span> <span class="p">[(</span><span class="n">day</span><span class="p">,</span> <span class="n">_days_in_csd</span><span class="p">(</span><span class="n">day</span><span class="p">,</span> <span class="n">se_csd</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="mf">0.005</span><span class="p">))</span> <span class="k">for</span> <span class="n">day</span> <span class="ow">in</span> <span class="n">days</span><span class="p">]</span>

            <span class="c1"># Determine the time range for each day</span>
            <span class="n">timemap</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">day</span><span class="p">,</span> <span class="n">chime</span><span class="o">.</span><span class="n">lsd_to_unix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">day</span><span class="p">,</span> <span class="n">day</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])))</span> <span class="k">for</span> <span class="n">day</span> <span class="ow">in</span> <span class="n">days</span>
            <span class="p">]</span>

            <span class="c1"># Extract the frequency and inputs for the first day</span>
            <span class="n">data_r</span> <span class="o">=</span> <span class="n">andata</span><span class="o">.</span><span class="n">Reader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="n">filemap</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">input_map</span> <span class="o">=</span> <span class="n">data_r</span><span class="o">.</span><span class="n">input</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="n">data_r</span><span class="o">.</span><span class="n">freq</span><span class="p">[:]</span>

            <span class="n">ninput</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_map</span><span class="p">)</span>
            <span class="n">nfreq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

            <span class="c1"># Loop through the rest of the days and make sure the</span>
            <span class="c1"># inputs and frequencies are the same</span>
            <span class="k">for</span> <span class="n">fmap</span> <span class="ow">in</span> <span class="n">filemap</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">data_r</span> <span class="o">=</span> <span class="n">andata</span><span class="o">.</span><span class="n">Reader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="n">fmap</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_r</span><span class="o">.</span><span class="n">input</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ninput</span><span class="p">:</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Differing number of corr inputs for csd </span><span class="si">{</span><span class="n">fmap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> and csd </span><span class="si">{</span><span class="n">filemap</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                        <span class="n">data_r</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="s2">&quot;correlator_input&quot;</span><span class="p">]</span>
                        <span class="o">!=</span> <span class="n">input_map</span><span class="p">[</span><span class="s2">&quot;correlator_input&quot;</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="p">):</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Differing corr inputs for csd </span><span class="si">{</span><span class="n">fmap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> and csd </span><span class="si">{</span><span class="n">filemap</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_r</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nfreq</span><span class="p">:</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Differing number of frequencies for csd </span><span class="si">{</span><span class="n">fmap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> and csd </span><span class="si">{</span><span class="n">filemap</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data_r</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="s2">&quot;centre&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">freq</span><span class="p">[</span><span class="s2">&quot;centre&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Differing frequencies for csd </span><span class="si">{</span><span class="n">fmap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> and csd </span><span class="si">{</span><span class="n">filemap</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>

        <span class="c1"># Broadcast results to all processes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timemap</span> <span class="o">=</span> <span class="n">mpiutil</span><span class="o">.</span><span class="n">world</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">timemap</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ndays</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timemap</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">input_map</span> <span class="o">=</span> <span class="n">mpiutil</span><span class="o">.</span><span class="n">world</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">input_map</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ninput</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_map</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">freq</span> <span class="o">=</span> <span class="n">mpiutil</span><span class="o">.</span><span class="n">world</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nfreq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span></div>


<div class="viewcode-block" id="MonitorCorrInput.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.MonitorCorrInput.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calls ch_util.ChanMonitor for each sidereal day.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        input_monitor : containers.CorrInputMonitor</span>
<span class="sd">            Saved for each sidereal day.  Contains the</span>
<span class="sd">            correlator input mask and frequency mask.</span>
<span class="sd">            Note that this is not output to the pipeline.  It is an</span>
<span class="sd">            ancillary data product that is saved when one sets the</span>
<span class="sd">            &#39;save&#39; parameter in the configuration file.</span>
<span class="sd">        csd_flag : containers.SiderealDayFlag</span>
<span class="sd">            Contains a mask that indicates bad sidereal days, determined as</span>
<span class="sd">            days that contribute a large number of unique bad correlator</span>
<span class="sd">            inputs.  Note that this is not output to the pipeline.</span>
<span class="sd">            It is ancillary data product that is saved when one sets the</span>
<span class="sd">            &#39;save&#39; parameter in the configuration file.</span>
<span class="sd">        input_monitor_all : containers.CorrInputMask</span>
<span class="sd">            Contains the correlator input mask obtained from taking AND</span>
<span class="sd">            of the masks from the (good) sidereal days.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">ch_util</span><span class="w"> </span><span class="kn">import</span> <span class="n">chan_monitor</span>

        <span class="c1"># Check if we should stop</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndays</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">PipelineStopIteration</span>

        <span class="c1"># Get a range of days for this process to analyze</span>
        <span class="n">n_local</span><span class="p">,</span> <span class="n">i_day_start</span><span class="p">,</span> <span class="n">i_day_end</span> <span class="o">=</span> <span class="n">mpiutil</span><span class="o">.</span><span class="n">split_local</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndays</span><span class="p">)</span>
        <span class="n">i_day</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i_day_start</span><span class="p">,</span> <span class="n">i_day_end</span><span class="p">)</span>

        <span class="c1"># Create local arrays to hold results</span>
        <span class="n">input_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_local</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ninput</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">good_day_flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_local</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="c1"># Loop over days</span>
        <span class="k">for</span> <span class="n">i_local</span><span class="p">,</span> <span class="n">i_dist</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">i_day</span><span class="p">):</span>
            <span class="n">csd</span><span class="p">,</span> <span class="n">time_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timemap</span><span class="p">[</span><span class="n">i_dist</span><span class="p">]</span>

            <span class="c1"># Print status</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calling channel monitor for csd </span><span class="si">%d</span><span class="s2">.&quot;</span><span class="p">,</span> <span class="n">csd</span><span class="p">)</span>

            <span class="c1"># Create an instance of chan_monitor for this day</span>
            <span class="n">cm</span> <span class="o">=</span> <span class="n">chan_monitor</span><span class="o">.</span><span class="n">ChanMonitor</span><span class="p">(</span><span class="o">*</span><span class="n">time_range</span><span class="p">)</span>

            <span class="c1"># Run the full test</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">cm</span><span class="o">.</span><span class="n">full_check</span><span class="p">()</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">RuntimeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
                <span class="c1"># No sources available for this csd</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;    csd </span><span class="si">%d</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">csd</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># Accumulate flags over multiple days</span>
            <span class="n">input_mask</span><span class="p">[</span><span class="n">i_local</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">good_ipts</span> <span class="o">&amp;</span> <span class="n">cm</span><span class="o">.</span><span class="n">pwds</span>
            <span class="n">good_day_flag</span><span class="p">[</span><span class="n">i_local</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># If requested, write to disk</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">:</span>
                <span class="c1"># Create a container to hold the results</span>
                <span class="n">input_mon</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">CorrInputMonitor</span><span class="p">(</span>
                    <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span> <span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_map</span><span class="p">,</span> <span class="n">distributed</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>

                <span class="c1"># Place the results in the container</span>
                <span class="n">input_mon</span><span class="o">.</span><span class="n">input_mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">good_ipts</span>
                <span class="n">input_mon</span><span class="o">.</span><span class="n">input_powered</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">pwds</span>
                <span class="n">input_mon</span><span class="o">.</span><span class="n">freq_mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">good_freqs</span>
                <span class="n">input_mon</span><span class="o">.</span><span class="n">freq_powered</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">gpu_node_flag</span>

                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="s2">&quot;postns&quot;</span><span class="p">):</span>
                    <span class="n">input_mon</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;position&quot;</span><span class="p">)</span>
                    <span class="n">input_mon</span><span class="o">.</span><span class="n">position</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">postns</span>

                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="s2">&quot;expostns&quot;</span><span class="p">):</span>
                    <span class="n">input_mon</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;expected_position&quot;</span><span class="p">)</span>
                    <span class="n">input_mon</span><span class="o">.</span><span class="n">expected_position</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">expostns</span>

                <span class="k">if</span> <span class="n">cm</span><span class="o">.</span><span class="n">source1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">input_mon</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;source1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">source1</span><span class="o">.</span><span class="n">name</span>

                <span class="k">if</span> <span class="n">cm</span><span class="o">.</span><span class="n">source2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">input_mon</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;source2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">source2</span><span class="o">.</span><span class="n">name</span>

                <span class="c1"># Construct tag from csd</span>
                <span class="n">tag</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;csd_</span><span class="si">{</span><span class="n">csd</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">input_mon</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tag</span>
                <span class="n">input_mon</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;csd&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">csd</span>

                <span class="c1"># Save results to disk</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_save_output</span><span class="p">(</span><span class="n">input_mon</span><span class="p">)</span>

        <span class="c1"># Gather the flags from all nodes</span>
        <span class="n">input_mask_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ndays</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ninput</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">good_day_flag_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndays</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="n">mpiutil</span><span class="o">.</span><span class="n">world</span><span class="o">.</span><span class="n">Allgather</span><span class="p">(</span><span class="n">input_mask</span><span class="p">,</span> <span class="n">input_mask_all</span><span class="p">)</span>
        <span class="n">mpiutil</span><span class="o">.</span><span class="n">world</span><span class="o">.</span><span class="n">Allgather</span><span class="p">(</span><span class="n">good_day_flag</span><span class="p">,</span> <span class="n">good_day_flag_all</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">good_day_flag_all</span><span class="p">):</span>
            <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Channel monitor failed for all days.&quot;</span><span class="p">)</span>

        <span class="c1"># Find days where the number of correlator inputs that are bad</span>
        <span class="c1"># ONLY for this day is greater than some user specified threshold</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">good_day_flag_all</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_day_min</span><span class="p">):</span>
            <span class="n">n_uniq_bad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndays</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
            <span class="n">dindex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndays</span><span class="p">)[</span><span class="n">good_day_flag_all</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">day</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dindex</span><span class="p">):</span>
                <span class="n">other_days</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">dindex</span><span class="p">,</span> <span class="n">ii</span><span class="p">)</span>
                <span class="n">n_uniq_bad</span><span class="p">[</span><span class="n">day</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="o">~</span><span class="n">input_mask_all</span><span class="p">[</span><span class="n">day</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">input_mask_all</span><span class="p">[</span><span class="n">other_days</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="n">good_day_flag_all</span> <span class="o">*=</span> <span class="n">n_uniq_bad</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_cut</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">good_day_flag_all</span><span class="p">):</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Significant number of new correlator inputs flagged bad each day.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Write csd flag to file</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">:</span>
            <span class="c1"># Create container</span>
            <span class="n">csd_flag</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealDayFlag</span><span class="p">(</span>
                <span class="n">csd</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tmap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">tmap</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">timemap</span><span class="p">])</span>
            <span class="p">)</span>

            <span class="c1"># Save flags to container</span>
            <span class="n">csd_flag</span><span class="o">.</span><span class="n">csd_flag</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">good_day_flag_all</span>

            <span class="n">csd_flag</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;flag_csd&quot;</span>

            <span class="c1"># Write output to hdf5 file</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_output</span><span class="p">(</span><span class="n">csd_flag</span><span class="p">)</span>

        <span class="c1"># Take the product of the input mask for all days that made threshold cut</span>
        <span class="n">input_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">input_mask_all</span><span class="p">[</span><span class="n">good_day_flag_all</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Create a container to hold the results for the entire pass</span>
        <span class="n">input_mon</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">CorrInputMask</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_map</span><span class="p">)</span>

        <span class="c1"># Place the results for the entire pass in a container</span>
        <span class="n">input_mon</span><span class="o">.</span><span class="n">input_mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">input_mask</span>

        <span class="n">input_mon</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;for_pass&quot;</span>

        <span class="c1"># Ensure we stop on next iteration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ndays</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timemap</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Return pass results</span>
        <span class="k">return</span> <span class="n">input_mon</span></div>
</div>



<div class="viewcode-block" id="TestCorrInput">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.TestCorrInput">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">TestCorrInput</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply a series of tests to find the good correlator inputs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    test_freq : list</span>
<span class="sd">        Physical frequencies (in MHz) to examine.</span>
<span class="sd">    ignore_gain: bool</span>
<span class="sd">        Do not apply the test that checks for excessively high digital gains.</span>
<span class="sd">    ignore_noise: bool</span>
<span class="sd">        Do not apply the test that checks for compliance of noise</span>
<span class="sd">        to radiometer equation.</span>
<span class="sd">    ignore_fit: bool</span>
<span class="sd">        Do not apply the test that checks the goodness of the fit</span>
<span class="sd">        to a template Tsky.</span>
<span class="sd">    threshold: float</span>
<span class="sd">        Fraction of frequencies that must pass all requested</span>
<span class="sd">        tests in order for input to be flagged as good.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">test_freq</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="n">ignore_gains</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">ignore_noise</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">ignore_fit</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">threshold</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>

    <span class="n">known_bad</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">[])</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set up variables that gives names to tests and specify tests to be applied.&quot;&quot;&quot;</span>
        <span class="c1"># Gives names to the tests that will be run</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="s2">&quot;is_chime&quot;</span><span class="p">,</span> <span class="s2">&quot;not_known_bad&quot;</span><span class="p">,</span> <span class="s2">&quot;digital_gain&quot;</span><span class="p">,</span> <span class="s2">&quot;radiometer&quot;</span><span class="p">,</span> <span class="s2">&quot;sky_fit&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ntest</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">test</span><span class="p">)</span>

        <span class="c1"># Determine what tests we will use</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_test</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_gains</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_noise</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_fit</span><span class="p">]</span>
        <span class="p">)</span>

<div class="viewcode-block" id="TestCorrInput.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.TestCorrInput.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestream</span><span class="p">,</span> <span class="n">inputmap</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find good inputs using timestream.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestream : andata.CorrData</span>
<span class="sd">            Apply series of tests to this timestream.</span>
<span class="sd">        inputmap : list of :class:`CorrInput`</span>
<span class="sd">            A list of describing the inputs as they are in timestream.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        corr_input_test : containers.CorrInputTest</span>
<span class="sd">            Container with the results of all tests and a</span>
<span class="sd">            input mask that combines all tests and frequencies.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Redistribute over the frequency direction</span>
        <span class="n">timestream</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Extract the frequency map</span>
        <span class="n">freqmap</span> <span class="o">=</span> <span class="n">timestream</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">][:]</span>

        <span class="c1"># Find the indices for frequencies in this timestream nearest</span>
        <span class="c1"># to the requested test frequencies.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">test_freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">freq_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">freqmap</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">freq_ind</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">freqmap</span><span class="p">[</span><span class="s2">&quot;centre&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">freq</span><span class="p">))</span> <span class="k">for</span> <span class="n">freq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">test_freq</span>
            <span class="p">]</span>

        <span class="c1"># Calculate start and end frequencies</span>
        <span class="n">nfreq</span> <span class="o">=</span> <span class="n">timestream</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">local_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sfreq</span> <span class="o">=</span> <span class="n">timestream</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">local_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">efreq</span> <span class="o">=</span> <span class="n">sfreq</span> <span class="o">+</span> <span class="n">nfreq</span>

        <span class="c1"># Create local flag arrays (inputs are good by default)</span>
        <span class="n">passed_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">timestream</span><span class="o">.</span><span class="n">ninput</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ntest</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="n">is_test_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="c1"># Mark any non-CHIME inputs as bad</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">timestream</span><span class="o">.</span><span class="n">ninput</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputmap</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tools</span><span class="o">.</span><span class="n">CHIMEAntenna</span><span class="p">):</span>
                <span class="n">passed_test</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Mark already known bad inputs</span>
        <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">known_bad</span><span class="p">:</span>
            <span class="n">passed_test</span><span class="p">[:,</span> <span class="n">ch</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Iterate over frequencies and find bad inputs</span>
        <span class="k">for</span> <span class="n">fi_local</span><span class="p">,</span> <span class="n">fi_dist</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">sfreq</span><span class="p">,</span> <span class="n">efreq</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">fi_dist</span> <span class="ow">in</span> <span class="n">freq_ind</span><span class="p">:</span>
                <span class="c1"># Check if vis_weight is zero for this frequency,</span>
                <span class="c1"># which would imply a bad GPU node.</span>
                <span class="k">if</span> <span class="s2">&quot;vis_weight&quot;</span> <span class="ow">in</span> <span class="n">timestream</span><span class="o">.</span><span class="n">flags</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">timestream</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="n">fi_dist</span><span class="p">]):</span>
                        <span class="k">continue</span>

                <span class="c1"># Run good channels code and unpack arguments</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">data_quality</span><span class="o">.</span><span class="n">good_channels</span><span class="p">(</span>
                    <span class="n">timestream</span><span class="p">,</span> <span class="n">test_freq</span><span class="o">=</span><span class="n">fi_dist</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="n">inputmap</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>
                <span class="n">good_gains</span><span class="p">,</span> <span class="n">good_noise</span><span class="p">,</span> <span class="n">good_fit</span><span class="p">,</span> <span class="n">test_inputs</span> <span class="o">=</span> <span class="n">res</span>

                <span class="c1"># Save the results to local array</span>
                <span class="k">if</span> <span class="n">good_gains</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">passed_test</span><span class="p">[</span><span class="n">fi_local</span><span class="p">,</span> <span class="n">test_inputs</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">good_gains</span>

                <span class="k">if</span> <span class="n">good_noise</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">passed_test</span><span class="p">[</span><span class="n">fi_local</span><span class="p">,</span> <span class="n">test_inputs</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">good_noise</span>

                <span class="k">if</span> <span class="n">good_fit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">passed_test</span><span class="p">[</span><span class="n">fi_local</span><span class="p">,</span> <span class="n">test_inputs</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">good_fit</span>

                <span class="n">is_test_freq</span><span class="p">[</span><span class="n">fi_local</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># Print results for this frequency</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">&quot;Frequency </span><span class="si">{}</span><span class="s2"> bad inputs: blank </span><span class="si">{}</span><span class="s2">; gains </span><span class="si">{}{}</span><span class="s2">; noise </span><span class="si">{}{}</span><span class="s2">; fit </span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">fi_dist</span><span class="p">,</span>
                        <span class="n">timestream</span><span class="o">.</span><span class="n">ninput</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">test_inputs</span><span class="p">),</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">good_gains</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">good_gains</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;failed&quot;</span><span class="p">,</span>
                        <span class="s2">&quot; [ignored]&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_gains</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">good_noise</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">good_noise</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;failed&quot;</span><span class="p">,</span>
                        <span class="s2">&quot; [ignored]&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_noise</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">good_fit</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">good_fit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;failed&quot;</span><span class="p">,</span>
                        <span class="s2">&quot; [ignored]&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_fit</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="c1"># Gather the input flags from all nodes</span>
        <span class="n">passed_test_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="n">timestream</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">timestream</span><span class="o">.</span><span class="n">ninput</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ntest</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span>
        <span class="p">)</span>
        <span class="n">is_test_freq_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">timestream</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="n">timestream</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Allgather</span><span class="p">(</span><span class="n">passed_test</span><span class="p">,</span> <span class="n">passed_test_all</span><span class="p">)</span>
        <span class="n">timestream</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Allgather</span><span class="p">(</span><span class="n">is_test_freq</span><span class="p">,</span> <span class="n">is_test_freq_all</span><span class="p">)</span>

        <span class="c1"># Keep only the test frequencies</span>
        <span class="n">passed_test_all</span> <span class="o">=</span> <span class="n">passed_test_all</span><span class="p">[</span><span class="n">is_test_freq_all</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
        <span class="n">freqmap</span> <span class="o">=</span> <span class="n">freqmap</span><span class="p">[</span><span class="n">is_test_freq_all</span><span class="p">]</span>

        <span class="c1"># Average over frequencies</span>
        <span class="n">input_mask_all</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">passed_test_all</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">passed_test_all</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span>

        <span class="c1"># Take the product along the test direction to determine good inputs for each frequency</span>
        <span class="n">input_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">input_mask_all</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_test</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Create container to hold results</span>
        <span class="n">corr_input_test</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">CorrInputTest</span><span class="p">(</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">freqmap</span><span class="p">,</span> <span class="n">test</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">test</span><span class="p">,</span> <span class="n">axes_from</span><span class="o">=</span><span class="n">timestream</span><span class="p">,</span> <span class="n">attrs_from</span><span class="o">=</span><span class="n">timestream</span>
        <span class="p">)</span>

        <span class="c1"># Save flags to container, return container</span>
        <span class="n">corr_input_test</span><span class="o">.</span><span class="n">input_mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">input_mask</span>

        <span class="n">corr_input_test</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;passed_test&quot;</span><span class="p">)</span>
        <span class="n">corr_input_test</span><span class="o">.</span><span class="n">passed_test</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">passed_test_all</span>

        <span class="k">return</span> <span class="n">corr_input_test</span></div>
</div>



<div class="viewcode-block" id="AccumulateCorrInputMask">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.AccumulateCorrInputMask">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">AccumulateCorrInputMask</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find good correlator inputs over multiple sidereal days.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_day_min : int</span>
<span class="sd">        Do not apply a sidereal day flag if the number of days</span>
<span class="sd">        in the pass is less than n_day_min.  Default is 3.</span>

<span class="sd">    n_cut : int</span>
<span class="sd">        Flag a sidereal day as bad if the number of correlator</span>
<span class="sd">        inputs that are uniquely flagged bad on that day is</span>
<span class="sd">        greater than n_cut.  Default is 5.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_day_min</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">n_cut</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create empty lists.</span>

<span class="sd">        As we iterate through sidereal days, we will append the corr_input_mask</span>
<span class="sd">        from each day to this list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_accumulated_input_mask</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_csd</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="AccumulateCorrInputMask.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.AccumulateCorrInputMask.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">corr_input_mask</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Append corr_input_mask to list.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        corr_input_mask : containers.CorrInputMask</span>
<span class="sd">            Mask flagging good correlator inputs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_accumulated_input_mask</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input</span> <span class="o">=</span> <span class="n">corr_input_mask</span><span class="o">.</span><span class="n">input</span><span class="p">[:]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_accumulated_input_mask</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">corr_input_mask</span><span class="o">.</span><span class="n">input_mask</span><span class="p">[:])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_csd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">corr_input_mask</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;csd&quot;</span><span class="p">])</span></div>


<div class="viewcode-block" id="AccumulateCorrInputMask.process_finish">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.AccumulateCorrInputMask.process_finish">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process_finish</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the product of the input mask for all good days.</span>

<span class="sd">        Determine good days as those where the fraction</span>
<span class="sd">        of good inputs is above some user specified</span>
<span class="sd">        threshold.  Then create accumulated input mask</span>
<span class="sd">        by taking the product of the input mask for all</span>
<span class="sd">        good days.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        corr_input_mask : containers.CorrInputMask</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ncsd</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_csd</span><span class="p">)</span>

        <span class="n">input_mask_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_accumulated_input_mask</span><span class="p">)</span>

        <span class="n">good_day_flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">ncsd</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="c1"># Find days where the number of correlator inputs that are bad</span>
        <span class="c1"># ONLY for this day is greater than some user specified threshold</span>
        <span class="k">if</span> <span class="n">ncsd</span> <span class="o">&gt;=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_day_min</span><span class="p">):</span>
            <span class="n">n_uniq_bad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ncsd</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
            <span class="n">dindex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ncsd</span><span class="p">)[</span><span class="n">good_day_flag</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">day</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dindex</span><span class="p">):</span>
                <span class="n">other_days</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">dindex</span><span class="p">,</span> <span class="n">ii</span><span class="p">)</span>
                <span class="n">n_uniq_bad</span><span class="p">[</span><span class="n">day</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="o">~</span><span class="n">input_mask_all</span><span class="p">[</span><span class="n">day</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">input_mask_all</span><span class="p">[</span><span class="n">other_days</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="n">good_day_flag</span> <span class="o">*=</span> <span class="n">n_uniq_bad</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_cut</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">good_day_flag</span><span class="p">):</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Significant number of new correlator inputs flagged bad each day.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Write csd flag to file</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">:</span>
            <span class="c1"># Create container</span>
            <span class="n">csd_flag</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealDayFlag</span><span class="p">(</span><span class="n">csd</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_csd</span><span class="p">))</span>

            <span class="c1"># Save flags to container</span>
            <span class="n">csd_flag</span><span class="o">.</span><span class="n">csd_flag</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">good_day_flag</span>

            <span class="n">csd_flag</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;flag_csd&quot;</span>

            <span class="c1"># Write output to hdf5 file</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_output</span><span class="p">(</span><span class="n">csd_flag</span><span class="p">)</span>

        <span class="c1"># Take the product of the input mask for all days that made threshold cut</span>
        <span class="n">input_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">input_mask_all</span><span class="p">[</span><span class="n">good_day_flag</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Create container to hold results</span>
        <span class="n">corr_input_mask</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">CorrInputMask</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="p">)</span>

        <span class="n">corr_input_mask</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;for_pass&quot;</span>

        <span class="c1"># Save input_mask to container, return container</span>
        <span class="n">corr_input_mask</span><span class="o">.</span><span class="n">input_mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">input_mask</span>

        <span class="k">return</span> <span class="n">corr_input_mask</span></div>
</div>



<div class="viewcode-block" id="ApplyCorrInputMask">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.ApplyCorrInputMask">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ApplyCorrInputMask</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply an input mask to a timestream.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="ApplyCorrInputMask.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.ApplyCorrInputMask.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestream</span><span class="p">,</span> <span class="n">cmask</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Flag out events by giving them zero weight.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestream : andata.CorrData or dcontainers.SiderealStream</span>
<span class="sd">            timestream data container</span>

<span class="sd">        cmask : containers.RFIMask, containers.CorrInputMask, etc.</span>
<span class="sd">            input mask container</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        timestream : andata.CorrData or dcontainers.SiderealStream</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure containers are distributed across frequency</span>
        <span class="n">timestream</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>
        <span class="n">cmask</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Create a slice that will expand the mask to</span>
        <span class="c1"># the same dimensions as the weight array</span>
        <span class="n">waxis</span> <span class="o">=</span> <span class="n">timestream</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span>
        <span class="n">slc</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">waxis</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ww</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">waxis</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;stack&quot;</span><span class="p">,</span> <span class="s2">&quot;prod&quot;</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cmask</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="n">slc</span><span class="p">[</span><span class="n">ww</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Extract input mask and weight array</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">timestream</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">cmask</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">weight</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Expand mask to same dimension as weight array</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slc</span><span class="p">)]</span>

        <span class="c1"># Determine mapping between inputs in the mask</span>
        <span class="c1"># and inputs in the timestream</span>
        <span class="n">mask_input</span> <span class="o">=</span> <span class="n">cmask</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">][:]</span>
        <span class="n">nminput</span> <span class="o">=</span> <span class="n">mask_input</span><span class="o">.</span><span class="n">size</span>

        <span class="n">tstream_input</span> <span class="o">=</span> <span class="n">timestream</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">][:]</span>
        <span class="n">ntinput</span> <span class="o">=</span> <span class="n">tstream_input</span><span class="o">.</span><span class="n">size</span>

        <span class="k">if</span> <span class="n">nminput</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Apply same mask to all products</span>
            <span class="n">weight</span> <span class="o">*=</span> <span class="n">mask</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Map each input to a mask</span>
            <span class="k">if</span> <span class="n">nminput</span> <span class="o">&lt;</span> <span class="n">ntinput</span><span class="p">:</span>
                <span class="c1"># The expression below will expand a mask constructed from the stacked</span>
                <span class="c1"># autocorrelation data for each cylinder/polarisation to the inputs from</span>
                <span class="c1"># that cylinder/polarisation.  However, we may want to make this more robust</span>
                <span class="c1"># and explicit by passing a telescope object or list of correlator inputs</span>
                <span class="c1"># and determining the cylinder/polarisation mapping from that.</span>
                <span class="n">iexpand</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ntinput</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mask_input</span><span class="p">[</span><span class="s2">&quot;chan_id&quot;</span><span class="p">],</span> <span class="n">ntinput</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="o">-</span> <span class="mi">1</span>
                <span class="p">)</span>

                <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[:,</span> <span class="n">iexpand</span><span class="p">]</span>

            <span class="c1"># Use apply_gain function to apply mask based on product map</span>
            <span class="n">prod</span> <span class="o">=</span> <span class="n">timestream</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;prod&quot;</span><span class="p">][</span><span class="n">timestream</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;stack&quot;</span><span class="p">][</span><span class="s2">&quot;prod&quot;</span><span class="p">]]</span>
            <span class="n">tools</span><span class="o">.</span><span class="n">apply_gain</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">prod_map</span><span class="o">=</span><span class="n">prod</span><span class="p">)</span>

        <span class="c1"># Return timestream</span>
        <span class="k">return</span> <span class="n">timestream</span></div>
</div>



<div class="viewcode-block" id="ApplySiderealDayFlag">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.ApplySiderealDayFlag">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ApplySiderealDayFlag</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Prevent certain sidereal days from progressing further in the pipeline.</span>

<span class="sd">    example: exclude certain sidereal days from the sidereal stack.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ApplySiderealDayFlag.setup">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.ApplySiderealDayFlag.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">csd_flag</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create dictionary from input .&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">csd_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">cc</span><span class="p">,</span> <span class="n">csd</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">csd_flag</span><span class="o">.</span><span class="n">csd</span><span class="p">[:]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">csd_dict</span><span class="p">[</span><span class="n">csd</span><span class="p">]</span> <span class="o">=</span> <span class="n">csd_flag</span><span class="o">.</span><span class="n">csd_flag</span><span class="p">[</span><span class="n">cc</span><span class="p">]</span></div>


<div class="viewcode-block" id="ApplySiderealDayFlag.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.ApplySiderealDayFlag.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestream</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if this sidereal day should continue processing.</span>

<span class="sd">        If this sidereal day is flagged as good or</span>
<span class="sd">        if no flag is specified for this sidereal day,</span>
<span class="sd">        then return the timestream.  If this sidereal day</span>
<span class="sd">        is flagged as bad, then return None.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestream : andata.CorrData / dcontainers.SiderealStream</span>
<span class="sd">            timestream data container. Should have a &#39;lsd&#39; or &#39;csd&#39; attribute.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        timestream : andata.CorrData / dcontainers.SiderealStream or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Fetch the csd from the timestream attributes</span>
        <span class="k">if</span> <span class="s2">&quot;lsd&quot;</span> <span class="ow">in</span> <span class="n">timestream</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
            <span class="n">this_csd</span> <span class="o">=</span> <span class="n">timestream</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;lsd&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="s2">&quot;csd&quot;</span> <span class="ow">in</span> <span class="n">timestream</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
            <span class="n">this_csd</span> <span class="o">=</span> <span class="n">timestream</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;csd&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">this_csd</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Is this csd specified in the file?</span>
        <span class="k">if</span> <span class="n">this_csd</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">csd_dict</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">timestream</span>

            <span class="k">if</span> <span class="n">this_csd</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Warning: input timestream does not have &#39;csd&#39;/&#39;lsd&#39; attribute.  &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;Will continue pipeline processing.&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Warning: status of CSD </span><span class="si">%d</span><span class="s2"> not given in </span><span class="si">%s</span><span class="s2">.  &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;Will continue pipeline processing.&quot;</span>
                <span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">this_csd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_name</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Is this csd flagged good?</span>
            <span class="n">this_flag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">csd_dict</span><span class="p">[</span><span class="n">this_csd</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">this_flag</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">timestream</span>

                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;CSD </span><span class="si">%d</span><span class="s2"> flagged good.  &quot;</span> <span class="o">+</span> <span class="s2">&quot;Will continue pipeline processing.&quot;</span>
                <span class="p">)</span> <span class="o">%</span> <span class="n">this_csd</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;CSD </span><span class="si">%d</span><span class="s2"> flagged bad.  &quot;</span> <span class="o">+</span> <span class="s2">&quot;Will halt pipeline processing.&quot;</span>
                <span class="p">)</span> <span class="o">%</span> <span class="n">this_csd</span>

        <span class="c1"># Print whether or not we will continue processing this csd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># Return input timestream or None</span>
        <span class="k">return</span> <span class="n">output</span></div>
</div>



<div class="viewcode-block" id="NanToNum">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.NanToNum">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">NanToNum</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Finds NaN and replaces with 0.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="NanToNum.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.NanToNum.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestream</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts any NaN in the vis dataset and weight dataset to the value 0.0.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestream : andata.CorrData or dcontainers.SiderealStream</span>
<span class="sd">            timestream container to check</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        timestream : andata.CorrData or dcontainers.SiderealStream</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure we are distributed over frequency</span>
        <span class="n">timestream</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Loop over frequencies to reduce memory usage</span>
        <span class="k">for</span> <span class="n">lfi</span><span class="p">,</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">timestream</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">enumerate</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
            <span class="c1"># Set non-finite values of the visibility equal to zero</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">timestream</span><span class="o">.</span><span class="n">vis</span><span class="p">[</span><span class="n">fi</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">flag</span><span class="p">):</span>
                <span class="n">timestream</span><span class="o">.</span><span class="n">vis</span><span class="p">[</span><span class="n">fi</span><span class="p">][</span><span class="n">flag</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">timestream</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="n">fi</span><span class="p">][</span>
                    <span class="n">flag</span>
                <span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># Also set weights to zero so we don&#39;t trust values</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> visibilities are non finite for &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;frequency=</span><span class="si">{</span><span class="n">fi</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="mi">100</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">flag</span><span class="o">.</span><span class="n">size</span><span class="si">:</span><span class="s2">0.2f</span><span class="si">}</span><span class="s2">%)&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Set non-finite values of the weight equal to zero</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">timestream</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="n">fi</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">flag</span><span class="p">):</span>
                <span class="n">timestream</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="n">fi</span><span class="p">][</span><span class="n">flag</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> weights are non finite for &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;frequency=</span><span class="si">{</span><span class="n">fi</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="mi">100</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">flag</span><span class="o">.</span><span class="n">size</span><span class="si">:</span><span class="s2">0.2f</span><span class="si">}</span><span class="s2">%)&quot;</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">timestream</span></div>
</div>



<div class="viewcode-block" id="RadiometerWeight">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.RadiometerWeight">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">RadiometerWeight</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Update vis_weight according to the radiometer equation.</span>

<span class="sd">    vis_weight_ij = Nsamples / V_ii V_jj</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RadiometerWeight.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.RadiometerWeight.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestream</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update the `vis_weight` dataset.</span>

<span class="sd">        Takes the input timestream.flags[&#39;vis_weight&#39;], recasts it from uint8 to float32,</span>
<span class="sd">        multiplies by the total number of samples, and divides by the autocorrelations of the</span>
<span class="sd">        two feeds that form each baseline.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestream : andata.CorrData</span>
<span class="sd">            timestream data to process</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        timestream : andata.CorrData</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.calibration</span><span class="w"> </span><span class="kn">import</span> <span class="n">_extract_diagonal</span> <span class="k">as</span> <span class="n">diag</span>

        <span class="c1"># Redistribute over the frequency direction</span>
        <span class="n">timestream</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">timestream</span><span class="p">,</span> <span class="n">andata</span><span class="o">.</span><span class="n">CorrData</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Converting weights to effective number of samples.&quot;</span><span class="p">)</span>

            <span class="c1"># Extract number of samples per integration period</span>
            <span class="n">max_nsamples</span> <span class="o">=</span> <span class="n">timestream</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;gpu.gpu_intergration_period&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Extract the maximum possible value of vis_weight</span>
            <span class="n">max_vis_weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">timestream</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;vis_weight&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>

            <span class="c1"># Calculate the scaling factor that converts from vis_weight value</span>
            <span class="c1"># to number of samples</span>
            <span class="n">vw_to_nsamp</span> <span class="o">=</span> <span class="n">max_nsamples</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">max_vis_weight</span><span class="p">)</span>

            <span class="c1"># Scale vis_weight by the effective number of samples</span>
            <span class="n">vis_weight</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">timestream</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;vis_weight&quot;</span><span class="p">][:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">*</span> <span class="n">vw_to_nsamp</span>
            <span class="p">)</span>

            <span class="c1"># Recast vis_weight as float32</span>
            <span class="c1"># Wrap to produce MPIArray</span>
            <span class="n">vis_weight</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span>
                <span class="n">vis_weight</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">timestream</span><span class="o">.</span><span class="n">comm</span>
            <span class="p">)</span>

            <span class="c1"># Extract attributes</span>
            <span class="n">vis_weight_attrs</span> <span class="o">=</span> <span class="n">memh5</span><span class="o">.</span><span class="n">attrs2dict</span><span class="p">(</span><span class="n">timestream</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;vis_weight&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>

            <span class="c1"># Delete current uint8 dataset</span>
            <span class="n">timestream</span><span class="p">[</span><span class="s2">&quot;flags&quot;</span><span class="p">]</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="s2">&quot;vis_weight&quot;</span><span class="p">)</span>

            <span class="c1"># Create new float32 dataset</span>
            <span class="n">vis_weight_dataset</span> <span class="o">=</span> <span class="n">timestream</span><span class="o">.</span><span class="n">create_flag</span><span class="p">(</span>
                <span class="s2">&quot;vis_weight&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">vis_weight</span><span class="p">,</span> <span class="n">distributed</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

            <span class="c1"># Copy attributes</span>
            <span class="n">memh5</span><span class="o">.</span><span class="n">copyattrs</span><span class="p">(</span><span class="n">vis_weight_attrs</span><span class="p">,</span> <span class="n">vis_weight_dataset</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">timestream</span><span class="p">,</span> <span class="n">dcontainers</span><span class="o">.</span><span class="n">SiderealStream</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Scaling weights by outer product of inverse receiver temperature.&quot;</span>
            <span class="p">)</span>

            <span class="c1"># Extract the autocorrelation</span>
            <span class="n">Trec</span> <span class="o">=</span> <span class="n">diag</span><span class="p">(</span><span class="n">timestream</span><span class="o">.</span><span class="n">vis</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>

            <span class="c1"># Invert the autocorrelation</span>
            <span class="n">inv_Trec</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">Trec</span><span class="p">)</span>

            <span class="c1"># Scale the weights by the outerproduct of the inverse autocorrelations</span>
            <span class="n">tools</span><span class="o">.</span><span class="n">apply_gain</span><span class="p">(</span><span class="n">timestream</span><span class="o">.</span><span class="n">weight</span><span class="p">[:],</span> <span class="n">inv_Trec</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">timestream</span><span class="o">.</span><span class="n">weight</span><span class="p">[:])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Format of `timestream` argument is unknown.&quot;</span><span class="p">)</span>

        <span class="c1"># Return timestream with updated weights</span>
        <span class="k">return</span> <span class="n">timestream</span></div>
</div>



<div class="viewcode-block" id="BadNodeFlagger">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.BadNodeFlagger">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BadNodeFlagger</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Flag out bad GPU nodes by giving zero weight to their frequencies.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nodes : list of ints</span>
<span class="sd">        Indices of bad nodes to flag.</span>
<span class="sd">    nodes_by_acq : dict</span>
<span class="sd">        Dictionary whose entries have the name of the acquisition as keyword</span>
<span class="sd">        and a list of the nodes to flag as bad for that acquisition as value.</span>
<span class="sd">    flag_freq_zero : boolean, optional</span>
<span class="sd">        Whether to flag out frequency zero.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nodes</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">[])</span>
    <span class="n">nodes_by_acq</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">dict</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">{})</span>

    <span class="n">flag_freq_zero</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="BadNodeFlagger.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.BadNodeFlagger.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestream</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Flag out bad nodes by giving them zero weight.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestream : andata.CorrData or dcontainers.SiderealStream</span>
<span class="sd">            timestream data to process</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        flagged_timestream : same type as timestream</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Redistribute over frequency</span>
        <span class="n">timestream</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Determine local frequencies</span>
        <span class="n">sf</span> <span class="o">=</span> <span class="n">timestream</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">local_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ef</span> <span class="o">=</span> <span class="n">sf</span> <span class="o">+</span> <span class="n">timestream</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">local_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Extract autocorrelation indices</span>
        <span class="n">auto_pi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">ii</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">pp</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">timestream</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;prod&quot;</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">pp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">pp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Create bad node flag by checking for frequencies/time samples where</span>
        <span class="c1"># the autocorrelations are all zero</span>
        <span class="n">good_freq_flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">timestream</span><span class="o">.</span><span class="n">vis</span><span class="p">[:,</span> <span class="n">auto_pi</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">real</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Apply bad node flag</span>
        <span class="n">timestream</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">good_freq_flag</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># If requested, flag the first frequency</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flag_freq_zero</span> <span class="ow">and</span> <span class="n">mpiutil</span><span class="o">.</span><span class="n">rank0</span><span class="p">:</span>
            <span class="n">timestream</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Set up map from frequency to node</span>
        <span class="n">basefreq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">800.0</span><span class="p">,</span> <span class="mf">400.0</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">nodelist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ff</span> <span class="o">-</span> <span class="n">basefreq</span><span class="p">))</span> <span class="o">%</span> <span class="mi">16</span> <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="n">timestream</span><span class="o">.</span><span class="n">freq</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Manually flag frequencies corresponding to specific GPU nodes</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">nind</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">nodelist</span> <span class="o">==</span> <span class="n">node</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">nind</span> <span class="o">&gt;=</span> <span class="n">sf</span> <span class="ow">and</span> <span class="n">nind</span> <span class="o">&lt;</span> <span class="n">ef</span><span class="p">:</span>
                    <span class="n">timestream</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="n">nind</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Flagging node </span><span class="si">%d</span><span class="s2">, freq </span><span class="si">%d</span><span class="s2">.&quot;</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">nind</span><span class="p">)</span>

        <span class="c1"># Manually flag frequencies corresponding to specific GPU nodes on specific acquisitions</span>
        <span class="n">this_acq</span> <span class="o">=</span> <span class="n">timestream</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;acquisition_name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">this_acq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_by_acq</span><span class="p">:</span>
            <span class="c1"># Grab list of nodes from input dictionary</span>
            <span class="n">nodes_to_flag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_by_acq</span><span class="p">[</span><span class="n">this_acq</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">nodes_to_flag</span><span class="p">,</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">):</span>
                <span class="n">nodes_to_flag</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodes_to_flag</span><span class="p">]</span>

            <span class="c1"># Loop over nodes and perform flagging</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes_to_flag</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">nind</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">nodelist</span> <span class="o">==</span> <span class="n">node</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">nind</span> <span class="o">&gt;=</span> <span class="n">sf</span> <span class="ow">and</span> <span class="n">nind</span> <span class="o">&lt;</span> <span class="n">ef</span><span class="p">:</span>
                        <span class="n">timestream</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="n">nind</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                            <span class="s2">&quot;Flagging node </span><span class="si">%d</span><span class="s2">, freq </span><span class="si">%d</span><span class="s2">.&quot;</span><span class="p">,</span> <span class="n">mpiutil</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">nind</span>
                        <span class="p">)</span>

        <span class="c1"># Return timestream with bad nodes flagged</span>
        <span class="k">return</span> <span class="n">timestream</span></div>
</div>



<div class="viewcode-block" id="daytime_flag">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.daytime_flag">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">daytime_flag</span><span class="p">(</span><span class="n">time</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a flag that indicates if times occur during the day.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    time : np.ndarray[ntime,]</span>
<span class="sd">        Unix timestamps.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    flag : np.ndarray[ntime,]</span>
<span class="sd">        Boolean flag that is True if the time occured during the day and False otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="n">rise</span> <span class="o">=</span> <span class="n">chime</span><span class="o">.</span><span class="n">solar_rising</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">-</span> <span class="mf">24.0</span> <span class="o">*</span> <span class="mf">3600.0</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">rr</span> <span class="ow">in</span> <span class="n">rise</span><span class="p">:</span>
        <span class="n">ss</span> <span class="o">=</span> <span class="n">chime</span><span class="o">.</span><span class="n">solar_setting</span><span class="p">(</span><span class="n">rr</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">flag</span> <span class="o">|=</span> <span class="p">(</span><span class="n">time</span> <span class="o">&gt;=</span> <span class="n">rr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">time</span> <span class="o">&lt;=</span> <span class="n">ss</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">flag</span></div>



<div class="viewcode-block" id="transit_flag">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.transit_flag">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">transit_flag</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">nsigma</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mf">400.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a flag that indicates if times occured near transit of a celestial body.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    body : skyfield.starlib.Star</span>
<span class="sd">        Skyfield representation of a celestial body.</span>
<span class="sd">    time : np.ndarray[ntime]</span>
<span class="sd">        Unix timestamps.</span>
<span class="sd">    nsigma : float</span>
<span class="sd">        Number of sigma to flag on either side of transit.</span>
<span class="sd">    freq : float or np.ndarray[nfreq]</span>
<span class="sd">        Evaluate the beam width at this frequency in MHz.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    flag : np.ndarray[ntime] or np.ndarray[nfreq, ntime]</span>
<span class="sd">        Boolean flag that is True if the times occur within nsigma of transit</span>
<span class="sd">        and False otherwise.  This will have a single dimension if freq is a scalar.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="n">obs</span> <span class="o">=</span> <span class="n">chime</span>

    <span class="c1"># Create boolean flag</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">freq</span><span class="p">):</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">freq</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">freq</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="c1"># Find transit times</span>
    <span class="n">transit_times</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">transit_times</span><span class="p">(</span>
        <span class="n">body</span><span class="p">,</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">24.0</span> <span class="o">*</span> <span class="mf">3600.0</span><span class="p">,</span> <span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">24.0</span> <span class="o">*</span> <span class="mf">3600.0</span>
    <span class="p">)</span>

    <span class="c1"># Loop over transit times</span>
    <span class="k">for</span> <span class="n">ttrans</span> <span class="ow">in</span> <span class="n">transit_times</span><span class="p">:</span>
        <span class="c1"># Compute source coordinates</span>
        <span class="n">sf_time</span> <span class="o">=</span> <span class="n">ctime</span><span class="o">.</span><span class="n">unix_to_skyfield_time</span><span class="p">(</span><span class="n">ttrans</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">skyfield_obs</span><span class="p">()</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">sf_time</span><span class="p">)</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>

        <span class="n">alt</span> <span class="o">=</span> <span class="n">pos</span><span class="o">.</span><span class="n">apparent</span><span class="p">()</span><span class="o">.</span><span class="n">altaz</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dec</span> <span class="o">=</span> <span class="n">pos</span><span class="o">.</span><span class="n">cirs_radec</span><span class="p">(</span><span class="n">sf_time</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Make sure body is above horizon</span>
        <span class="k">if</span> <span class="n">alt</span><span class="o">.</span><span class="n">radians</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="c1"># Estimate the amount of time the body is in the primary beam</span>
            <span class="c1"># as +/- nsigma sigma, where sigma denotes the width of the</span>
            <span class="c1"># primary beam.  We use the lowest frequency and E-W (or X) polarisation,</span>
            <span class="c1"># since this is the most conservative (largest sigma).</span>
            <span class="n">window_deg</span> <span class="o">=</span> <span class="n">nsigma</span> <span class="o">*</span> <span class="n">cal_utils</span><span class="o">.</span><span class="n">guess_fwhm</span><span class="p">(</span>
                <span class="n">freq</span><span class="p">,</span> <span class="n">pol</span><span class="o">=</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="n">dec</span><span class="o">=</span><span class="n">dec</span><span class="o">.</span><span class="n">radians</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="n">window_sec</span> <span class="o">=</span> <span class="n">window_deg</span> <span class="o">*</span> <span class="mf">240.0</span> <span class="o">*</span> <span class="n">ctime</span><span class="o">.</span><span class="n">SIDEREAL_S</span>

            <span class="c1"># Flag +/- window_sec around transit time</span>
            <span class="n">begin</span> <span class="o">=</span> <span class="n">ttrans</span> <span class="o">-</span> <span class="n">window_sec</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">ttrans</span> <span class="o">+</span> <span class="n">window_sec</span>
            <span class="n">flag</span> <span class="o">|=</span> <span class="p">(</span><span class="n">time</span> <span class="o">&gt;=</span> <span class="n">begin</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">time</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span>

    <span class="c1"># Return boolean flag indicating times near transit</span>
    <span class="k">return</span> <span class="n">flag</span></div>



<div class="viewcode-block" id="taper_mask">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.taper_mask">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">taper_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">nwidth</span><span class="p">,</span> <span class="n">outer</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply a taper to a mask via a Hanning window.&quot;&quot;&quot;</span>
    <span class="n">num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">outer</span><span class="p">:</span>
        <span class="n">tapered_mask</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tapered_mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="n">taper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">nwidth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">dmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">tapered_mask</span><span class="p">)</span>
    <span class="n">transition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dmask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">transition</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dmask</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">tt</span> <span class="o">+</span> <span class="n">nwidth</span><span class="p">)</span>
            <span class="n">tapered_mask</span><span class="p">[</span><span class="n">ind</span> <span class="o">%</span> <span class="n">num</span><span class="p">]</span> <span class="o">*=</span> <span class="n">taper</span><span class="p">[:</span><span class="n">nwidth</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">tt</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">nwidth</span><span class="p">,</span> <span class="n">tt</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">tapered_mask</span><span class="p">[</span><span class="n">ind</span> <span class="o">%</span> <span class="n">num</span><span class="p">]</span> <span class="o">*=</span> <span class="n">taper</span><span class="p">[</span><span class="o">-</span><span class="n">nwidth</span><span class="p">:]</span>

    <span class="k">if</span> <span class="n">outer</span><span class="p">:</span>
        <span class="n">tapered_mask</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">tapered_mask</span>

    <span class="k">return</span> <span class="n">tapered_mask</span></div>



<div class="viewcode-block" id="MaskDay">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.MaskDay">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MaskDay</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mask out the daytime data.</span>

<span class="sd">    This task can also act as a base class for applying an arbitrary</span>
<span class="sd">    mask to the data based on time.  This is achieved by redefining</span>
<span class="sd">    the `_flag` method.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    zero_data : bool, optional</span>
<span class="sd">        Zero the data in addition to modifying the noise weights</span>
<span class="sd">    taper_width : float, optional</span>
<span class="sd">        Width (in seconds) of the taper applied to the mask.  Creates a smooth transition from</span>
<span class="sd">        masked to unmasked regions using a cosine function.  Set to 0.0 for no taper (default).</span>
<span class="sd">    outer_taper : bool, optional</span>
<span class="sd">        If outer_taper is True, then the taper occurs in the unmasked region.</span>
<span class="sd">        If outer_taper is False, then the taper occurs in the masked region.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">zero_data</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">taper_width</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="n">outer_taper</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<div class="viewcode-block" id="MaskDay.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.MaskDay.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dstream</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the weight to zero during day time.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dstream : dcontainers.SiderealStream or equivalent</span>
<span class="sd">            Data stream to be masked. Must have a time or ra axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mstream : dcontainers.SiderealStream or equivalent</span>
<span class="sd">            Masked data stream.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Redistribute over frequency</span>
        <span class="n">dstream</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Get flag that indicates day times (RAs)</span>
        <span class="k">if</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">dstream</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">dstream</span><span class="o">.</span><span class="n">time</span><span class="p">[:]</span>
            <span class="n">ntaper</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">taper_width</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">time</span><span class="p">))))</span>

            <span class="n">flag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flag</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Fetch either the LSD or CSD attribute.  In the case of a SidrealStack,</span>
            <span class="c1"># there will be multiple LSDs and the flag will be the logical OR of the</span>
            <span class="c1"># flag from each individual LSD.</span>
            <span class="n">csd</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">dstream</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;lsd&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;lsd&quot;</span> <span class="ow">in</span> <span class="n">dstream</span><span class="o">.</span><span class="n">attrs</span> <span class="k">else</span> <span class="n">dstream</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;csd&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">csd</span><span class="p">,</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">):</span>
                <span class="n">csd</span> <span class="o">=</span> <span class="p">[</span><span class="n">csd</span><span class="p">]</span>

            <span class="n">ra</span> <span class="o">=</span> <span class="n">dstream</span><span class="o">.</span><span class="n">ra</span><span class="p">[:]</span>
            <span class="n">ntaper</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">taper_width</span>
                <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ra</span><span class="p">)))</span> <span class="o">*</span> <span class="mf">240.0</span> <span class="o">*</span> <span class="n">ctime</span><span class="o">.</span><span class="n">SIDEREAL_S</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="n">flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ra</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">csd</span><span class="p">:</span>
                <span class="n">time</span> <span class="o">=</span> <span class="n">chime</span><span class="o">.</span><span class="n">lsd_to_unix</span><span class="p">(</span><span class="n">cc</span> <span class="o">+</span> <span class="n">ra</span> <span class="o">/</span> <span class="mf">360.0</span><span class="p">)</span>
                <span class="n">flag</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flag</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

        <span class="c1"># Log how much data were masking</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="p">(</span><span class="mf">100.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">flag</span><span class="p">))</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> percent of data will be masked.&quot;</span><span class="p">)</span>

        <span class="c1"># Apply the mask</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">flag</span><span class="p">):</span>
            <span class="c1"># If requested, apply taper.</span>
            <span class="k">if</span> <span class="n">ntaper</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Applying taper over </span><span class="si">{</span><span class="n">ntaper</span><span class="si">}</span><span class="s2"> time samples.&quot;</span><span class="p">)</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="n">taper_mask</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="n">ntaper</span><span class="p">,</span> <span class="n">outer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">outer_taper</span><span class="p">)</span>

            <span class="c1"># Apply the mask to the weights</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">dstream</span><span class="p">,</span> <span class="s2">&quot;weight&quot;</span><span class="p">):</span>
                <span class="n">dstream</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">*=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">flag</span>

            <span class="c1"># If requested, apply the mask to the data</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">zero_data</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">dstream</span><span class="p">,</span> <span class="s2">&quot;vis&quot;</span><span class="p">):</span>
                <span class="n">dstream</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span> <span class="o">*=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">flag</span>

            <span class="c1"># If a mask dataset exists, apply the flag, accounting</span>
            <span class="c1"># for mask tapering</span>
            <span class="k">if</span> <span class="s2">&quot;mask&quot;</span> <span class="ow">in</span> <span class="n">dstream</span><span class="o">.</span><span class="n">datasets</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">outer_taper</span><span class="p">:</span>
                    <span class="n">dstream</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span> <span class="o">|=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dstream</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span> <span class="o">|=</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

        <span class="c1"># Return masked sidereal stream</span>
        <span class="k">return</span> <span class="n">dstream</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_flag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">daytime_flag</span><span class="p">(</span><span class="n">time</span><span class="p">)</span></div>



<span class="c1"># Alias DayMask to MaskDay for backwards compatibility</span>
<span class="n">DayMask</span> <span class="o">=</span> <span class="n">MaskDay</span>


<div class="viewcode-block" id="MaskSource">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.MaskSource">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MaskSource</span><span class="p">(</span><span class="n">MaskDay</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mask out data near source transits.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    source : str or list of str</span>
<span class="sd">        Name of the source(s) in the same format as `ch_ephem.sources.source_dictionary`.</span>
<span class="sd">    nsigma : float</span>
<span class="sd">        Mask this number of sigma on either side of source transit.</span>
<span class="sd">        Here sigma is the exepected width of the primary beam for</span>
<span class="sd">        an E-W polarisation antenna at 400 MHz as defined by the</span>
<span class="sd">        `ch_util.cal_utils.guess_fwhm` function.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">source</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">nsigma</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>

<div class="viewcode-block" id="MaskSource.setup">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.MaskSource.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save the skyfield bodies representing the sources to the `body` attribute.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Must specify name of the source to mask as config property.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Separate normal transits and antipodal transits</span>
        <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">source</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;_antipode&quot;</span><span class="p">)</span>
            <span class="n">body</span> <span class="o">=</span> <span class="n">sources</span><span class="o">.</span><span class="n">source_dictionary</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

            <span class="k">if</span> <span class="s2">&quot;antipode&quot;</span> <span class="ow">in</span> <span class="n">src</span><span class="p">:</span>
                <span class="c1"># Create a body at the antipode transit RA</span>
                <span class="n">body</span> <span class="o">=</span> <span class="n">ctime</span><span class="o">.</span><span class="n">skyfield_star_from_ra_dec</span><span class="p">(</span>
                    <span class="n">ra</span><span class="o">=</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">ra</span><span class="o">.</span><span class="n">_degrees</span> <span class="o">+</span> <span class="mi">180</span><span class="p">)</span> <span class="o">%</span> <span class="mi">360</span><span class="p">,</span>
                    <span class="n">dec</span><span class="o">=</span><span class="n">body</span><span class="o">.</span><span class="n">dec</span><span class="o">.</span><span class="n">_degrees</span><span class="p">,</span>
                    <span class="n">name</span><span class="o">=</span><span class="p">(</span><span class="n">src</span><span class="p">,),</span>
                <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">body</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_flag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">body</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="p">:</span>
            <span class="n">flag</span> <span class="o">|=</span> <span class="n">transit_flag</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">nsigma</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nsigma</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">flag</span></div>



<div class="viewcode-block" id="MaskSun">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.MaskSun">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MaskSun</span><span class="p">(</span><span class="n">MaskSource</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mask out data near solar transit.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="MaskSun.setup">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.MaskSun.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save the skyfield body for the sun.&quot;&quot;&quot;</span>
        <span class="n">planets</span> <span class="o">=</span> <span class="n">ctime</span><span class="o">.</span><span class="n">skyfield_wrapper</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;de421.bsp&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="p">[</span><span class="n">planets</span><span class="p">[</span><span class="s2">&quot;sun&quot;</span><span class="p">]]</span></div>
</div>



<div class="viewcode-block" id="MaskMoon">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.MaskMoon">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MaskMoon</span><span class="p">(</span><span class="n">MaskSource</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mask out data near lunar transit.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="MaskMoon.setup">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.MaskMoon.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save the skyfield body for the moon.&quot;&quot;&quot;</span>
        <span class="n">planets</span> <span class="o">=</span> <span class="n">ctime</span><span class="o">.</span><span class="n">skyfield_wrapper</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;de421.bsp&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="p">[</span><span class="n">planets</span><span class="p">[</span><span class="s2">&quot;moon&quot;</span><span class="p">]]</span></div>
</div>



<div class="viewcode-block" id="MaskRA">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.MaskRA">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MaskRA</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mask out a range in right ascension.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    start, end : float</span>
<span class="sd">        Start and end of masked out region.</span>
<span class="sd">    width : float</span>
<span class="sd">        Use a smooth transition of given width between the fully masked and</span>
<span class="sd">        unmasked data. This is interior to the region marked by start and end.</span>
<span class="sd">    zero_data : bool, optional</span>
<span class="sd">        Zero the data in addition to modifying the noise weights</span>
<span class="sd">        (default is True).</span>
<span class="sd">    remove_average : bool, optional</span>
<span class="sd">        Estimate and remove the mean level from each visibilty. This estimate</span>
<span class="sd">        does not use data from the masked region.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">90.0</span><span class="p">)</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">270.0</span><span class="p">)</span>

    <span class="n">width</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">60.0</span><span class="p">)</span>

    <span class="n">zero_data</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">remove_average</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<div class="viewcode-block" id="MaskRA.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.MaskRA.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sstream</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply a day time mask.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sstream : dcontainers.SiderealStream</span>
<span class="sd">            Unmasked sidereal stack.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mstream : dcontainers.SiderealStream</span>
<span class="sd">            Masked sidereal stream.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sstream</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="n">ra_shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">sstream</span><span class="o">.</span><span class="n">ra</span><span class="p">[:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">)</span> <span class="o">%</span> <span class="mf">360.0</span>
        <span class="n">end_shift</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">)</span> <span class="o">%</span> <span class="mf">360.0</span>

        <span class="c1"># Crudely mask the on and off regions</span>
        <span class="n">mask_bool</span> <span class="o">=</span> <span class="n">ra_shift</span> <span class="o">&gt;</span> <span class="n">end_shift</span>

        <span class="c1"># Put in the transition at the start of the day</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">ra_shift</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">,</span>
            <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">ra_shift</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">))),</span>
            <span class="n">mask_bool</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Put the transition at the end of the day</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">ra_shift</span> <span class="o">&gt;</span> <span class="n">end_shift</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">ra_shift</span> <span class="o">&lt;=</span> <span class="n">end_shift</span><span class="p">),</span>
            <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">((</span><span class="n">ra_shift</span> <span class="o">-</span> <span class="n">end_shift</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">))),</span>
            <span class="n">mask</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_average</span><span class="p">:</span>
            <span class="c1"># Estimate the mean level from unmasked data</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">scipy.stats</span>

            <span class="n">nanvis</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">sstream</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span>
                <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_bool</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
            <span class="p">)</span>
            <span class="n">average</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">nanvis</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="n">sstream</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span> <span class="o">-=</span> <span class="n">average</span>

        <span class="c1"># Apply the mask to the data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">zero_data</span><span class="p">:</span>
            <span class="n">sstream</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">mask</span>

        <span class="c1"># Modify the noise weights</span>
        <span class="n">sstream</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">mask</span><span class="o">**</span><span class="mi">2</span>

        <span class="k">return</span> <span class="n">sstream</span></div>
</div>



<div class="viewcode-block" id="MaskCHIMEData">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.MaskCHIMEData">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MaskCHIMEData</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mask out data ahead of map making.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    intra_cylinder : bool</span>
<span class="sd">        Include baselines within the same cylinder (default=True).</span>
<span class="sd">    xx_pol : bool</span>
<span class="sd">        Include X-polarisation (default=True).</span>
<span class="sd">    yy no_pol : bool</span>
<span class="sd">        Include Y-polarisation (default=True).</span>
<span class="sd">    cross_pol : bool</span>
<span class="sd">        Include cross-polarisation (default=True).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">intra_cylinder</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">xx_pol</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">yy_pol</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">cross_pol</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<div class="viewcode-block" id="MaskCHIMEData.setup">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.MaskCHIMEData.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tel</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Setup the task.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tel : :class:`ch_pipeline.core.pathfinder.CHIME`</span>
<span class="sd">            CHIME telescope class to use to get feed information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">get_telescope</span><span class="p">(</span><span class="n">tel</span><span class="p">)</span></div>


<div class="viewcode-block" id="MaskCHIMEData.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.MaskCHIMEData.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mmodes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mask out unwanted data in the m-modes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mmodes : dcontainers.MModes</span>
<span class="sd">            mmode dataset to process</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mmodes : dcontainers.MModes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span>

        <span class="n">mmodes</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">)</span>

        <span class="n">mw</span> <span class="o">=</span> <span class="n">mmodes</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span>

        <span class="k">for</span> <span class="n">pi</span><span class="p">,</span> <span class="p">(</span><span class="n">fi</span><span class="p">,</span> <span class="n">fj</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mmodes</span><span class="o">.</span><span class="n">prodstack</span><span class="p">):</span>
            <span class="n">oi</span><span class="p">,</span> <span class="n">oj</span> <span class="o">=</span> <span class="n">tel</span><span class="o">.</span><span class="n">feeds</span><span class="p">[</span><span class="n">fi</span><span class="p">],</span> <span class="n">tel</span><span class="o">.</span><span class="n">feeds</span><span class="p">[</span><span class="n">fj</span><span class="p">]</span>

            <span class="c1"># Check if baseline is intra-cylinder</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">intra_cylinder</span> <span class="ow">and</span> <span class="p">(</span><span class="n">oi</span><span class="o">.</span><span class="n">cyl</span> <span class="o">==</span> <span class="n">oj</span><span class="o">.</span><span class="n">cyl</span><span class="p">):</span>
                <span class="n">mw</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">pi</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="c1"># Check all the polarisation states</span>
            <span class="n">is_xx</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">is_array_x</span><span class="p">(</span><span class="n">oi</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tools</span><span class="o">.</span><span class="n">is_array_x</span><span class="p">(</span><span class="n">oj</span><span class="p">)</span>
            <span class="n">is_yy</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">is_array_y</span><span class="p">(</span><span class="n">oi</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tools</span><span class="o">.</span><span class="n">is_array_y</span><span class="p">(</span><span class="n">oj</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">xx_pol</span> <span class="ow">and</span> <span class="n">is_xx</span><span class="p">:</span>
                <span class="n">mw</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">pi</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">yy_pol</span> <span class="ow">and</span> <span class="n">is_yy</span><span class="p">:</span>
                <span class="n">mw</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">pi</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">cross_pol</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">is_xx</span> <span class="ow">or</span> <span class="n">is_yy</span><span class="p">):</span>
                <span class="n">mw</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">pi</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">return</span> <span class="n">mmodes</span></div>
</div>



<div class="viewcode-block" id="MaskCHIMEMisc">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.MaskCHIMEMisc">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MaskCHIMEMisc</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Some miscellaneous data masking routines.&quot;&quot;&quot;</span>

    <span class="n">mask_clock</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">mask_nodes</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">mask_freq</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

<div class="viewcode-block" id="MaskCHIMEMisc.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.MaskCHIMEMisc.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ss</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mask the 10 MHz clock line, specific nodes, and/or specified freqeuncies.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ss : containers.SiderealStream</span>
<span class="sd">            sidereal stream data to mask</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ss</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;prod&quot;</span><span class="p">)</span>

        <span class="c1"># Mask out the 10 MHz lines</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_clock</span><span class="p">:</span>
            <span class="c1"># Identify the frequency bins that contain the 10 MHz clock line</span>
            <span class="n">m10</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(((</span><span class="n">ss</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="s2">&quot;centre&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="o">%</span> <span class="mf">10.0</span><span class="p">)</span> <span class="o">-</span> <span class="mf">5.0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">ss</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="s2">&quot;width&quot;</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="n">ss</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">m10</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_nodes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node_index</span> <span class="o">=</span> <span class="p">((</span><span class="mf">800.0</span> <span class="o">-</span> <span class="n">ss</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="s2">&quot;centre&quot;</span><span class="p">])</span> <span class="o">/</span> <span class="mf">400.0</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="o">%</span> <span class="mi">16</span>

            <span class="k">for</span> <span class="n">ni</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_nodes</span><span class="p">:</span>
                <span class="n">node_mask</span> <span class="o">=</span> <span class="n">node_index</span> <span class="o">!=</span> <span class="n">ni</span>
                <span class="n">ss</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">node_mask</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="s2">&quot;centre&quot;</span><span class="p">])</span>
            <span class="n">fmask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mask_freq</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="n">ss</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">fmask</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">ss</span></div>
</div>



<div class="viewcode-block" id="MaskDecorrelatedCylinder">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.MaskDecorrelatedCylinder">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MaskDecorrelatedCylinder</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Identify and mask frequencies and times where a cylinder decorrelated.</span>

<span class="sd">    If the error rate is high on a backplane link in the second stage shuffle</span>
<span class="sd">    of the F-engine corner turn, then on rare occassions (few times per year)</span>
<span class="sd">    the data streams being handled by that FPGA can become misaligned or</span>
<span class="sd">    desynchronized with the rest of the data streams.  The 512 correlator inputs</span>
<span class="sd">    on the cylinder corresponding to that pair of FPGA crates will have negligible</span>
<span class="sd">    correlation with all other inputs for the 64 frequencies received by that</span>
<span class="sd">    FPGA during the second stage shuffle.  This will persist until the data streams</span>
<span class="sd">    are re-synchronized with a correlator restart.</span>

<span class="sd">    This task identifies times and frequencies affected by these misalignment events</span>
<span class="sd">    by examining, for each cylinder, the ratio of 1-cylinder-separation, co-polar</span>
<span class="sd">    visibilities acquired by redundant baselines that do not contain the cylinder</span>
<span class="sd">    to those that do contain the cylinder.  This ratio will be close to 1 under</span>
<span class="sd">    normal operations since the baselines are largely redundant, however it will</span>
<span class="sd">    become very large after a cylinder becomes misaligned since there is no</span>
<span class="sd">    correlation and the denominator drops to near zero.</span>

<span class="sd">    Additionally, if provided the mapping between frequency channel and FPGA,</span>
<span class="sd">    this task will ensure that when there is evidence of a decorrelated cylinder,</span>
<span class="sd">    all 64 frequencies handled by the problematic FPGA are masked.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    threshold: int</span>
<span class="sd">        Mask frequencies and times where the median ratio of the</span>
<span class="sd">        average-without-cylinder to average-with-cylinder visibility</span>
<span class="sd">        amplitude is greater than this threshold.</span>
<span class="sd">    max_frac_freq: float</span>
<span class="sd">        Mask any frequency that was transmitted by an FPGA motherboard slot</span>
<span class="sd">        with more than this fraction of frequencies masked by the above</span>
<span class="sd">        threshold.  Only relevant if the frequency map is provided at setup.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">threshold</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">5.0</span><span class="p">)</span>
    <span class="n">max_frac_freq</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<div class="viewcode-block" id="MaskDecorrelatedCylinder.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.MaskDecorrelatedCylinder.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">inputmap</span><span class="p">,</span> <span class="n">freqmap</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the mask.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : TimeStream</span>
<span class="sd">            Visibilites before averaging over cylinders.</span>
<span class="sd">        inputmap : list of :class:`CorrInput`</span>
<span class="sd">            A list describing the inputs in data.</span>
<span class="sd">        freqmap : :class:`FrequencyMapSingle`</span>
<span class="sd">            The mapping between frequency bin and [shuffle, crate, slot, link]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : RFIMask</span>
<span class="sd">            Mask with True indicating that a cylinder decorrelated</span>
<span class="sd">            at that frequency and time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Distribute over frequencies</span>
        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Get polarisations of feeds</span>
        <span class="n">pol</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">get_feed_polarisations</span><span class="p">(</span><span class="n">inputmap</span><span class="p">)</span>

        <span class="c1"># Get positions of feeds</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">get_feed_positions</span><span class="p">(</span><span class="n">inputmap</span><span class="p">)</span>

        <span class="c1"># Get cylinder each feed is on</span>
        <span class="n">cyl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">inp</span><span class="o">.</span><span class="n">cyl</span> <span class="k">if</span> <span class="n">tools</span><span class="o">.</span><span class="n">is_chime</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">inputmap</span><span class="p">])</span>
        <span class="n">ucyl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cyl</span><span class="p">[</span><span class="n">cyl</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">ncyl</span> <span class="o">=</span> <span class="n">ucyl</span><span class="o">.</span><span class="n">size</span>

        <span class="c1"># Make sure that none of our typical products reference non-array feeds</span>
        <span class="n">stack_new</span><span class="p">,</span> <span class="n">stack_flag</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">redefine_stack_index_map</span><span class="p">(</span>
            <span class="n">inputmap</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">prod</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">stack</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">reverse_map</span><span class="p">[</span><span class="s2">&quot;stack&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">valid_stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">stack_flag</span><span class="p">)</span>
        <span class="n">ninvalid</span> <span class="o">=</span> <span class="n">stack_new</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">valid_stack</span><span class="o">.</span><span class="n">size</span>

        <span class="k">if</span> <span class="n">ninvalid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">stack_new</span> <span class="o">=</span> <span class="n">stack_new</span><span class="p">[</span><span class="n">valid_stack</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Could not find appropriate reference inputs for &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ninvalid</span><span class="si">:</span><span class="s2">0.0f</span><span class="si">}</span><span class="s2"> stacked products.  Ignoring these &quot;</span>
                <span class="s2">&quot;products in decorrelated cylinder calculation.&quot;</span>
            <span class="p">)</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">prod</span><span class="p">[</span><span class="n">stack_new</span><span class="p">[</span><span class="s2">&quot;prod&quot;</span><span class="p">]]</span>

        <span class="n">prodstack</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">conj</span> <span class="o">=</span> <span class="n">stack_new</span><span class="p">[</span><span class="s2">&quot;conjugate&quot;</span><span class="p">]</span>
        <span class="n">prodstack</span><span class="p">[</span><span class="s2">&quot;input_a&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">conj</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="s2">&quot;input_b&quot;</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="s2">&quot;input_a&quot;</span><span class="p">])</span>
        <span class="n">prodstack</span><span class="p">[</span><span class="s2">&quot;input_b&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">conj</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="s2">&quot;input_a&quot;</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="s2">&quot;input_b&quot;</span><span class="p">])</span>

        <span class="c1"># Calculate baseline distance and polarisation pair</span>
        <span class="n">index_a</span> <span class="o">=</span> <span class="n">prodstack</span><span class="p">[</span><span class="s2">&quot;input_a&quot;</span><span class="p">]</span>
        <span class="n">index_b</span> <span class="o">=</span> <span class="n">prodstack</span><span class="p">[</span><span class="s2">&quot;input_b&quot;</span><span class="p">]</span>

        <span class="n">bdist</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">index_a</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos</span><span class="p">[</span><span class="n">index_b</span><span class="p">]</span>
        <span class="n">bpol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">defchararray</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pol</span><span class="p">[</span><span class="n">index_a</span><span class="p">],</span> <span class="n">pol</span><span class="p">[</span><span class="n">index_b</span><span class="p">])</span>

        <span class="c1"># Find the grid indices</span>
        <span class="n">xind</span><span class="p">,</span> <span class="n">yind</span> <span class="o">=</span> <span class="n">find_grid_indices</span><span class="p">(</span><span class="n">bdist</span><span class="p">)[:</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># Only use the co-polar, 1-cylinder separation visibilities for this analysis</span>
        <span class="n">ico</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">((</span><span class="n">pol</span><span class="p">[</span><span class="n">index_a</span><span class="p">]</span> <span class="o">==</span> <span class="n">pol</span><span class="p">[</span><span class="n">index_b</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">xind</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Create an identifier based on the polarisation pair and north-south baseline</span>
        <span class="n">pol_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">pstr</span><span class="p">:</span> <span class="n">pp</span> <span class="k">for</span> <span class="n">pp</span><span class="p">,</span> <span class="n">pstr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">bpol</span><span class="p">[</span><span class="n">ico</span><span class="p">]))}</span>

        <span class="n">idd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ico</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">idd</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">pol_map</span><span class="p">[</span><span class="n">bpol</span><span class="p">[</span><span class="n">ii</span><span class="p">]]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">ico</span><span class="p">]</span>
        <span class="n">idd</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">yind</span><span class="p">[</span><span class="n">ico</span><span class="p">]</span>

        <span class="c1"># Find the unique pol/baselines and the inverse map</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">idd</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">isort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="c1"># Determine boundaries of unique pol/baselines</span>
        <span class="n">bnd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="n">isort</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">index</span><span class="o">.</span><span class="n">size</span><span class="p">])</span>
        <span class="p">)</span>

        <span class="c1"># Ignore any unique pol/baseline that does not have ncyl - 1 redundant copies.</span>
        <span class="c1"># This can happen due to the valid_stack selection.</span>
        <span class="n">ncopies</span> <span class="o">=</span> <span class="n">bnd</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">bnd</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">bflag</span> <span class="o">=</span> <span class="n">ncopies</span> <span class="o">==</span> <span class="p">(</span><span class="n">ncyl</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">nmeas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bflag</span><span class="p">)</span>

        <span class="c1"># Loop over the unique pol/baselines and for each one determine if each of the</span>
        <span class="c1"># cylinders is present in each of the redundant copies</span>
        <span class="n">pindex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nmeas</span><span class="p">,</span> <span class="n">ncyl</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">flag_with</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ncyl</span><span class="p">,</span> <span class="n">nmeas</span><span class="p">,</span> <span class="n">ncyl</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="n">cc</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">bb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmeas</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">bflag</span><span class="p">[</span><span class="n">bb</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="n">pi</span> <span class="o">=</span> <span class="n">ico</span><span class="p">[</span><span class="n">isort</span><span class="p">[</span><span class="n">bnd</span><span class="p">[</span><span class="n">bb</span><span class="p">]</span> <span class="p">:</span> <span class="n">bnd</span><span class="p">[</span><span class="n">bb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]]</span>
            <span class="n">pindex</span><span class="p">[</span><span class="n">cc</span><span class="p">]</span> <span class="o">=</span> <span class="n">valid_stack</span><span class="p">[</span><span class="n">pi</span><span class="p">]</span>

            <span class="n">flag_with</span><span class="p">[:,</span> <span class="n">cc</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">ucyl</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">==</span> <span class="n">cyl</span><span class="p">[</span><span class="n">index_a</span><span class="p">[</span><span class="n">pi</span><span class="p">]][</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
            <span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ucyl</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">==</span> <span class="n">cyl</span><span class="p">[</span><span class="n">index_b</span><span class="p">[</span><span class="n">pi</span><span class="p">]][</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:])</span>

            <span class="n">cc</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">flag_without</span> <span class="o">=</span> <span class="o">~</span><span class="n">flag_with</span>

        <span class="c1"># Extract the required data products</span>
        <span class="n">vis</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:,</span> <span class="n">pindex</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)[:,</span> <span class="n">pindex</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># Define slices that will expand both the coefficients and data</span>
        <span class="c1"># to the correct shape for broadcasting against each other</span>
        <span class="n">cslc</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">dslc</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>

        <span class="c1"># Create an array to fill with the final mask</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">vis</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vis</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="c1"># Loop over frequencies</span>
        <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">vis</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="c1"># For each cylinder, average the magnitude of the visibilities for:</span>
            <span class="c1">#   all redundant baselines that contain that cylinder</span>
            <span class="c1">#   all redundant baselines that do not contain that cylinder</span>
            <span class="n">fwith</span> <span class="o">=</span> <span class="n">flag_with</span><span class="p">[</span><span class="n">cslc</span><span class="p">]</span> <span class="o">*</span> <span class="n">flag</span><span class="p">[</span><span class="n">ff</span><span class="p">][</span><span class="n">dslc</span><span class="p">]</span>
            <span class="n">fwithout</span> <span class="o">=</span> <span class="n">flag_without</span><span class="p">[</span><span class="n">cslc</span><span class="p">]</span> <span class="o">*</span> <span class="n">flag</span><span class="p">[</span><span class="n">ff</span><span class="p">][</span><span class="n">dslc</span><span class="p">]</span>

            <span class="n">norm_with</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fwith</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">norm_without</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fwithout</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

            <span class="n">avg_with</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="n">fwith</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">vis</span><span class="p">[</span><span class="n">ff</span><span class="p">][</span><span class="n">dslc</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span>
            <span class="p">)</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">norm_with</span><span class="p">)</span>
            <span class="n">avg_without</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="n">fwithout</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">vis</span><span class="p">[</span><span class="n">ff</span><span class="p">][</span><span class="n">dslc</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span>
            <span class="p">)</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">norm_without</span><span class="p">)</span>

            <span class="c1"># Take the ratio of without the cylinder to with the cylinder</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="n">avg_without</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">avg_with</span><span class="p">)</span>

            <span class="n">valid</span> <span class="o">=</span> <span class="p">(</span><span class="n">norm_with</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">norm_without</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>

            <span class="c1"># If all entries along axis=1 are invalid then the following</span>
            <span class="c1"># nanmedian will throw a warning if we just fill the invalid</span>
            <span class="c1"># positions with NaN&#39;s. Instead fill samples where all axis=1 is</span>
            <span class="c1"># invalid with zeros which will still fail the following comparison</span>
            <span class="c1"># to generate the mask</span>
            <span class="n">fill</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">0</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
            <span class="c1"># Take the median of the ratio over all unique baselines</span>
            <span class="n">med</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">valid</span><span class="p">,</span> <span class="n">ratio</span><span class="p">,</span> <span class="n">fill</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Mask any time where the median was greater than some threshold</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">ff</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">med</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Gather the mask for all frequencies on all nodes</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">allgather</span><span class="p">()</span>

        <span class="c1"># If more than some (user specified) fraction of frequencies transmitted</span>
        <span class="c1"># by an FPGA motherboard slot have been masked, then mask all frequencies</span>
        <span class="c1"># transmitted by that motherboard slot.  The cylinder decorrelation is</span>
        <span class="c1"># expected to affect all of these frequencies.  This step is only possible</span>
        <span class="c1"># if the frequency map as a function of time has been provided on setup.</span>

        <span class="k">if</span> <span class="n">freqmap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1024</span><span class="p">:</span>
            <span class="n">slot</span> <span class="o">=</span> <span class="n">freqmap</span><span class="o">.</span><span class="n">slot</span><span class="p">[:]</span>
            <span class="n">grouper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">slot</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;mergesort&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">slot</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">frac_freq_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">grouper</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">grouper</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">|</span> <span class="p">(</span><span class="n">frac_freq_masked</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_frac_freq</span><span class="p">)[</span><span class="n">slot</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># Print the fraction of data that has been masked by this task</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="p">(</span><span class="mf">100.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> percent of data was masked due &quot;</span>
            <span class="s2">&quot;to a decorrelated cylinder.&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Create output container and store final mask</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">dcontainers</span><span class="o">.</span><span class="n">RFIMask</span><span class="p">(</span><span class="n">axes_from</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">attrs_from</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>

        <span class="n">out</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">mask</span>

        <span class="k">return</span> <span class="n">out</span></div>
</div>



<div class="viewcode-block" id="ExpandMask">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.ExpandMask">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ExpandMask</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Expand a mask along the time/RA axis.</span>

<span class="sd">    Used to mask the transitional regions between good and bad data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nexpand : int</span>
<span class="sd">        If a time/RA is within nexpand samples from a masked time/RA,</span>
<span class="sd">        then it will be masked in the output.</span>
<span class="sd">    in_place : bool</span>
<span class="sd">        If True, then overwrite the raw mask with the expanded mask.</span>
<span class="sd">        If False, then create a new container with the expanded mask.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nexpand</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">in_place</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="ExpandMask.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.ExpandMask.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw_mask</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mask any times/RAs that neighbor a masked time/RA.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        raw_mask : RFIMask or SiderealRFIMask</span>
<span class="sd">            original mask to expand</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        exp_mask : RFIMask or SiderealRFIMask</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nfreq</span><span class="p">,</span> <span class="n">ntime</span> <span class="o">=</span> <span class="n">raw_mask</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">mraw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">ntime</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nexpand</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">mraw</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nexpand</span> <span class="p">:</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">nexpand</span><span class="p">]</span> <span class="o">=</span> <span class="n">raw_mask</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span>

        <span class="n">window</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nexpand</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">mexp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">rfi</span><span class="o">.</span><span class="n">_rolling_window_lastaxis</span><span class="p">(</span><span class="n">mraw</span><span class="p">,</span> <span class="n">window</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_place</span><span class="p">:</span>
            <span class="n">exp_mask</span> <span class="o">=</span> <span class="n">raw_mask</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">exp_mask</span> <span class="o">=</span> <span class="n">dcontainers</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">raw_mask</span><span class="p">)</span>

        <span class="n">exp_mask</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">mexp</span>

        <span class="k">return</span> <span class="n">exp_mask</span></div>
</div>



<div class="viewcode-block" id="DataFlagger">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.DataFlagger">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DataFlagger</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Flag data based on DataFlags in database.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    flag_type : list</span>
<span class="sd">        List of DataFlagType names to apply. Defaults to the flags representing ranges of time known to be bad</span>
<span class="sd">        that may effect the delay spectrum estimate.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">flag_type</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">list_type</span><span class="p">(</span>
        <span class="n">type_</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="p">[</span>
            <span class="s2">&quot;acjump&quot;</span><span class="p">,</span>
            <span class="s2">&quot;bad_calibration_acquisition_restart&quot;</span><span class="p">,</span>
            <span class="s2">&quot;bad_calibration_fpga_restart&quot;</span><span class="p">,</span>
            <span class="s2">&quot;bad_calibration_gains&quot;</span><span class="p">,</span>
            <span class="s2">&quot;decorrelated_cylinder&quot;</span><span class="p">,</span>
            <span class="s2">&quot;globalflag&quot;</span><span class="p">,</span>
            <span class="s2">&quot;rain1mm&quot;</span><span class="p">,</span>
        <span class="p">],</span>
    <span class="p">)</span>

<div class="viewcode-block" id="DataFlagger.setup">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.DataFlagger.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Query the database for flags of the requested types.&quot;&quot;&quot;</span>
        <span class="n">flags</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Query flag database if on 0th node</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">connect_database</span><span class="p">()</span>
            <span class="n">flag_types</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">DataFlagType</span><span class="o">.</span><span class="n">select</span><span class="p">()</span>
            <span class="n">possible_flags</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ft</span> <span class="ow">in</span> <span class="n">flag_types</span><span class="p">:</span>
                <span class="n">possible_flags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ft</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ft</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">flag_type</span> <span class="ow">or</span> <span class="s2">&quot;all&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">flag_type</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Querying for </span><span class="si">{</span><span class="n">ft</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> Flags&quot;</span><span class="p">)</span>
                    <span class="n">new_flags</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">DataFlag</span><span class="o">.</span><span class="n">select</span><span class="p">()</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">DataFlag</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">ft</span><span class="p">)</span>
                    <span class="n">flags</span><span class="p">[</span><span class="n">ft</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_flags</span><span class="p">)</span>

            <span class="c1"># Check that user-proved flag names are valid</span>
            <span class="k">for</span> <span class="n">flag_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">flag_type</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">flag_name</span> <span class="o">!=</span> <span class="s2">&quot;all&quot;</span> <span class="ow">and</span> <span class="n">flag_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">possible_flags</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: Unrecognized Flag </span><span class="si">{</span><span class="n">flag_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Share flags with other nodes</span>
        <span class="n">flags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Save flags to class attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">flg</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">flg</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">flags</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> Flags in Total.&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span></div>


<div class="viewcode-block" id="DataFlagger.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.DataFlagger.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestream</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set weight to zero for range of data covered by the database flags.</span>

<span class="sd">        Flags are applied based on time, frequency, and (for non-stacked data) input.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestream : andata.CorrData or dcontainers.SiderealStream or dcontainers.TimeStream</span>
<span class="sd">            Timestream to flag.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        timestream : andata.CorrData or dcontainers.SiderealStream or dcontainers.TimeStream</span>
<span class="sd">            Returns the same timestream object with a modified weight dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Redistribute over the frequency direction</span>
        <span class="n">timestream</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Extract the weight dataset and identify its axes</span>
        <span class="n">waxis</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">timestream</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">timestream</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

        <span class="c1"># Determine whether input dependent flags can be applied</span>
        <span class="n">apply_input_flags</span> <span class="o">=</span> <span class="s2">&quot;input&quot;</span> <span class="ow">in</span> <span class="n">waxis</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="p">(</span><span class="s2">&quot;prod&quot;</span> <span class="ow">in</span> <span class="n">waxis</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">timestream</span><span class="o">.</span><span class="n">is_stacked</span>
        <span class="p">)</span>

        <span class="c1"># If not stacked, determine which inputs are in the timestream.</span>
        <span class="c1"># If stacked, assume flags apply to all products.</span>
        <span class="k">if</span> <span class="n">apply_input_flags</span><span class="p">:</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="n">timestream</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">][</span><span class="s2">&quot;chan_id&quot;</span><span class="p">][:]</span>
            <span class="n">prod</span> <span class="o">=</span> <span class="n">timestream</span><span class="o">.</span><span class="n">prodstack</span>

        <span class="c1"># Get time axis or convert RA axis</span>
        <span class="k">if</span> <span class="s2">&quot;ra&quot;</span> <span class="ow">in</span> <span class="n">timestream</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
            <span class="n">ra</span> <span class="o">=</span> <span class="n">timestream</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;ra&quot;</span><span class="p">][:]</span>
            <span class="k">if</span> <span class="s2">&quot;lsd&quot;</span> <span class="ow">in</span> <span class="n">timestream</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
                <span class="n">csd</span> <span class="o">=</span> <span class="n">timestream</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;lsd&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">csd</span> <span class="o">=</span> <span class="n">timestream</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;csd&quot;</span><span class="p">]</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">chime</span><span class="o">.</span><span class="n">lsd_to_unix</span><span class="p">(</span><span class="n">csd</span> <span class="o">+</span> <span class="n">ra</span> <span class="o">/</span> <span class="mf">360.0</span><span class="p">)</span>
            <span class="n">taxis</span> <span class="o">=</span> <span class="s2">&quot;ra&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">timestream</span><span class="o">.</span><span class="n">time</span>
            <span class="n">taxis</span> <span class="o">=</span> <span class="s2">&quot;time&quot;</span>

        <span class="c1"># Determine local frequencies</span>
        <span class="n">local_slice</span> <span class="o">=</span> <span class="n">timestream</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_bounds</span>
        <span class="n">local_freq</span> <span class="o">=</span> <span class="n">timestream</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="n">local_slice</span><span class="p">]</span>

        <span class="c1"># Find the bin number of each local frequency</span>
        <span class="n">basefreq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">800.0</span><span class="p">,</span> <span class="mf">400.0</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">local_bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ff</span> <span class="o">-</span> <span class="n">basefreq</span><span class="p">))</span> <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="n">local_freq</span><span class="p">])</span>

        <span class="c1"># Initiate weight mask (1 means not flagged)</span>
        <span class="n">weight_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">weight</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="c1"># Loop over flags of requested types</span>
        <span class="k">for</span> <span class="n">flag_type</span><span class="p">,</span> <span class="n">flag_list</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">flag</span> <span class="ow">in</span> <span class="n">flag_list</span><span class="p">:</span>
                <span class="c1"># Identify flagged times</span>
                <span class="n">time_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">time</span> <span class="o">&gt;=</span> <span class="n">flag</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">time</span> <span class="o">&lt;=</span> <span class="n">flag</span><span class="o">.</span><span class="n">finish_time</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">time_idx</span><span class="p">):</span>
                    <span class="c1"># Print info to log about why the data is being flagged</span>
                    <span class="n">datestr_start</span> <span class="o">=</span> <span class="n">ctime</span><span class="o">.</span><span class="n">unix_to_datetime</span><span class="p">(</span><span class="n">flag</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span>
                        <span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">T%H%M%SZ&quot;</span>
                    <span class="p">)</span>
                    <span class="n">datestr_end</span> <span class="o">=</span> <span class="n">ctime</span><span class="o">.</span><span class="n">unix_to_datetime</span><span class="p">(</span><span class="n">flag</span><span class="o">.</span><span class="n">finish_time</span><span class="p">)</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span>
                        <span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">T%H%M%SZ&quot;</span>
                    <span class="p">)</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">time_idx</span><span class="p">)</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> (of </span><span class="si">{</span><span class="n">time_idx</span><span class="o">.</span><span class="n">size</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">) samples flagged &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;by a </span><span class="si">{</span><span class="n">flag_type</span><span class="si">}</span><span class="s2"> DataFlag covering &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datestr_start</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">datestr_end</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                    <span class="c1"># Refine the mask based on any frequency or input selection</span>
                    <span class="n">tslc</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">ax</span> <span class="o">==</span> <span class="n">taxis</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">waxis</span><span class="p">]</span>
                    <span class="n">flag_mask</span> <span class="o">=</span> <span class="n">time_idx</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">tslc</span><span class="p">)]</span>
                    <span class="k">if</span> <span class="n">flag</span><span class="o">.</span><span class="n">freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="c1"># `and` with flagged local frequencies</span>
                        <span class="c1"># By default, all frequencies are flagged</span>
                        <span class="n">fslc</span> <span class="o">=</span> <span class="p">[</span><span class="n">local_bin</span> <span class="k">if</span> <span class="n">ax</span> <span class="o">==</span> <span class="s2">&quot;freq&quot;</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">waxis</span><span class="p">]</span>
                        <span class="n">flag_mask</span> <span class="o">=</span> <span class="n">flag_mask</span> <span class="o">&amp;</span> <span class="n">flag</span><span class="o">.</span><span class="n">freq_mask</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">fslc</span><span class="p">)]</span>

                    <span class="k">if</span> <span class="n">flag</span><span class="o">.</span><span class="n">inputs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">apply_input_flags</span><span class="p">:</span>
                        <span class="c1"># `and` with flagged inputs</span>
                        <span class="c1"># By default, all inputs are flagged</span>
                        <span class="n">islc</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="n">inputs</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">,</span> <span class="s2">&quot;prod&quot;</span><span class="p">,</span> <span class="s2">&quot;stack&quot;</span><span class="p">]</span> <span class="k">else</span> <span class="kc">None</span>
                            <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">waxis</span>
                        <span class="p">]</span>
                        <span class="n">flag_mask</span> <span class="o">=</span> <span class="n">flag_mask</span> <span class="o">&amp;</span> <span class="n">flag</span><span class="o">.</span><span class="n">input_mask</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">islc</span><span class="p">)]</span>

                    <span class="c1"># set weight=0 where flag=1</span>
                    <span class="n">weight_mask</span> <span class="o">=</span> <span class="n">weight_mask</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag_mask</span><span class="p">)</span>

        <span class="c1"># Multiply weight mask by existing weight dataset</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">weight_mask</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">apply_input_flags</span> <span class="ow">and</span> <span class="s2">&quot;input&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">waxis</span><span class="p">:</span>
                <span class="c1"># Use apply_gain function to apply mask based on product map</span>
                <span class="n">weight_mask</span> <span class="o">=</span> <span class="n">weight_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">weight</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">tools</span><span class="o">.</span><span class="n">apply_gain</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">weight_mask</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">prod_map</span><span class="o">=</span><span class="n">prod</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">weight</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">weight_mask</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="mf">100.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mf">1.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight_mask</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">weight_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="s2">&quot;percent of data was flagged as bad.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;No DataFlags applied.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">timestream</span></div>
</div>



<div class="viewcode-block" id="ApplyInputFlag">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.ApplyInputFlag">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ApplyInputFlag</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Flag bad inputs.</span>

<span class="sd">    Uses the flaginput acquisition generated by the real-time pipeline.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ApplyInputFlag.setup">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.ApplyInputFlag.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">observer</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load flaginput files that cover full span of time to be processed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        files: list of str</span>
<span class="sd">            List of paths to files containing the input flags.</span>
<span class="sd">        observer : caput.time.Observer, optional</span>
<span class="sd">            Details of the observer, if not set default to CHIME.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observer</span> <span class="o">=</span> <span class="n">chime</span> <span class="k">if</span> <span class="n">observer</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">observer</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">input_flags</span> <span class="o">=</span> <span class="n">andata</span><span class="o">.</span><span class="n">FlagInputData</span><span class="o">.</span><span class="n">from_acq_h5</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">datasets</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;flag&quot;</span><span class="p">])</span></div>


<div class="viewcode-block" id="ApplyInputFlag.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.ApplyInputFlag.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Lookup and apply the relevant input flags.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data: TODContainer, SiderealStream, TrackBeam</span>
<span class="sd">            Must have `input` axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data: TODContainer, SiderealStream, TrackBeam</span>
<span class="sd">            The input container with the weight dataset</span>
<span class="sd">            set to zero for bad inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span>
        <span class="n">daxis</span> <span class="o">=</span> <span class="p">{</span><span class="n">ax</span><span class="p">:</span> <span class="n">ind</span> <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axis</span><span class="p">)}</span>

        <span class="k">if</span> <span class="s2">&quot;input&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">daxis</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;The weight dataset must have an input axis.&quot;</span><span class="p">)</span>

        <span class="n">timestamp</span><span class="p">,</span> <span class="n">time_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_timestamp</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="n">sel</span> <span class="o">=</span> <span class="p">{</span><span class="n">time_axis</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="s2">&quot;input&quot;</span><span class="p">:</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)}</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">distributed</span><span class="p">:</span>
            <span class="n">avail</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axis</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">time_axis</span><span class="p">,</span> <span class="s2">&quot;input&quot;</span><span class="p">]]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">avail</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="n">avail</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;input&quot;</span><span class="p">)</span>
                <span class="n">sinp</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">local_offset</span><span class="p">[</span><span class="n">daxis</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]]</span>
                <span class="n">einp</span> <span class="o">=</span> <span class="n">sinp</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">local_shape</span><span class="p">[</span><span class="n">daxis</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]]</span>

                <span class="n">sel</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">sinp</span><span class="p">,</span> <span class="n">einp</span><span class="p">)</span>

        <span class="n">expand</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">sel</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">])</span>

        <span class="n">transpose</span> <span class="o">=</span> <span class="p">(</span><span class="n">time_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">daxis</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">daxis</span><span class="p">[</span><span class="n">time_axis</span><span class="p">])</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_flags</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s2">&quot;flag&quot;</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">transpose</span><span class="o">=</span><span class="n">transpose</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">time_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">flag</span><span class="p">[</span><span class="n">expand</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_timestamp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine the timestamp based on the container type.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">tod</span><span class="o">.</span><span class="n">TOData</span><span class="p">):</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">time</span>
            <span class="n">time_axis</span> <span class="o">=</span> <span class="s2">&quot;time&quot;</span>

        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">dcontainers</span><span class="o">.</span><span class="n">SiderealStream</span><span class="p">):</span>
            <span class="n">ra</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">ra</span>
            <span class="n">lsd</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;lsd&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;lsd&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span> <span class="k">else</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;csd&quot;</span><span class="p">]</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observer</span><span class="o">.</span><span class="n">lsd_to_unix</span><span class="p">(</span><span class="n">lsd</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">ra</span> <span class="o">/</span> <span class="mf">360.0</span><span class="p">)</span>
            <span class="n">time_axis</span> <span class="o">=</span> <span class="s2">&quot;ra&quot;</span>

        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">dcontainers</span><span class="o">.</span><span class="n">TrackBeam</span><span class="p">):</span>
            <span class="n">ra</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">pix</span><span class="p">[</span><span class="s2">&quot;phi&quot;</span><span class="p">][:]</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;cirs_ra&quot;</span><span class="p">]</span>
            <span class="n">lsdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observer</span><span class="o">.</span><span class="n">unix_to_lsd</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;transit_time&quot;</span><span class="p">])</span> <span class="o">+</span> <span class="n">ra</span> <span class="o">/</span> <span class="mf">360.0</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">observer</span><span class="o">.</span><span class="n">lsd_to_unix</span><span class="p">(</span><span class="n">lsdf</span><span class="p">)</span>
            <span class="n">time_axis</span> <span class="o">=</span> <span class="s2">&quot;pix&quot;</span>

        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">dcontainers</span><span class="o">.</span><span class="n">StaticGainData</span><span class="p">):</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span>
            <span class="n">time_axis</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Do not know how to calculate timestamp&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; for container type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">time_axis</span></div>



<div class="viewcode-block" id="SetInputFlag">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.SetInputFlag">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SetInputFlag</span><span class="p">(</span><span class="n">ApplyInputFlag</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set input flags dataset based on values from the real-time pipeline at the time.</span>

<span class="sd">    This is useful for holographic observations or SiderealStreams, neither of which</span>
<span class="sd">    have their input_flags dataset populated.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SetInputFlag.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.SetInputFlag.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Lookup and save the input flags based on the time.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data: TODContainer, SiderealStream, TrackBeam</span>
<span class="sd">            Must have `input_flags` dataset.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data: TODContainer, SiderealStream, TrackBeam</span>
<span class="sd">            The input container with the input_flags dataset</span>
<span class="sd">            set to 1.0 for good inputs and 0.0 for bad inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">daxis</span> <span class="o">=</span> <span class="p">{</span><span class="n">ax</span><span class="p">:</span> <span class="n">ind</span> <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">input_flags</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])}</span>

        <span class="n">timestamp</span><span class="p">,</span> <span class="n">time_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_timestamp</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="n">flag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_flags</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span>
            <span class="s2">&quot;flag&quot;</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">transpose</span><span class="o">=</span><span class="n">daxis</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">daxis</span><span class="p">[</span><span class="n">time_axis</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">data</span><span class="o">.</span><span class="n">input_flags</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">flag</span>

        <span class="k">return</span> <span class="n">data</span></div>
</div>



<div class="viewcode-block" id="load_rainfall">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.load_rainfall">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">load_rainfall</span><span class="p">(</span><span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">node_spoof</span><span class="o">=</span><span class="n">_DEFAULT_NODE_SPOOF</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Load rainfall measurements in a specific time range.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    start_time, end_time : float</span>
<span class="sd">        Unix times denoting beginning and end of time range.</span>
<span class="sd">    node_spoof : dictionary</span>
<span class="sd">        Host and directory for finding weather data.</span>
<span class="sd">        Default: {&#39;fir_online&#39;: &#39;/project/rpp-chime/chime/chime_online/&#39;}</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    times, rainfall : np.ndarray</span>
<span class="sd">        Arrays of Unix timestamps and rainfall measurements (in mm).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Use Finder to fetch weather data files overlapping with specified time interval</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="n">Finder</span><span class="p">(</span><span class="n">node_spoof</span><span class="o">=</span><span class="n">node_spoof</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">only_chime_weather</span><span class="p">()</span>
    <span class="n">f</span><span class="o">.</span><span class="n">set_time_range</span><span class="p">(</span><span class="n">start_time</span><span class="o">=</span><span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="o">=</span><span class="n">end_time</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">accept_all_global_flags</span><span class="p">()</span>
    <span class="n">results_list</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">get_results</span><span class="p">()</span>

    <span class="c1"># For each weather file, fetch rainfall measurements and associated timestamps</span>
    <span class="n">times</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">rainfall</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results_list</span><span class="p">:</span>
        <span class="n">result_data</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">as_loaded_data</span><span class="p">()</span>
        <span class="n">times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result_data</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;station_time_blockhouse&quot;</span><span class="p">])</span>
        <span class="n">rainfall</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result_data</span><span class="p">[</span><span class="s2">&quot;blockhouse&quot;</span><span class="p">][</span><span class="s2">&quot;rain&quot;</span><span class="p">])</span>

    <span class="c1"># Concatenate timestamp and rainfall arrays, and also sort chronologically</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
    <span class="n">rainfall</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">rainfall</span><span class="p">)</span>
    <span class="n">idx_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">idx_sort</span><span class="p">]</span>
    <span class="n">rainfall</span> <span class="o">=</span> <span class="n">rainfall</span><span class="p">[</span><span class="n">idx_sort</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">rainfall</span></div>



<div class="viewcode-block" id="compute_cumulative_rainfall">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.compute_cumulative_rainfall">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_cumulative_rainfall</span><span class="p">(</span>
    <span class="n">times</span><span class="p">,</span> <span class="n">accumulation_time</span><span class="o">=</span><span class="mf">30.0</span><span class="p">,</span> <span class="n">node_spoof</span><span class="o">=</span><span class="n">_DEFAULT_NODE_SPOOF</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute cumulative rainfall for a given set of Unix times.</span>

<span class="sd">    The cumulative rainfall total is computed over the previous</span>
<span class="sd">    accumulation_time seconds.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    times : np.ndarray</span>
<span class="sd">        Unix times to compute cumulative rainfall for. Assumed to be sorted</span>
<span class="sd">        chronologically.</span>
<span class="sd">    accumulation_time: float</span>
<span class="sd">        Number of hours over which to compute accumulated rainfall for each time sample.</span>
<span class="sd">        Default: 30.</span>
<span class="sd">    node_spoof : dictionary</span>
<span class="sd">        Host and directory for finding weather data.</span>
<span class="sd">        Default: {&#39;fir_online&#39;: &#39;/project/rpp-chime/chime/chime_online/&#39;}.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rainfall : np.ndarray</span>
<span class="sd">        Cumulative rainfall totals, in mm.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Extra buffer (in s) for reading rainfall measurements, to ensure that range of</span>
    <span class="c1"># input times is always fully within range of rainfall timestamps</span>
    <span class="n">_TIME_BUFFER</span> <span class="o">=</span> <span class="mi">600</span>

    <span class="c1"># Compute accumulation time in seconds</span>
    <span class="n">accumulation_time_s</span> <span class="o">=</span> <span class="n">accumulation_time</span> <span class="o">*</span> <span class="mi">3600</span>

    <span class="c1"># Load rainfall measurements within relevant time range</span>
    <span class="n">rain_timestamps</span><span class="p">,</span> <span class="n">rain_meas</span> <span class="o">=</span> <span class="n">load_rainfall</span><span class="p">(</span>
        <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">accumulation_time_s</span> <span class="o">-</span> <span class="n">_TIME_BUFFER</span><span class="p">,</span>
        <span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">_TIME_BUFFER</span><span class="p">,</span>
        <span class="n">node_spoof</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Compute number of rainfall timestamps to accumulate</span>
    <span class="n">dtimestamp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">rain_timestamps</span><span class="p">))</span>
    <span class="n">n_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">accumulation_time_s</span> <span class="o">/</span> <span class="n">dtimestamp</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Compute cumulative rainfall totals at each timestamp and (n_sum - 1) previous</span>
    <span class="c1"># timestamps:</span>
    <span class="c1"># - First, for each timestamp, compute sum of rainfall at that timestamp and all</span>
    <span class="c1">#   previous timestamps</span>
    <span class="n">all_cumu_rainfall</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">rain_meas</span><span class="p">)</span>
    <span class="c1"># - Make new array to store final results</span>
    <span class="n">cumu_rainfall</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">rain_meas</span><span class="p">)</span>
    <span class="c1"># - First n_sum sums will just be equal to cumsum result</span>
    <span class="n">cumu_rainfall</span><span class="p">[:</span><span class="n">n_sum</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_cumu_rainfall</span><span class="p">[:</span><span class="n">n_sum</span><span class="p">]</span>
    <span class="c1"># - Other sums will be difference of cumsum results separated by n_sum entries</span>
    <span class="n">cumu_rainfall</span><span class="p">[</span><span class="n">n_sum</span><span class="p">:]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">all_cumu_rainfall</span><span class="p">[</span><span class="n">n_sum</span><span class="p">:]</span> <span class="o">-</span> <span class="n">all_cumu_rainfall</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">rain_meas</span><span class="p">)</span> <span class="o">-</span> <span class="n">n_sum</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># For each input time, assign cumulative rainfall from first timestamp</span>
    <span class="c1"># that occurs after this time. This errs on the side of potentially</span>
    <span class="c1"># overestimating the cumulative rainfall at a given input time.</span>
    <span class="n">time_timestamp_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">rain_timestamps</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
    <span class="c1"># If the rightmost value(s) of `times` are greater than `rain_timestamps`,</span>
    <span class="c1"># `searchsorted` returns the last index + 1, which is out of bounds.</span>
    <span class="c1"># If this is the case, assume that the last available rainfall value</span>
    <span class="c1"># extends to times with no data</span>
    <span class="n">time_timestamp_idx</span><span class="p">[</span><span class="n">time_timestamp_idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rain_timestamps</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">rain_timestamps</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">cumu_rainfall</span><span class="p">[</span><span class="n">time_timestamp_idx</span><span class="p">]</span></div>



<div class="viewcode-block" id="FlagRainfall">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.FlagRainfall">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FlagRainfall</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Flag times following periods of heavy rainfall.</span>

<span class="sd">    This task uses rainfall measurements from the DRAO weather station to compute</span>
<span class="sd">    the accumulated rainfall within a given time interval prior to each time sample.</span>
<span class="sd">    If the rainfall total exceeds some threshold, the weight dataset is set to zero</span>
<span class="sd">    for that time.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    accumulation_time : float</span>
<span class="sd">        Number of hours over which to compute accumulated rainfall for each time sample.</span>
<span class="sd">        Default: 30.</span>
<span class="sd">    threshold : float</span>
<span class="sd">        Rainfall threshold (in mm) for flagging. Default: 1.0.</span>
<span class="sd">    node_spoof : dictionary</span>
<span class="sd">        Host and directory for finding weather data.</span>
<span class="sd">        Default: {&#39;fir_online&#39;: &#39;/project/rpp-chime/chime/chime_online/&#39;}.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">accumulation_time</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">30.0</span><span class="p">)</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">node_spoof</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">dict</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">_DEFAULT_NODE_SPOOF</span><span class="p">)</span>

<div class="viewcode-block" id="FlagRainfall.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.FlagRainfall.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set weight to zero if cumulative rainfall exceeds desired threshold.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stream : andata.CorrData, dcontainers.SiderealStream, dcontainers.TimeStream,</span>
<span class="sd">                 dcontainers.HybridVisStream, dcontainers.RingMap</span>
<span class="sd">            Stream to flag.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        stream : andata.CorrData, dcontainers.SiderealStream, dcontainers.TimeStream,</span>
<span class="sd">                 dcontainers.HybridVisStream, dcontainers.RingMap</span>
<span class="sd">            Returns the same stream object with a modified weight dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Redistribute over the frequency direction</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Get time axis or convert RA axis to Unix time</span>
        <span class="k">if</span> <span class="s2">&quot;ra&quot;</span> <span class="ow">in</span> <span class="n">stream</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
            <span class="n">ra</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;ra&quot;</span><span class="p">][:]</span>
            <span class="k">if</span> <span class="s2">&quot;lsd&quot;</span> <span class="ow">in</span> <span class="n">stream</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
                <span class="n">csd</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;lsd&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">csd</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;csd&quot;</span><span class="p">]</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">chime</span><span class="o">.</span><span class="n">lsd_to_unix</span><span class="p">(</span><span class="n">csd</span> <span class="o">+</span> <span class="n">ra</span> <span class="o">/</span> <span class="mf">360.0</span><span class="p">)</span>
            <span class="n">taxis</span> <span class="o">=</span> <span class="s2">&quot;ra&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">time</span>
            <span class="n">taxis</span> <span class="o">=</span> <span class="s2">&quot;time&quot;</span>

        <span class="c1"># Compute cumulative rainfall within specified time interval.</span>
        <span class="c1"># Only run on rank 0, because a database query is required</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">rainfall</span> <span class="o">=</span> <span class="n">compute_cumulative_rainfall</span><span class="p">(</span>
                <span class="n">time</span><span class="p">,</span>
                <span class="n">accumulation_time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">accumulation_time</span><span class="p">,</span>
                <span class="n">node_spoof</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">node_spoof</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rainfall</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

        <span class="c1"># Broadcast cumulative rainfall to all ranks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="n">rainfall</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Compute mask corresponding to times when rainfall is below threshold</span>
        <span class="n">rainfall_mask</span> <span class="o">=</span> <span class="n">rainfall</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span>

        <span class="c1"># Multiply weights by mask.</span>
        <span class="n">waxis</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span>
        <span class="n">tslc</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">ax</span> <span class="o">==</span> <span class="n">taxis</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">waxis</span><span class="p">]</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">rainfall_mask</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">tslc</span><span class="p">)]</span>

        <span class="c1"># Report how much data has been flagged due to rainfall</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="mf">100.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mf">1.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rainfall_mask</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">rainfall_mask</span><span class="p">))</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="s2">&quot;percent of data was flagged due to rainfall.&quot;</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">stream</span></div>
</div>



<div class="viewcode-block" id="MaskManyBadInputs">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.MaskManyBadInputs">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MaskManyBadInputs</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Flag spans of time where a large number of inputs were flagged as bad.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    threshold : int</span>
<span class="sd">        Flag data if the number of bad inputs exceeds this value.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">threshold</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">150</span><span class="p">)</span>

<div class="viewcode-block" id="MaskManyBadInputs.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.MaskManyBadInputs.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set weight to zero if number of bad inputs exceeds desired threshold.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stream : andata.CorrData, dcontainers.SiderealStream, dcontainers.TimeStream,</span>
<span class="sd">                 dcontainers.HybridVisStream, dcontainers.RingMap</span>
<span class="sd">            Stream to flag.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        stream : andata.CorrData, dcontainers.SiderealStream, dcontainers.TimeStream,</span>
<span class="sd">                 dcontainers.HybridVisStream, dcontainers.RingMap</span>
<span class="sd">            Returns the same stream object with a modified weight dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Redistribute over the frequency direction</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Extract the input flags</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">input_flags</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">input_flags</span><span class="p">[:]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Input stream does not contain input_flags dataset. &quot;</span>
                <span class="s2">&quot;No data will be flagged.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">stream</span>

        <span class="c1"># Compute number of bad inputs</span>
        <span class="n">nbad</span> <span class="o">=</span> <span class="n">input_flags</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">input_flags</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">flag</span> <span class="o">=</span> <span class="n">nbad</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span>

        <span class="c1"># Multiply weights by flag.</span>
        <span class="n">waxis</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span>
        <span class="n">tslc</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ra&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">waxis</span><span class="p">]</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">flag</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">tslc</span><span class="p">)]</span>

        <span class="c1"># Report how much data has been flagged due to rainfall</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="mf">100.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mf">1.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">flag</span><span class="o">.</span><span class="n">size</span><span class="p">)</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="s2">&quot;percent of data was flagged due to large number of bad inputs.&quot;</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">stream</span></div>
</div>



<div class="viewcode-block" id="MaskHighFracLost">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.MaskHighFracLost">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MaskHighFracLost</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mask frequencies and times with significant data loss during integration.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    threshold : int</span>
<span class="sd">        Flag frequencies and times if the fraction of data lost</span>
<span class="sd">        due to RFI or packet loss exceeds this threshold.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">threshold</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.02</span><span class="p">)</span>

<div class="viewcode-block" id="MaskHighFracLost.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.MaskHighFracLost.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create mask indicating when frac_lost exceeds desired threshold.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stream : andata.CorrData</span>
<span class="sd">            Stream to flag.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mask_cont : dcontainers.RFIMask or dcontainers.SiderealRFIMask</span>
<span class="sd">            Boolean mask where True indicates frac_lost is greater than</span>
<span class="sd">            the threshold.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Redistribute over the frequency direction</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Extract the frac_lost dataset</span>
        <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;flags&quot;</span> <span class="ow">in</span> <span class="n">stream</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;frac_lost&quot;</span> <span class="ow">in</span> <span class="n">stream</span><span class="p">[</span><span class="s2">&quot;flags&quot;</span><span class="p">]):</span>
            <span class="n">frac_lost</span> <span class="o">=</span> <span class="n">stream</span><span class="p">[</span><span class="s2">&quot;flags&quot;</span><span class="p">][</span><span class="s2">&quot;frac_lost&quot;</span><span class="p">][:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Input stream does not contain flags/frac_lost dataset. &quot;</span>
                <span class="s2">&quot;No data will be flagged.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">stream</span>

        <span class="c1"># Create output container</span>
        <span class="k">if</span> <span class="s2">&quot;ra&quot;</span> <span class="ow">in</span> <span class="n">stream</span><span class="o">.</span><span class="n">axes</span><span class="p">:</span>
            <span class="n">mask_cont</span> <span class="o">=</span> <span class="n">dcontainers</span><span class="o">.</span><span class="n">SiderealRFIMask</span><span class="p">(</span><span class="n">axes_from</span><span class="o">=</span><span class="n">stream</span><span class="p">,</span> <span class="n">attrs_from</span><span class="o">=</span><span class="n">stream</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">stream</span><span class="o">.</span><span class="n">axes</span><span class="p">:</span>
            <span class="n">mask_cont</span> <span class="o">=</span> <span class="n">dcontainers</span><span class="o">.</span><span class="n">RFIMask</span><span class="p">(</span><span class="n">axes_from</span><span class="o">=</span><span class="n">stream</span><span class="p">,</span> <span class="n">attrs_from</span><span class="o">=</span><span class="n">stream</span><span class="p">)</span>

        <span class="c1"># Identify times and frequencies with significant frac_lost</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">frac_lost</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span>

        <span class="c1"># Collect all parts of the mask. Method .allgather() returns a np.ndarray</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">allgather</span><span class="p">()</span>

        <span class="c1"># Log the percent of data masked</span>
        <span class="n">drop_frac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">%0.5f%%</span><span class="s2"> of data exceeds frac_lost threshold.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="mf">100.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">drop_frac</span><span class="p">))</span>
        <span class="p">)</span>

        <span class="c1"># Save to output container</span>
        <span class="n">mask_cont</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">mask</span>

        <span class="k">return</span> <span class="n">mask_cont</span></div>
</div>



<div class="viewcode-block" id="search_grid">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.search_grid">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">search_grid</span><span class="p">(</span><span class="n">xeval</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find indices into a uniformly space grid that extract desired regions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xeval : np.ndarray</span>
<span class="sd">        Coordinate of the centre of each region.</span>
<span class="sd">    window : np.ndarray</span>
<span class="sd">        Half-width of each region.  Must broadcast against xeval.</span>
<span class="sd">    x : np.ndarray[nsample,]</span>
<span class="sd">        Coordinate grid.  Must be uniformly spaced and monotonically increasing.</span>
<span class="sd">    wrap : bool</span>
<span class="sd">        Wrap around if a region exceeds the first or last point in the grid.</span>
<span class="sd">        Otherwise the region will be restricted in size to remain in the grid.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xlb : np.ndarray</span>
<span class="sd">        The index into the grid the defines the lower bound of each region.</span>
<span class="sd">    xub : np.ndarray</span>
<span class="sd">        The index into the grid the defines the upper bound of each region.</span>
<span class="sd">        Each region can be selected with slice(xlb, xub).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">min_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
    <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span>

    <span class="n">xlb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">xeval</span> <span class="o">-</span> <span class="n">window</span> <span class="o">-</span> <span class="n">min_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dx</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">xub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">xeval</span> <span class="o">+</span> <span class="n">window</span> <span class="o">-</span> <span class="n">min_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dx</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">wrap</span><span class="p">:</span>
        <span class="n">xlb</span> <span class="o">=</span> <span class="p">(</span><span class="n">nx</span> <span class="o">+</span> <span class="n">xlb</span><span class="p">)</span> <span class="o">%</span> <span class="n">nx</span>
        <span class="n">xub</span> <span class="o">=</span> <span class="n">xub</span> <span class="o">%</span> <span class="n">nx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">xlb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">xlb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nx</span><span class="p">)</span>
        <span class="n">xub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">xub</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nx</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">xlb</span><span class="p">,</span> <span class="n">xub</span></div>



<div class="viewcode-block" id="CatalogBase">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.CatalogBase">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CatalogBase</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Shared methods for catalog-based masking and tapering.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="CatalogBase.setup">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.CatalogBase.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">manager</span><span class="p">,</span> <span class="n">catalog</span><span class="p">,</span> <span class="n">horizon</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save the telescope instance and the catalog of bright sources.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        manager : io.TelescopeConvertible</span>
<span class="sd">            Telescope/manager used to determine the location of bright sources.</span>
<span class="sd">        catalog : subclass of SourceCatalog</span>
<span class="sd">            Catalog containing bright sources to mask.</span>
<span class="sd">        horizon : HorizonLimit</span>
<span class="sd">            Altitude of the horizon as a function of azimuth.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Save the telescope and horizon</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">telescope</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">get_telescope</span><span class="p">(</span><span class="n">manager</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">latitude</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">horizon</span> <span class="o">=</span> <span class="n">horizon</span>

        <span class="c1"># Save the minimum north-south separation</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">yind</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">min_ysep</span> <span class="o">=</span> <span class="n">find_grid_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">baselines</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_ysep</span> <span class="o">=</span> <span class="n">min_ysep</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_ysep</span> <span class="o">=</span> <span class="n">min_ysep</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">yind</span><span class="p">))</span>

        <span class="c1"># Save the catalog</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span> <span class="o">=</span> <span class="n">catalog</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_redshift</span> <span class="o">=</span> <span class="s2">&quot;frequency&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span> <span class="ow">or</span> <span class="s2">&quot;redshift&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span></div>


<div class="viewcode-block" id="CatalogBase.get_source_freq">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.CatalogBase.get_source_freq">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_source_freq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the frequency corresponding to each source&#39;s redshift.</span>

<span class="sd">        Returns `self.catalog[&quot;frequency&quot;]` if available.  Otherwise the</span>
<span class="sd">        redshift of the source will be converted to frequency assuming</span>
<span class="sd">        the 21 cm line. Redshift values and their uncertainties taken</span>
<span class="sd">        from `self.catalog[&quot;redshift&quot;]`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        src_freq : np.ndarray[nsource,]</span>
<span class="sd">            Rest-frame frequency in MHz of 21 cm emission or absorption</span>
<span class="sd">            for each source, computed as freq_21 / (1 + z), where freq_21 is</span>
<span class="sd">            the rest-frame frequency of the 21 cm line.</span>
<span class="sd">        src_freq_err : np.ndarray[nsource,]</span>
<span class="sd">            Uncertainty in source frequency in MHz, propagated from redshift errors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">cora.util</span><span class="w"> </span><span class="kn">import</span> <span class="n">units</span>

        <span class="k">if</span> <span class="s2">&quot;frequency&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">:</span>
            <span class="n">src_freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;frequency&quot;</span><span class="p">][</span><span class="s2">&quot;freq&quot;</span><span class="p">][:]</span>
            <span class="n">src_freq_err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;frequency&quot;</span><span class="p">][</span><span class="s2">&quot;freq_error&quot;</span><span class="p">][:]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;redshift&quot;</span><span class="p">][</span><span class="s2">&quot;z&quot;</span><span class="p">][:]</span>
            <span class="n">zerr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;redshift&quot;</span><span class="p">][</span><span class="s2">&quot;z_error&quot;</span><span class="p">][:]</span>

            <span class="n">src_freq</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">nu21</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span>
            <span class="n">src_freq_err</span> <span class="o">=</span> <span class="n">src_freq</span> <span class="o">*</span> <span class="n">zerr</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">src_freq</span><span class="p">,</span> <span class="n">src_freq_err</span></div>


<div class="viewcode-block" id="CatalogBase.get_z_limit">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.CatalogBase.get_z_limit">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_z_limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the z coordinate of the horizon.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : np.ndarray[ncoord,]</span>
<span class="sd">            Telescope-x coordinate of sources.</span>
<span class="sd">        y : np.ndarray[ncoord,]</span>
<span class="sd">            Telescope-y coordinate of sources.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        zlim : np.ndarray[ncoord,]</span>
<span class="sd">            Telescope-z coordinate cooresponding to the horizon</span>
<span class="sd">            at the azimuthal angle given by x and y.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">horizon</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">az</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
            <span class="n">min_alt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">horizon</span><span class="o">.</span><span class="n">get_horizon_limit</span><span class="p">(</span><span class="n">az</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">min_alt</span><span class="p">))</span>

        <span class="k">return</span> <span class="mf">0.0</span></div>
</div>



<div class="viewcode-block" id="SourcePixelsMixin">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.SourcePixelsMixin">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SourcePixelsMixin</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mixin providing coordinates of the transit of sources in a map.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="SourcePixelsMixin.get_source_coordinates">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.SourcePixelsMixin.get_source_coordinates">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_source_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine the coordinates of bright sources in a beamformed dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : RingMap or HybridVisStream</span>
<span class="sd">            Beamformed dataset to be flagged. Must have a &quot;ra&quot; axis and</span>
<span class="sd">            an &quot;el&quot; axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ind : np.ndarray[nsource,]</span>
<span class="sd">            Index of the source in the catalog.</span>
<span class="sd">        src_ra : np.ndarray[nsource,]</span>
<span class="sd">            Right ascension of the sources in the catalog.</span>
<span class="sd">        src_dec : np.ndarray[nsource,]</span>
<span class="sd">            Declination of the sources in the catalog.</span>
<span class="sd">        src_y : np.ndarray[nsource,]</span>
<span class="sd">            Telescope-y coordinate of the sources in the catalog</span>
<span class="sd">            at transit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">draco.analysis.beamform</span><span class="w"> </span><span class="kn">import</span> <span class="n">icrs_to_cirs</span>

        <span class="c1"># Determine the coordinates of the sources in the current epoch</span>
        <span class="k">if</span> <span class="s2">&quot;lsd&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
            <span class="n">lsd</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;lsd&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="s2">&quot;csd&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
            <span class="n">lsd</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;csd&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lsd</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">src_ra</span><span class="p">,</span> <span class="n">src_dec</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][</span><span class="s2">&quot;ra&quot;</span><span class="p">][:],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">catalog</span><span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">][</span><span class="s2">&quot;dec&quot;</span><span class="p">][:],</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">lsd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">epoch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">lsd_to_unix</span><span class="p">(</span><span class="n">lsd</span><span class="p">))</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">icrs_to_cirs</span><span class="p">(</span><span class="n">src_ra</span><span class="p">,</span> <span class="n">src_dec</span><span class="p">,</span> <span class="n">ep</span><span class="p">)</span> <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="n">epoch</span><span class="p">]</span>
            <span class="n">src_ra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">src_dec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">src_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">src_ra</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># Calculate source telescope y coordinate,</span>
        <span class="c1"># given by sin(za) at transit.</span>
        <span class="n">src_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">src_dec</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">src_ind</span><span class="p">,</span> <span class="n">src_ra</span><span class="p">,</span> <span class="n">src_dec</span><span class="p">,</span> <span class="n">src_y</span></div>
</div>



<div class="viewcode-block" id="SourceTracksMixin">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.SourceTracksMixin">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SourceTracksMixin</span><span class="p">(</span><span class="n">SourcePixelsMixin</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mixin providing coordinates of the tracks sources take through a map.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    max_ha : float</span>
<span class="sd">        Do not consider sources beyond this hour angle in degrees.</span>
<span class="sd">    upsample : int</span>
<span class="sd">        Upsample the tracks this factor relative to the native resolution</span>
<span class="sd">        of the maps in RA.  This will result in a smoother mask or taper.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">max_ha</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">upsample</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

<div class="viewcode-block" id="SourceTracksMixin.get_source_coordinates">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.SourceTracksMixin.get_source_coordinates">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_source_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine the coordinates of bright source tracks in a beamformed dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : RingMap or HybridVisStream</span>
<span class="sd">            Beamformed dataset to be flagged. Must have a &quot;ra&quot; axis and</span>
<span class="sd">            an &quot;el&quot; axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ind : np.ndarray[ncoord,]</span>
<span class="sd">            Index of the source in the catalog for each coordinate</span>
<span class="sd">            in the flattened array.</span>
<span class="sd">        ra : np.ndarray[ncoord,]</span>
<span class="sd">            Right ascension of the U-shaped tracks of sources</span>
<span class="sd">            in the catalog.  Flattened into a 1-d array.</span>
<span class="sd">        dec : np.ndarray[ncoord,]</span>
<span class="sd">            Declination of the sources in the catalog.  This is</span>
<span class="sd">            replicated nra times for each source and flattened</span>
<span class="sd">            into a 1-d array.</span>
<span class="sd">        y : np.ndarray[ncoord,]</span>
<span class="sd">            Telescope-y coordinate of the U-shaped tracks of</span>
<span class="sd">            sources in the catalog.  Flattened into a 1-d array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">src_ind</span><span class="p">,</span> <span class="n">src_ra</span><span class="p">,</span> <span class="n">src_dec</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_source_coordinates</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="n">ra</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">ra</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">upsample</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">upsample</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                <span class="n">ra</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">ra</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">ra</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ra</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                <span class="n">num</span><span class="o">=</span><span class="n">ra</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">upsample</span><span class="p">,</span>
                <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">ha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">ra</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">src_ra</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
        <span class="n">ha</span> <span class="o">=</span> <span class="p">((</span><span class="n">ha</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>  <span class="c1"># correct phase wrap</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">interferometry</span><span class="o">.</span><span class="n">sph_to_ground</span><span class="p">(</span>
            <span class="n">ha</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">latitude</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">src_dec</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
        <span class="p">)</span>

        <span class="n">zlim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_z_limit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="n">z</span> <span class="o">&gt;</span> <span class="n">zlim</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_ha</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flag</span> <span class="o">&amp;=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ha</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_ha</span><span class="p">)</span>

        <span class="n">valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">src_ind</span><span class="p">[</span><span class="n">valid</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">ra</span><span class="p">[</span><span class="n">valid</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">src_dec</span><span class="p">[</span><span class="n">valid</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">y</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span></div>
</div>



<div class="viewcode-block" id="MaskFromCatalogBase">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.MaskFromCatalogBase">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MaskFromCatalogBase</span><span class="p">(</span><span class="n">CatalogBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mask regions of a map near bright point sources.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    mask_alias : bool</span>
<span class="sd">        Mask the frequency-dependent, north-south alias location</span>
<span class="sd">        in addition to the true location.</span>
<span class="sd">    common_freq : bool</span>
<span class="sd">        Ensure the (non-aliased) mask is frequency independent by</span>
<span class="sd">        constructing the windows using the minimum frequency.</span>
<span class="sd">    nsigma_ra : float</span>
<span class="sd">        Width of the window to mask in the RA direction specified in</span>
<span class="sd">        number of sigma of the primary beam.</span>
<span class="sd">    nsigma_dec : float</span>
<span class="sd">        Width of the window to mask in the dec direction specified</span>
<span class="sd">        in number of sigma of the synthesized beam.</span>
<span class="sd">    nsigma_freq : float</span>
<span class="sd">        Width of the window to mask in the freq direction specified</span>
<span class="sd">        in the number of sigma given by the catalog redshift error.</span>
<span class="sd">        Only relevant if the catalog provided during setup is a</span>
<span class="sd">        SpectroscopicCatalog.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mask_alias</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">common_freq</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">nsigma_ra</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">3.0</span><span class="p">)</span>
    <span class="n">nsigma_dec</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">3.0</span><span class="p">)</span>
    <span class="n">nsigma_freq</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">3.0</span><span class="p">)</span>

<div class="viewcode-block" id="MaskFromCatalogBase.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.MaskFromCatalogBase.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate a mask that excludes pixels near transit of bright point sources.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : RingMap or HybridVisStream</span>
<span class="sd">            Beamformed dataset to be flagged. Must have a &quot;ra&quot; axis and</span>
<span class="sd">            an &quot;el&quot; axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : RingMapMask</span>
<span class="sd">            Boolean mask with True indicating that a pixel is near</span>
<span class="sd">            a bright source.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Distribute over frequencies</span>
        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="n">min_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_bounds</span><span class="p">]</span>
        <span class="n">nfreq</span> <span class="o">=</span> <span class="n">freq</span><span class="o">.</span><span class="n">size</span>

        <span class="c1"># Create output container</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">dcontainers</span><span class="o">.</span><span class="n">RingMapMask</span><span class="p">(</span>
            <span class="n">axes_from</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">attrs_from</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">distributed</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">distributed</span><span class="p">,</span>
            <span class="n">comm</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="n">out</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

        <span class="c1"># Determine the coordinates of the sources in the current epoch</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">src_ra</span><span class="p">,</span> <span class="n">src_dec</span><span class="p">,</span> <span class="n">src_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_source_coordinates</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="n">nsource</span> <span class="o">=</span> <span class="n">src_ra</span><span class="o">.</span><span class="n">size</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_redshift</span><span class="p">:</span>
            <span class="n">src_freq</span><span class="p">,</span> <span class="n">src_freq_err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_source_freq</span><span class="p">()</span>

        <span class="c1"># Get aliased coordinates as well</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_alias</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span> <span class="o">/</span> <span class="p">(</span><span class="n">freq</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1e6</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_ysep</span><span class="p">)</span>
            <span class="n">src_yalias</span> <span class="o">=</span> <span class="n">src_y</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">src_y</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">))</span> <span class="o">*</span> <span class="n">b</span>  <span class="c1"># nfreq, nsource</span>

        <span class="c1"># Get the size of the window</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">nfreq</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">min_freq</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">common_freq</span> <span class="k">else</span> <span class="n">freq</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">wavelength</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span> <span class="o">/</span> <span class="p">(</span><span class="n">nu</span> <span class="o">*</span> <span class="mf">1e6</span><span class="p">)</span>

        <span class="c1"># In the sin(za) direction, we use the synthesized beam.</span>
        <span class="c1"># 0.85 * wavelength / max_ysep gives the FWHM for a natural weighting scheme,</span>
        <span class="c1"># and the factor of 2.35482 converts from FWHM to sigma.</span>
        <span class="n">sigma_y</span> <span class="o">=</span> <span class="mf">0.85</span> <span class="o">*</span> <span class="n">wavelength</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_ysep</span> <span class="o">*</span> <span class="mf">2.35482</span><span class="p">)</span>
        <span class="n">window_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsigma_dec</span> <span class="o">*</span> <span class="n">sigma_y</span>

        <span class="c1"># In the RA direction, we use the primary beam width,</span>
        <span class="c1"># because we have significant grating lobes.</span>
        <span class="n">sigma_x</span> <span class="o">=</span> <span class="n">cal_utils</span><span class="o">.</span><span class="n">guess_fwhm</span><span class="p">(</span>
            <span class="n">nu</span><span class="p">,</span>
            <span class="n">pol</span><span class="o">=</span><span class="s2">&quot;X&quot;</span><span class="p">,</span>
            <span class="n">dec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">src_dec</span><span class="p">),</span>
            <span class="n">sigma</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">voltage</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">seconds</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">window_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsigma_ra</span> <span class="o">*</span> <span class="n">sigma_x</span>

        <span class="c1"># Get the map grid in RA and telescope y</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">ra</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;el&quot;</span><span class="p">]</span>

        <span class="n">wrap_x</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">%</span> <span class="mf">360.0</span><span class="p">)</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Search the grid</span>
        <span class="n">xlower</span><span class="p">,</span> <span class="n">xupper</span> <span class="o">=</span> <span class="n">search_grid</span><span class="p">(</span><span class="n">src_ra</span><span class="p">,</span> <span class="n">window_x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="n">wrap_x</span><span class="p">)</span>
        <span class="n">ylower</span><span class="p">,</span> <span class="n">yupper</span> <span class="o">=</span> <span class="n">search_grid</span><span class="p">(</span><span class="n">src_y</span><span class="p">,</span> <span class="n">window_y</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_alias</span><span class="p">:</span>
            <span class="n">y2lower</span><span class="p">,</span> <span class="n">y2upper</span> <span class="o">=</span> <span class="n">search_grid</span><span class="p">(</span><span class="n">src_yalias</span><span class="p">,</span> <span class="n">window_y</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Loop over sources</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">nsource</span><span class="p">):</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_redshift</span><span class="p">:</span>
                <span class="n">freq_diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">freq</span><span class="p">[</span><span class="n">ii</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">src_freq</span><span class="p">[</span><span class="n">ii</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="o">/</span> <span class="n">src_freq_err</span><span class="p">[</span><span class="n">ii</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">freq_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsigma_freq</span><span class="p">:</span>
                    <span class="k">continue</span>

            <span class="k">if</span> <span class="n">xupper</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">xlower</span><span class="p">[</span><span class="n">ii</span><span class="p">]:</span>
                <span class="n">xslice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">xlower</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">xupper</span><span class="p">[</span><span class="n">ii</span><span class="p">])]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xslice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">xlower</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">xupper</span><span class="p">[</span><span class="n">ii</span><span class="p">])]</span>

            <span class="n">yslice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">ylower</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">yupper</span><span class="p">[</span><span class="n">ii</span><span class="p">])]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_alias</span><span class="p">:</span>
                <span class="n">yslice</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">y2lower</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">y2upper</span><span class="p">[</span><span class="n">ii</span><span class="p">]))</span>

            <span class="k">for</span> <span class="n">xslc</span> <span class="ow">in</span> <span class="n">xslice</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">yslc</span> <span class="ow">in</span> <span class="n">yslice</span><span class="p">:</span>
                    <span class="n">mask</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xslc</span><span class="p">,</span> <span class="n">yslc</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Return the output container with the source mask</span>
        <span class="k">return</span> <span class="n">out</span></div>
</div>



<div class="viewcode-block" id="MaskSourcePixelsFromCatalog">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.MaskSourcePixelsFromCatalog">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MaskSourcePixelsFromCatalog</span><span class="p">(</span><span class="n">SourcePixelsMixin</span><span class="p">,</span> <span class="n">MaskFromCatalogBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mask regions of a map near bright point sources.&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="MaskSourceTracksFromCatalog">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.MaskSourceTracksFromCatalog">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MaskSourceTracksFromCatalog</span><span class="p">(</span><span class="n">SourceTracksMixin</span><span class="p">,</span> <span class="n">MaskFromCatalogBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mask regions of a map near the U-shaped tracks of bright point sources.&quot;&quot;&quot;</span></div>



<span class="n">MaskBrightSourcePixels</span> <span class="o">=</span> <span class="n">MaskSourcePixelsFromCatalog</span>
<span class="n">MaskBrightSourceTracks</span> <span class="o">=</span> <span class="n">MaskSourceTracksFromCatalog</span>


<div class="viewcode-block" id="TaperFromCatalogBase">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.TaperFromCatalogBase">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">TaperFromCatalogBase</span><span class="p">(</span><span class="n">CatalogBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Taper regions of a map near bright point sources.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    mask_alias : bool</span>
<span class="sd">        Mask the frequency-dependent, north-south alias location</span>
<span class="sd">        in addition to the true location.</span>
<span class="sd">    common_freq : bool</span>
<span class="sd">        Ensure the (non-aliased) mask is frequency independent by</span>
<span class="sd">        constructing the windows using the minimum frequency.</span>
<span class="sd">    nsigma_ra : float</span>
<span class="sd">        Width of the window to mask in the RA direction specified in</span>
<span class="sd">        number of sigma of the primary beam.</span>
<span class="sd">    nsigma_dec : float</span>
<span class="sd">        Width of the window to mask in the dec direction specified</span>
<span class="sd">        in number of sigma of the synthesized beam.</span>
<span class="sd">    nsigma_freq : float</span>
<span class="sd">        Width of the window to mask in the freq direction specified</span>
<span class="sd">        in the number of sigma given by the catalog redshift error.</span>
<span class="sd">        Only relevant if the catalog provided during setup has</span>
<span class="sd">        redshift information</span>
<span class="sd">    spatial_taper : float</span>
<span class="sd">        Extent over which the taper transitions from 0 to 1 in</span>
<span class="sd">        units of normalized spatial coordinates.</span>
<span class="sd">    spectral_taper : float</span>
<span class="sd">        Extent over which the taper transitions from 0 to 1 in</span>
<span class="sd">        the normalized spectral coordinates.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mask_alias</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">common_freq</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">nsigma_ra</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">3.0</span><span class="p">)</span>
    <span class="n">nsigma_dec</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">3.0</span><span class="p">)</span>
    <span class="n">nsigma_freq</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">3.0</span><span class="p">)</span>

    <span class="n">spatial_taper</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">spectral_taper</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>

<div class="viewcode-block" id="TaperFromCatalogBase.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.TaperFromCatalogBase.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate a mask that excludes pixels near transit of bright point sources.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : RingMap or HybridVisStream</span>
<span class="sd">            Beamformed dataset to be flagged. Must have a &quot;ra&quot; axis and</span>
<span class="sd">            an &quot;el&quot; axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : RingMapMask</span>
<span class="sd">            Boolean mask with True indicating that a pixel is near</span>
<span class="sd">            a bright source.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Distribute over frequencies</span>
        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="n">min_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_bounds</span><span class="p">]</span>
        <span class="n">nfreq</span> <span class="o">=</span> <span class="n">freq</span><span class="o">.</span><span class="n">size</span>

        <span class="c1"># Create output container</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">dcontainers</span><span class="o">.</span><span class="n">RingMapTaper</span><span class="p">(</span>
            <span class="n">axes_from</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">attrs_from</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">distributed</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">distributed</span><span class="p">,</span>
            <span class="n">comm</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="n">taper</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">taper</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">taper</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c1"># Determine the coordinates of the sources in the current epoch</span>
        <span class="n">src_ind</span><span class="p">,</span> <span class="n">src_ra</span><span class="p">,</span> <span class="n">src_dec</span><span class="p">,</span> <span class="n">src_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_source_coordinates</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="n">nsource</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">src_ind</span><span class="p">)</span><span class="o">.</span><span class="n">size</span>

        <span class="n">src_bnd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">src_ind</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">src_ind</span><span class="o">.</span><span class="n">size</span><span class="p">])</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_redshift</span><span class="p">:</span>
            <span class="n">src_freq</span><span class="p">,</span> <span class="n">src_freq_err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_source_freq</span><span class="p">()</span>
            <span class="n">window_freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsigma_freq</span> <span class="o">*</span> <span class="n">src_freq_err</span>

        <span class="c1"># Get aliased coordinates as well</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_alias</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span> <span class="o">/</span> <span class="p">(</span><span class="n">freq</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1e6</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_ysep</span><span class="p">)</span>
            <span class="n">src_yalias</span> <span class="o">=</span> <span class="n">src_y</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">src_y</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">))</span> <span class="o">*</span> <span class="n">b</span>  <span class="c1"># nfreq, nsource</span>

        <span class="c1"># Get the size of the window</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">nfreq</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">min_freq</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">common_freq</span> <span class="k">else</span> <span class="n">freq</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">wavelength</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span> <span class="o">/</span> <span class="p">(</span><span class="n">nu</span> <span class="o">*</span> <span class="mf">1e6</span><span class="p">)</span>

        <span class="c1"># In the sin(za) direction, we use the synthesized beam.</span>
        <span class="c1"># 0.85 * wavelength / max_ysep gives the FWHM for a natural weighting scheme,</span>
        <span class="c1"># and the factor of 2.35482 converts from FWHM to sigma.</span>
        <span class="n">sigma_y</span> <span class="o">=</span> <span class="mf">0.85</span> <span class="o">*</span> <span class="n">wavelength</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_ysep</span> <span class="o">*</span> <span class="mf">2.35482</span><span class="p">)</span>
        <span class="n">window_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsigma_dec</span> <span class="o">*</span> <span class="n">sigma_y</span>

        <span class="c1"># In the RA direction, we use the primary beam width,</span>
        <span class="c1"># because we have significant grating lobes.</span>
        <span class="n">sigma_x</span> <span class="o">=</span> <span class="n">cal_utils</span><span class="o">.</span><span class="n">guess_fwhm</span><span class="p">(</span>
            <span class="n">nu</span><span class="p">,</span>
            <span class="n">pol</span><span class="o">=</span><span class="s2">&quot;X&quot;</span><span class="p">,</span>
            <span class="n">dec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">src_dec</span><span class="p">),</span>
            <span class="n">sigma</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">voltage</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">seconds</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">window_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsigma_ra</span> <span class="o">*</span> <span class="n">sigma_x</span>

        <span class="c1"># Get the map grid in RA and telescope y</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">ra</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;el&quot;</span><span class="p">]</span>

        <span class="n">wrap_x</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">%</span> <span class="mf">360.0</span><span class="p">)</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">xg</span><span class="p">,</span> <span class="n">yg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s2">&quot;ij&quot;</span><span class="p">)</span>

        <span class="c1"># Create a function for applying a cosine taper.</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_cosine_taper</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">taper_width</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Cosine taper function.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">taper_width</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">d_clipped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">taper_width</span><span class="p">)</span>
                <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">d_clipped</span> <span class="o">/</span> <span class="n">taper_width</span><span class="p">))</span>

            <span class="c1"># If taper_width is zero, use a hard cutoff.</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># Loop over sources</span>
        <span class="k">for</span> <span class="n">ff</span><span class="p">,</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">nsource</span><span class="p">):</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_redshift</span><span class="p">:</span>
                <span class="n">freq_diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">((</span><span class="n">freq</span><span class="p">[</span><span class="n">ff</span><span class="p">]</span> <span class="o">-</span> <span class="n">src_freq</span><span class="p">[</span><span class="n">ss</span><span class="p">])</span> <span class="o">/</span> <span class="n">window_freq</span><span class="p">[</span><span class="n">ss</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">freq_diff</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_taper</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">freq_factor</span> <span class="o">=</span> <span class="n">_cosine_taper</span><span class="p">(</span><span class="n">freq_diff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral_taper</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">freq_factor</span> <span class="o">=</span> <span class="mf">1.0</span>

            <span class="n">this_src</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">src_bnd</span><span class="p">[</span><span class="n">ss</span><span class="p">],</span> <span class="n">src_bnd</span><span class="p">[</span><span class="n">ss</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

            <span class="n">win_x</span> <span class="o">=</span> <span class="n">window_x</span><span class="p">[</span><span class="n">ff</span><span class="p">,</span> <span class="n">src_bnd</span><span class="p">[</span><span class="n">ss</span><span class="p">]]</span>
            <span class="n">win_y</span> <span class="o">=</span> <span class="n">window_y</span><span class="p">[</span><span class="n">ff</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

            <span class="n">track_x</span> <span class="o">=</span> <span class="n">src_ra</span><span class="p">[</span><span class="n">this_src</span><span class="p">]</span> <span class="o">/</span> <span class="n">win_x</span>
            <span class="n">track_y</span> <span class="o">=</span> <span class="n">src_y</span><span class="p">[</span><span class="n">this_src</span><span class="p">]</span> <span class="o">/</span> <span class="n">win_y</span>

            <span class="k">if</span> <span class="n">wrap_x</span><span class="p">:</span>
                <span class="n">track_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">track_x</span><span class="p">,</span> <span class="n">track_x</span> <span class="o">+</span> <span class="mf">360.0</span> <span class="o">/</span> <span class="n">win_x</span><span class="p">,</span> <span class="n">track_x</span> <span class="o">-</span> <span class="mf">360.0</span> <span class="o">/</span> <span class="n">win_x</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">track_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">track_y</span><span class="p">,</span> <span class="n">track_y</span><span class="p">,</span> <span class="n">track_y</span><span class="p">))</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_alias</span><span class="p">:</span>
                <span class="n">track_yalias</span> <span class="o">=</span> <span class="n">src_yalias</span><span class="p">[</span><span class="n">this_src</span><span class="p">]</span> <span class="o">/</span> <span class="n">win_y</span>
                <span class="k">if</span> <span class="n">wrap_x</span><span class="p">:</span>
                    <span class="n">track_yalias</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">track_yalias</span><span class="p">,</span> <span class="n">track_yalias</span><span class="p">,</span> <span class="n">track_yalias</span><span class="p">)</span>
                    <span class="p">)</span>

                <span class="n">track_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatentate</span><span class="p">((</span><span class="n">track_x</span><span class="p">,</span> <span class="n">track_x</span><span class="p">))</span>
                <span class="n">track_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatentate</span><span class="p">((</span><span class="n">track_y</span><span class="p">,</span> <span class="n">track_yalias</span><span class="p">))</span>

            <span class="n">track_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">track_x</span><span class="p">,</span> <span class="n">track_y</span><span class="p">))</span>

            <span class="n">grid_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">xg</span> <span class="o">/</span> <span class="n">win_x</span><span class="p">,</span> <span class="n">yg</span> <span class="o">/</span> <span class="n">win_y</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">tree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">track_points</span><span class="p">)</span>

            <span class="n">distances</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">grid_points</span><span class="p">)</span>

            <span class="n">taper</span><span class="p">[:,</span> <span class="n">ff</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">freq_factor</span> <span class="o">*</span> <span class="n">_cosine_taper</span><span class="p">(</span>
                <span class="n">distances</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spatial_taper</span>
            <span class="p">)</span>

        <span class="c1"># Return the output container with the source mask</span>
        <span class="k">return</span> <span class="n">out</span></div>
</div>



<div class="viewcode-block" id="TaperSourcePixelsFromCatalog">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.TaperSourcePixelsFromCatalog">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">TaperSourcePixelsFromCatalog</span><span class="p">(</span><span class="n">SourcePixelsMixin</span><span class="p">,</span> <span class="n">TaperFromCatalogBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Taper regions of a map near bright point sources.&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="TaperSourceTracksFromCatalog">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.TaperSourceTracksFromCatalog">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">TaperSourceTracksFromCatalog</span><span class="p">(</span><span class="n">SourceTracksMixin</span><span class="p">,</span> <span class="n">TaperFromCatalogBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Taper regions of a map near the U-shaped tracks of bright point sources.&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="MaskAliasedMap">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.MaskAliasedMap">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MaskAliasedMap</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mask regions of a map that contain north-south aliases.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    common_freq : bool</span>
<span class="sd">        Generate a common mask for all frequencies, set by the</span>
<span class="sd">        maximum frequency in the container.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">common_freq</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="MaskAliasedMap.setup">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.MaskAliasedMap.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">manager</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract the minimum baseline separation from the telescope class.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        manager : io.TelescopeConvertible</span>
<span class="sd">            Telescope/manager used to extract the baseline distances</span>
<span class="sd">            to calculate the minimum separation in the north-south direction</span>
<span class="sd">            needed to compute aliases.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Determine the layout of the visibilities on the grid.</span>
        <span class="n">telescope</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">get_telescope</span><span class="p">(</span><span class="n">manager</span><span class="p">)</span>
        <span class="n">min_ysep</span> <span class="o">=</span> <span class="n">find_grid_indices</span><span class="p">(</span><span class="n">telescope</span><span class="o">.</span><span class="n">baselines</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Save the minimum north-south separation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_ysep</span> <span class="o">=</span> <span class="n">min_ysep</span></div>


<div class="viewcode-block" id="MaskAliasedMap.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.MaskAliasedMap.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ringmap</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mask data beamformed to zenith angles beyond the aliased horizon.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ringmap : RingMap</span>
<span class="sd">            Ringmap to be flagged.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ringmap : RingMap</span>
<span class="sd">            Input container with weights set to zero for</span>
<span class="sd">            zenith angles beyond the aliased horizon.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Destribute over frequency</span>
        <span class="n">ringmap</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Extract el and freq axis</span>
        <span class="n">el</span> <span class="o">=</span> <span class="n">ringmap</span><span class="o">.</span><span class="n">index_map</span><span class="p">[</span><span class="s2">&quot;el&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">common_freq</span><span class="p">:</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ringmap</span><span class="o">.</span><span class="n">freq</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="n">ringmap</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="n">ringmap</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_bounds</span><span class="p">]</span>

        <span class="n">horizon_limit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_horizon_limit</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

        <span class="n">flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">el</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:])</span> <span class="o">&lt;</span> <span class="n">horizon_limit</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="n">waxis</span> <span class="o">=</span> <span class="n">ringmap</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span>
        <span class="n">wslc</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">wax</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">,</span> <span class="s2">&quot;el&quot;</span><span class="p">]</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">wax</span> <span class="ow">in</span> <span class="n">waxis</span><span class="p">]</span>

        <span class="n">ringmap</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">flag</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">wslc</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">ringmap</span></div>


<div class="viewcode-block" id="MaskAliasedMap.get_horizon_limit">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.flagging.html#ch_pipeline.analysis.flagging.MaskAliasedMap.get_horizon_limit">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_horizon_limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the value of sin(za) where the southern horizon aliases.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq : np.ndarray[nfreq,]</span>
<span class="sd">            Frequency in MHz.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        horizon_limit : np.ndarray[nfreq,]</span>
<span class="sd">            This is the value of sin(za) where the southern horizon aliases.</span>
<span class="sd">            Regions of sky where ``|sin(za)|`` is greater than or equal to</span>
<span class="sd">            this value will contain aliases.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">c</span> <span class="o">/</span> <span class="p">(</span><span class="n">freq</span> <span class="o">*</span> <span class="mf">1e6</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_ysep</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015, CHIME collaboration.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>