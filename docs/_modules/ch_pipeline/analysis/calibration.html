

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ch_pipeline.analysis.calibration &mdash; ch_pipeline  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            ch_pipeline
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev.html">Development Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference.html">Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ch_pipeline</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">ch_pipeline.analysis.calibration</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for ch_pipeline.analysis.calibration</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Tasks for calibrating the data.&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">caput.time</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ctime</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.signal</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">caput</span><span class="w"> </span><span class="kn">import</span> <span class="n">config</span><span class="p">,</span> <span class="n">memh5</span><span class="p">,</span> <span class="n">mpiarray</span><span class="p">,</span> <span class="n">mpiutil</span><span class="p">,</span> <span class="n">weighted_median</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ch_ephem</span><span class="w"> </span><span class="kn">import</span> <span class="n">coord</span><span class="p">,</span> <span class="n">sources</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ch_ephem.observers</span><span class="w"> </span><span class="kn">import</span> <span class="n">chime</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ch_util</span><span class="w"> </span><span class="kn">import</span> <span class="n">andata</span><span class="p">,</span> <span class="n">cal_utils</span><span class="p">,</span> <span class="n">ephemeris</span><span class="p">,</span> <span class="n">finder</span><span class="p">,</span> <span class="n">fluxcat</span><span class="p">,</span> <span class="n">ni_utils</span><span class="p">,</span> <span class="n">rfi</span><span class="p">,</span> <span class="n">tools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">draco.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">containers</span><span class="p">,</span> <span class="n">task</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">draco.util</span><span class="w"> </span><span class="kn">import</span> <span class="n">_fast_tools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">mpi4py</span><span class="w"> </span><span class="kn">import</span> <span class="n">MPI</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">interpolate</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.constants</span><span class="w"> </span><span class="kn">import</span> <span class="n">c</span> <span class="k">as</span> <span class="n">speed_of_light</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">..core</span><span class="w"> </span><span class="kn">import</span> <span class="n">containers</span> <span class="k">as</span> <span class="n">ccontainers</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..core.dataquery</span><span class="w"> </span><span class="kn">import</span> <span class="n">_DEFAULT_NODE_SPOOF</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_extract_diagonal</span><span class="p">(</span><span class="n">utmat</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract the diagonal elements of an upper triangular array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    utmat : np.ndarray[..., nprod, ...]</span>
<span class="sd">        Upper triangular array.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis of array that is upper triangular.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    diag : np.ndarray[..., ninput, ...]</span>
<span class="sd">        Diagonal of the array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Estimate nside from the array shape</span>
    <span class="n">nside</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">utmat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span>

    <span class="c1"># Check that this nside is correct</span>
    <span class="k">if</span> <span class="n">utmat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">!=</span> <span class="p">(</span><span class="n">nside</span> <span class="o">*</span> <span class="p">(</span><span class="n">nside</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Array length (</span><span class="si">{</span><span class="n">utmat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">) of axis </span><span class="si">{</span><span class="n">axis</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> does not correspond upper triangle</span><span class="se">\</span>
<span class="s2">                of square matrix&quot;</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="c1"># Find indices of the diagonal</span>
    <span class="n">diag_ind</span> <span class="o">=</span> <span class="p">[</span><span class="n">tools</span><span class="o">.</span><span class="n">cmap</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">nside</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nside</span><span class="p">)]</span>

    <span class="c1"># Construct slice objects representing the axes before and after the product axis</span>
    <span class="n">slice0</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[:],)</span> <span class="o">*</span> <span class="n">axis</span>
    <span class="n">slice1</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[:],)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">utmat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="n">axis</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Extract wanted elements with a giant slice</span>
    <span class="n">sl</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">slice0</span><span class="p">,</span> <span class="n">diag_ind</span><span class="p">,</span> <span class="o">*</span><span class="n">slice1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">utmat</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span>


<div class="viewcode-block" id="solve_gain">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.solve_gain">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">solve_gain</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">feeds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate gain from largest eigenvector.</span>

<span class="sd">    Step through each time/freq pixel, generate a Hermitian matrix,</span>
<span class="sd">    perform eigendecomposition, iteratively replacing the diagonal</span>
<span class="sd">    elements with a low-rank approximation, and calculate complex gains</span>
<span class="sd">    from the largest eigenvector.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : np.ndarray[nfreq, nprod, ntime]</span>
<span class="sd">        Visibility array to be decomposed</span>
<span class="sd">    feeds : list</span>
<span class="sd">        Which feeds to include. If :obj:`None` include all feeds.</span>
<span class="sd">    norm : np.ndarray[nfreq, nfeed, ntime], optional</span>
<span class="sd">        Array to use for weighting.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    evalue : np.ndarray[nfreq, nfeed, ntime]</span>
<span class="sd">        Eigenvalues obtained from eigenvalue decomposition</span>
<span class="sd">        of the visibility matrix.</span>
<span class="sd">    gain : np.ndarray[nfreq, nfeed, ntime]</span>
<span class="sd">        Gain solution for each feed, time, and frequency</span>
<span class="sd">    gain_error : np.ndarray[nfreq, nfeed, ntime]</span>
<span class="sd">        Error on the gain solution for each feed, time, and frequency</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Turn into numpy array to avoid any unfortunate indexing issues</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

    <span class="c1"># Calcuate the number of feeds in the data matrix</span>
    <span class="n">tfeed</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span>

    <span class="c1"># If not set, create the list of included feeds (i.e. all feeds)</span>
    <span class="n">feeds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">feeds</span><span class="p">)</span> <span class="k">if</span> <span class="n">feeds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">tfeed</span><span class="p">)</span>
    <span class="n">nfeed</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">feeds</span><span class="p">)</span>

    <span class="c1"># Create empty arrays to store the outputs</span>
    <span class="n">gain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nfeed</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
    <span class="n">gain_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nfeed</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">evalue</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nfeed</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="c1"># Set up normalisation matrix</span>
    <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="p">(</span><span class="n">_extract_diagonal</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">real</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">norm</span><span class="p">[:,</span> <span class="n">feeds</span><span class="p">]</span>

    <span class="k">elif</span> <span class="n">norm</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">gain</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Input normalization matrix has shape </span><span class="si">{</span><span class="n">norm</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;should have shape </span><span class="si">{</span><span class="n">gain</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Pre-generate the array of inverted norms</span>
    <span class="n">inv_norm</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>

    <span class="c1"># Initialise a temporary array for unpacked products</span>
    <span class="n">cd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nfeed</span><span class="p">,</span> <span class="n">nfeed</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Iterate over frequency/time and solve gains</span>
    <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="c1"># Skip if all zeros</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">fi</span><span class="p">,</span> <span class="p">:,</span> <span class="n">ti</span><span class="p">]):</span>
                <span class="k">continue</span>

            <span class="c1"># Unpack visibility and normalisation array into square matrix</span>
            <span class="n">_fast_tools</span><span class="o">.</span><span class="n">_unpack_product_array_fast</span><span class="p">(</span>
                <span class="n">data</span><span class="p">[</span><span class="n">fi</span><span class="p">,</span> <span class="p">:,</span> <span class="n">ti</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">cd</span><span class="p">,</span> <span class="n">feeds</span><span class="p">,</span> <span class="n">tfeed</span>
            <span class="p">)</span>

            <span class="c1"># Apply weighting</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">norm</span><span class="p">[</span><span class="n">fi</span><span class="p">,</span> <span class="p">:,</span> <span class="n">ti</span><span class="p">]</span>
            <span class="n">cd</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">w</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span>

            <span class="c1"># Skip if any non-finite values</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">cd</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">continue</span>

            <span class="c1"># Solve for eigenvectors and eigenvalues</span>
            <span class="n">evals</span><span class="p">,</span> <span class="n">evecs</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">eigh_no_diagonal</span><span class="p">(</span><span class="n">cd</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

            <span class="c1"># Construct gain solutions</span>
            <span class="k">if</span> <span class="n">evals</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sign0</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">evecs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">real</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">)</span>
                <span class="n">gain</span><span class="p">[</span><span class="n">fi</span><span class="p">,</span> <span class="p">:,</span> <span class="n">ti</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">sign0</span> <span class="o">*</span> <span class="n">inv_norm</span><span class="p">[</span><span class="n">fi</span><span class="p">,</span> <span class="p">:,</span> <span class="n">ti</span><span class="p">]</span> <span class="o">*</span> <span class="n">evecs</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">evals</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mf">0.5</span>
                <span class="p">)</span>

                <span class="n">gain_error</span><span class="p">[</span><span class="n">fi</span><span class="p">,</span> <span class="p">:,</span> <span class="n">ti</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">inv_norm</span><span class="p">[</span><span class="n">fi</span><span class="p">,</span> <span class="p">:,</span> <span class="n">ti</span><span class="p">]</span>
                    <span class="o">*</span> <span class="mf">1.4826</span>
                    <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">evals</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">evals</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>
                    <span class="o">/</span> <span class="n">evals</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mf">0.5</span>
                <span class="p">)</span>

                <span class="n">evalue</span><span class="p">[</span><span class="n">fi</span><span class="p">,</span> <span class="p">:,</span> <span class="n">ti</span><span class="p">]</span> <span class="o">=</span> <span class="n">evals</span>

            <span class="c1"># Solve for eigenvectors</span>
            <span class="c1"># evals, evecs = tools.eigh_no_diagonal(cd, niter=5, eigvals=(nfeed - 2, nfeed - 1))</span>

            <span class="c1"># Construct dynamic range and gain, but only if the two highest</span>
            <span class="c1"># eigenvalues are positive. If not, we just let the gain and dynamic</span>
            <span class="c1"># range stay as zero.</span>
            <span class="c1"># if evals[-1] &gt; 0 and evals[-2] &gt; 0:</span>
            <span class="c1">#     dr[fi, ti] = evals[-1] / evals[-2]</span>
            <span class="c1">#     gain[fi, :, ti] = inv_norm[fi, :, ti] * evecs[:, -1] * evals[-1]**0.5</span>

    <span class="k">return</span> <span class="n">evalue</span><span class="p">,</span> <span class="n">gain</span><span class="p">,</span> <span class="n">gain_error</span></div>



<div class="viewcode-block" id="interp_gains">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.interp_gains">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">interp_gains</span><span class="p">(</span><span class="n">trans_times</span><span class="p">,</span> <span class="n">gain_mat</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Linearly interpolates gain solutions in sidereal day.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    trans_times : array_like</span>
<span class="sd">        Unix time of object transit</span>
<span class="sd">    gain_mat : array_like</span>
<span class="sd">        Array of gains shaped (freq, ncorr, ndays)</span>
<span class="sd">    times : array_like</span>
<span class="sd">        Timestamps onto which gain solution is interpolated</span>
<span class="sd">    axis : int</span>
<span class="sd">        Axis along which to interpolate.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Array of interpolated gains</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span>
        <span class="n">trans_times</span><span class="p">,</span> <span class="n">gain_mat</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>

    <span class="n">gains</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
    <span class="n">gains</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">times</span> <span class="o">&lt;</span> <span class="n">trans_times</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">gain_mat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="n">gains</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">times</span> <span class="o">&gt;</span> <span class="n">trans_times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">gain_mat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">gains</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_cdiff</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subtract the average of two nearby points from every point in the timestream.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ts</span>

    <span class="k">return</span> <span class="n">ts</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="o">-</span><span class="n">dt</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_adiff</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subtract the average of the first dt points and last dt points from every point.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ts</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">ts</span>
        <span class="o">-</span> <span class="mf">0.5</span>
        <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">dt</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="n">dt</span><span class="p">:],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))[</span>
            <span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span>
        <span class="p">]</span>
    <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_contiguous_flag</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="n">centre</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Flag everything outside the contiguous unflagged region around centre.&quot;&quot;&quot;</span>
    <span class="n">nelem</span> <span class="o">=</span> <span class="n">flag</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">shp</span> <span class="o">=</span> <span class="n">flag</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">centre</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">centre</span> <span class="o">=</span> <span class="n">nelem</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="o">*</span><span class="n">shp</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">centre</span><span class="p">,</span> <span class="n">nelem</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">flag</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">ii</span><span class="p">]:</span>
                <span class="n">flag</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">ii</span><span class="p">:]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">continue</span>

        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">centre</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">flag</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">ii</span><span class="p">]:</span>
                <span class="n">flag</span><span class="p">[</span><span class="n">index</span><span class="p">][:</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">continue</span>

    <span class="k">return</span> <span class="n">flag</span>


<div class="viewcode-block" id="NoiseSourceFold">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.NoiseSourceFold">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">NoiseSourceFold</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fold the noise source for synced data.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    period : int, optional</span>
<span class="sd">        Period of the noise source in integration samples.</span>
<span class="sd">    phase : list, optional</span>
<span class="sd">        Phase of noise source on sample.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">period</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">[])</span>
    <span class="n">only_off</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="NoiseSourceFold.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.NoiseSourceFold.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fold on the noise source and generate a gated dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ts : andata.CorrData object</span>
<span class="sd">            Timestream to fold on.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        folded_ts : andata.CorrData</span>
<span class="sd">            Timestream with a gated_vis0 dataset containing the noise</span>
<span class="sd">            source data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">period</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase</span><span class="p">):</span>
            <span class="n">ni_params</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ni_params</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;ni_period&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">period</span><span class="p">,</span> <span class="s2">&quot;ni_on_bins&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase</span><span class="p">}</span>

        <span class="k">return</span> <span class="n">ni_utils</span><span class="o">.</span><span class="n">process_synced_data</span><span class="p">(</span>
            <span class="n">ts</span><span class="p">,</span> <span class="n">ni_params</span><span class="o">=</span><span class="n">ni_params</span><span class="p">,</span> <span class="n">only_off</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">only_off</span>
        <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="NoiseInjectionCalibration">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.NoiseInjectionCalibration">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">NoiseInjectionCalibration</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">MPILoggedTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calibration using noise injection.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    nchannels : int, optional</span>
<span class="sd">        Number of channels (default 16).</span>
<span class="sd">    ch_ref : int in the range 0 &lt;= ch_ref &lt;= Nchannels-1, optional</span>
<span class="sd">        Reference channel (default 0).</span>
<span class="sd">    fbin_ref : int, optional</span>
<span class="sd">        Reference frequency bin</span>
<span class="sd">    decimate_only : bool, optional</span>
<span class="sd">        If set (not default), then we do not apply the gain solution</span>
<span class="sd">        and return a decimated but uncalibrated timestream.</span>

<span class="sd">    .. deprecated:: pass1G</span>
<span class="sd">        This calibration technique only works on old data from before Pass 1G.</span>
<span class="sd">        For more recent data, look at :class:`GatedNoiseCalibration`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nchannels</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">ch_ref</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">fbin_ref</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="n">decimate_only</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="NoiseInjectionCalibration.setup">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.NoiseInjectionCalibration.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputmap</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Use the input map to set up the calibrator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inputmap : list of :class:`tools.CorrInputs`</span>
<span class="sd">            Describing the inputs to the correlator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ch_ref</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">get_noise_channel</span><span class="p">(</span><span class="n">inputmap</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Using input=</span><span class="si">%i</span><span class="s2"> as noise channel&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_ref</span><span class="p">)</span></div>


<div class="viewcode-block" id="NoiseInjectionCalibration.next">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.NoiseInjectionCalibration.next">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find gains from noise injection data and apply them to visibilities.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ts : containers.TimeStream</span>
<span class="sd">            Parallel timestream class containing noise injection data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cts : containers.CalibratedTimeStream</span>
<span class="sd">            Timestream with calibrated (decimated) visibilities, gains and</span>
<span class="sd">            respective timestamps.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This method should derive the gains from the data as it comes in,</span>
        <span class="c1"># and apply the corrections to rigidise the data</span>
        <span class="c1">#</span>
        <span class="c1"># The data will come be received as a containers.TimeStream type. In</span>
        <span class="c1"># some ways this looks a little like AnData, but it works in parallel</span>

        <span class="c1"># Ensure that we are distributed over frequency</span>

        <span class="n">ts</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Create noise injection data object from input timestream</span>
        <span class="n">nidata</span> <span class="o">=</span> <span class="n">ni_utils</span><span class="o">.</span><span class="n">ni_data</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchannels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_ref</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fbin_ref</span><span class="p">)</span>

        <span class="c1"># Decimated visibilities without calibration</span>
        <span class="n">vis_uncal</span> <span class="o">=</span> <span class="n">nidata</span><span class="o">.</span><span class="n">vis_off_dec</span>

        <span class="c1"># Timestamp corresponding to decimated visibilities</span>
        <span class="n">timestamp</span> <span class="o">=</span> <span class="n">nidata</span><span class="o">.</span><span class="n">timestamp_dec</span>

        <span class="c1"># Find gains</span>
        <span class="n">nidata</span><span class="o">.</span><span class="n">get_ni_gains</span><span class="p">()</span>
        <span class="n">gain</span> <span class="o">=</span> <span class="n">nidata</span><span class="o">.</span><span class="n">ni_gains</span>

        <span class="c1"># Correct decimated visibilities</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">decimate_only</span><span class="p">:</span>
            <span class="n">vis</span> <span class="o">=</span> <span class="n">vis_uncal</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Apply the gain solution</span>
            <span class="n">gain_inv</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">gain</span><span class="p">)</span>
            <span class="n">vis</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">apply_gain</span><span class="p">(</span><span class="n">vis_uncal</span><span class="p">,</span> <span class="n">gain_inv</span><span class="p">)</span>

        <span class="c1"># Calculate dynamic range</span>
        <span class="n">ev</span> <span class="o">=</span> <span class="n">ni_utils</span><span class="o">.</span><span class="n">sort_evalues_mag</span><span class="p">(</span><span class="n">nidata</span><span class="o">.</span><span class="n">ni_evals</span><span class="p">)</span>  <span class="c1"># Sort evalues</span>
        <span class="n">dr</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ev</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">ev</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">dr</span> <span class="o">=</span> <span class="n">dr</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># Turn vis, gains and dr into MPIArray</span>
        <span class="n">vis</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">vis</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">ts</span><span class="o">.</span><span class="n">comm</span><span class="p">)</span>
        <span class="n">gain</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">gain</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">ts</span><span class="o">.</span><span class="n">comm</span><span class="p">)</span>
        <span class="n">dr</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">dr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">ts</span><span class="o">.</span><span class="n">comm</span><span class="p">)</span>

        <span class="c1"># Create NoiseInjTimeStream</span>
        <span class="n">cts</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">TimeStream</span><span class="p">(</span>
            <span class="n">timestamp</span><span class="p">,</span>
            <span class="n">ts</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">vis</span><span class="o">.</span><span class="n">global_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">comm</span><span class="o">=</span><span class="n">vis</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
            <span class="n">copy_attrs</span><span class="o">=</span><span class="n">ts</span><span class="p">,</span>
            <span class="n">gain</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">cts</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">vis</span>
        <span class="n">cts</span><span class="o">.</span><span class="n">gain</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">gain</span>
        <span class="n">cts</span><span class="o">.</span><span class="n">gain_dr</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">dr</span>
        <span class="n">cts</span><span class="o">.</span><span class="n">common</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">input</span>

        <span class="n">cts</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cts</span></div>
</div>



<div class="viewcode-block" id="GatedNoiseCalibration">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.GatedNoiseCalibration">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">GatedNoiseCalibration</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calibration using noise injection.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    norm : [&#39;gated&#39;, &#39;off&#39;, &#39;identity&#39;]</span>
<span class="sd">        Specify what to use to normalise the matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">norm</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;off&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="GatedNoiseCalibration.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.GatedNoiseCalibration.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">inputmap</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find gains from noise injection data and apply them to visibilities.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ts : andata.CorrData</span>
<span class="sd">            Parallel timestream class containing noise injection data.</span>
<span class="sd">        inputmap : list of CorrInputs</span>
<span class="sd">            List describing the inputs to the correlator.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ts : andata.CorrData</span>
<span class="sd">            Timestream with calibrated (decimated) visibilities, gains and</span>
<span class="sd">            respective timestamps.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure that we are distributed over frequency</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Figure out which input channel is the noise source (used as gain reference)</span>
        <span class="n">noise_channel</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">get_noise_channel</span><span class="p">(</span><span class="n">inputmap</span><span class="p">)</span>

        <span class="c1"># Get the norm matrix</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">==</span> <span class="s2">&quot;gated&quot;</span><span class="p">:</span>
            <span class="n">norm_array</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">_extract_diagonal</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;gated_vis0&quot;</span><span class="p">][:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
            <span class="p">)</span>
            <span class="n">norm_array</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">norm_array</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">==</span> <span class="s2">&quot;off&quot;</span><span class="p">:</span>
            <span class="n">norm_array</span> <span class="o">=</span> <span class="n">_extract_diagonal</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
            <span class="n">norm_array</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">norm_array</span><span class="p">)</span>

            <span class="c1"># Extract the points with zero weight (these will get zero norm)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">_extract_diagonal</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="n">w</span><span class="p">[:,</span> <span class="n">noise_channel</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Make sure we keep the noise channel though!</span>

            <span class="n">norm_array</span> <span class="o">*=</span> <span class="n">w</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
            <span class="n">norm_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
                <span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ts</span><span class="o">.</span><span class="n">ninput</span><span class="p">,</span> <span class="n">ts</span><span class="o">.</span><span class="n">ntime</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Value of norm not recognised.&quot;</span><span class="p">)</span>

        <span class="c1"># Take a view now to avoid some MPI issues</span>
        <span class="n">gate_view</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;gated_vis0&quot;</span><span class="p">][:]</span><span class="o">.</span><span class="n">local_array</span>

        <span class="c1"># Find gains with the eigenvalue method</span>
        <span class="n">evalue</span><span class="p">,</span> <span class="n">gain</span> <span class="o">=</span> <span class="n">solve_gain</span><span class="p">(</span><span class="n">gate_view</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm_array</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">dr</span> <span class="o">=</span> <span class="n">evalue</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">evalue</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span>

        <span class="c1"># Normalise by the noise source channel</span>
        <span class="n">gain</span> <span class="o">*=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">gain</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">noise_channel</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">gain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">gain</span><span class="p">)</span>

        <span class="c1"># Create container from gains</span>
        <span class="n">gain_data</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">GainData</span><span class="p">(</span><span class="n">axes_from</span><span class="o">=</span><span class="n">ts</span><span class="p">)</span>
        <span class="n">gain_data</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;weight&quot;</span><span class="p">)</span>

        <span class="c1"># Copy data into container</span>
        <span class="n">gain_data</span><span class="o">.</span><span class="n">gain</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">gain</span>
        <span class="n">gain_data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">dr</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">return</span> <span class="n">gain_data</span></div>
</div>



<div class="viewcode-block" id="DetermineSourceTransit">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.DetermineSourceTransit">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DetermineSourceTransit</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Determine the sources that are transiting within time range covered by container.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    source_list : list of str</span>
<span class="sd">        List of source names to consider.  If not specified, all sources</span>
<span class="sd">        contained in `ch_ephem.sources.source_dictionary` will be considered.</span>
<span class="sd">    freq : float</span>
<span class="sd">        Frequency in MHz.  Sort the sources by the flux at this frequency.</span>
<span class="sd">    require_transit: bool</span>
<span class="sd">        If this is True and a source transit is not found in the container,</span>
<span class="sd">        then the task will return None.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">source_list</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">[])</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">600.0</span><span class="p">)</span>
    <span class="n">require_transit</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<div class="viewcode-block" id="DetermineSourceTransit.setup">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.DetermineSourceTransit.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set list of sources, sorted by flux in descending order.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">source_list</span> <span class="ow">or</span> <span class="n">ephemeris</span><span class="o">.</span><span class="n">source_dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span>
            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">src</span><span class="p">:</span> <span class="n">fluxcat</span><span class="o">.</span><span class="n">FluxCatalog</span><span class="p">[</span><span class="n">src</span><span class="p">]</span><span class="o">.</span><span class="n">predict_flux</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">),</span>
            <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="DetermineSourceTransit.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.DetermineSourceTransit.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sstream</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add attributes to container describing source transit contained within.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sstream : containers.SiderealStream, containers.TimeStream, or equivalent</span>
<span class="sd">            Container covering the source transit.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sstream : containers.SiderealStream, containers.TimeStream, or equivalent</span>
<span class="sd">            Container covering the source transit, now with `source_name` and</span>
<span class="sd">            `transit_time` attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Determine the time covered by input container</span>
        <span class="k">if</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">sstream</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="n">sstream</span><span class="o">.</span><span class="n">time</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lsd</span> <span class="o">=</span> <span class="n">sstream</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;lsd&quot;</span><span class="p">,</span> <span class="n">sstream</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;csd&quot;</span><span class="p">))</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="n">chime</span><span class="o">.</span><span class="n">lsd_to_unix</span><span class="p">(</span><span class="n">lsd</span> <span class="o">+</span> <span class="n">sstream</span><span class="o">.</span><span class="n">ra</span> <span class="o">/</span> <span class="mf">360.0</span><span class="p">)</span>

        <span class="c1"># Loop over sources and check if there is a transit within time range</span>
        <span class="c1"># covered by container.  If so, then add attributes describing that source</span>
        <span class="c1"># and break from the loop.</span>
        <span class="n">contains_transit</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_list</span><span class="p">:</span>
            <span class="n">transit_time</span> <span class="o">=</span> <span class="n">chime</span><span class="o">.</span><span class="n">transit_times</span><span class="p">(</span>
                <span class="n">sources</span><span class="o">.</span><span class="n">source_dictionary</span><span class="p">[</span><span class="n">src</span><span class="p">],</span> <span class="n">timestamp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">timestamp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">transit_time</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Data stream contains </span><span class="si">{</span><span class="n">src</span><span class="si">}</span><span class="s2"> transit on LSD </span><span class="si">{</span><span class="n">chime</span><span class="o">.</span><span class="n">unix_to_lsd</span><span class="p">(</span><span class="n">transit_time</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
                <span class="n">sstream</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;source_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">src</span>
                <span class="n">sstream</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;transit_time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">transit_time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">contains_transit</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">contains_transit</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">require_transit</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sstream</span>

        <span class="k">return</span> <span class="kc">None</span></div>
</div>



<div class="viewcode-block" id="EigenCalibration">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.EigenCalibration">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">EigenCalibration</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Deteremine response of each feed to a point source.</span>

<span class="sd">    Extract the feed response from the real-time eigendecomposition</span>
<span class="sd">    of the N2 visibility matrix.  Flag frequencies that have low dynamic</span>
<span class="sd">    range, orthogonalize the polarizations, fringestop, and reference</span>
<span class="sd">    the phases appropriately.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    source : str</span>
<span class="sd">        Name of the source (same format as `sources.source_dictionary`).</span>
<span class="sd">    eigen_ref : int</span>
<span class="sd">        Index of the feed that is current phase reference of the eigenvectors.</span>
<span class="sd">    phase_ref : list</span>
<span class="sd">        Two element list that indicates the chan_id of the feeds to use</span>
<span class="sd">        as phase reference for the [Y, X] polarisation.</span>
<span class="sd">    med_phase_ref : bool</span>
<span class="sd">        Overides `phase_ref`, instead referencing the phase with respect</span>
<span class="sd">        to the median value over feeds of a given polarisation.</span>
<span class="sd">    neigen : int</span>
<span class="sd">        Number of eigenvalues to include in the orthogonalization.</span>
<span class="sd">    max_hour_angle : float</span>
<span class="sd">        The maximum hour angle in degrees to consider in the analysis.</span>
<span class="sd">        Hour angles between [window * max_hour_angle, max_hour_angle] will</span>
<span class="sd">        be used for the determination of the off source eigenvalue.</span>
<span class="sd">    window : float</span>
<span class="sd">        Fraction of the maximum hour angle considered still on source.</span>
<span class="sd">    dyn_rng_threshold : float</span>
<span class="sd">        Ratio of the second largest eigenvalue on source to the largest eigenvalue</span>
<span class="sd">        off source below which frequencies and times will be considered contaminated</span>
<span class="sd">        and discarded from further analysis.</span>
<span class="sd">    telescope_rotation : float</span>
<span class="sd">        Rotation of the telescope from true north in degrees.  A positive rotation is</span>
<span class="sd">        anti-clockwise when looking down at the telescope from the sky.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">source</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">eigen_ref</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">phase_ref</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">[</span><span class="mi">1152</span><span class="p">,</span> <span class="mi">1408</span><span class="p">])</span>
    <span class="n">med_phase_ref</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">neigen</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">max_hour_angle</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">10.0</span><span class="p">)</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.75</span><span class="p">)</span>
    <span class="n">dyn_rng_threshold</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">3.0</span><span class="p">)</span>
    <span class="n">telescope_rotation</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">chime</span><span class="o">.</span><span class="n">rotation</span><span class="p">)</span>

<div class="viewcode-block" id="EigenCalibration.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.EigenCalibration.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">inputmap</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine feed response from eigendecomposition.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : andata.CorrData</span>
<span class="sd">            CorrData object that contains the chimecal acquisition datasets,</span>
<span class="sd">            specifically vis, weight, erms, evec, and eval.</span>
<span class="sd">        inputmap : list of CorrInput&#39;s</span>
<span class="sd">            List describing the inputs as ordered in data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        response : containers.SiderealStream</span>
<span class="sd">            Response of each feed to the point source.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure that we are distributed over frequency</span>
        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Determine local dimensions</span>
        <span class="n">nfreq</span><span class="p">,</span> <span class="n">neigen</span><span class="p">,</span> <span class="n">ninput</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;evec&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">local_shape</span>

        <span class="c1"># Find the local frequencies</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_bounds</span><span class="p">]</span>

        <span class="c1"># Determine source name.  If not provided as config property, then check data attributes.</span>
        <span class="n">source_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="ow">or</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;source_name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">source_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The source name must be specified as a configuration property &quot;</span>
                <span class="s2">&quot;or added to input container attributes by an earlier task.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Compute flux of source</span>
        <span class="n">source_obj</span> <span class="o">=</span> <span class="n">fluxcat</span><span class="o">.</span><span class="n">FluxCatalog</span><span class="p">[</span><span class="n">source_name</span><span class="p">]</span>
        <span class="n">inv_rt_flux_density</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">source_obj</span><span class="o">.</span><span class="n">predict_flux</span><span class="p">(</span><span class="n">freq</span><span class="p">))</span>
        <span class="p">)</span>

        <span class="c1"># Determine source coordinates</span>
        <span class="n">ttrans</span> <span class="o">=</span> <span class="n">chime</span><span class="o">.</span><span class="n">transit_times</span><span class="p">(</span><span class="n">source_obj</span><span class="o">.</span><span class="n">skyfield</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">csd</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">chime</span><span class="o">.</span><span class="n">unix_to_lsd</span><span class="p">(</span><span class="n">ttrans</span><span class="p">)))</span>

        <span class="n">src_ra</span><span class="p">,</span> <span class="n">src_dec</span> <span class="o">=</span> <span class="n">chime</span><span class="o">.</span><span class="n">object_coords</span><span class="p">(</span>
            <span class="n">source_obj</span><span class="o">.</span><span class="n">skyfield</span><span class="p">,</span> <span class="n">date</span><span class="o">=</span><span class="n">ttrans</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="n">ra</span> <span class="o">=</span> <span class="n">chime</span><span class="o">.</span><span class="n">unix_to_lsa</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>

        <span class="n">ha</span> <span class="o">=</span> <span class="n">ra</span> <span class="o">-</span> <span class="n">src_ra</span>
        <span class="n">ha</span> <span class="o">=</span> <span class="p">((</span><span class="n">ha</span> <span class="o">+</span> <span class="mf">180.0</span><span class="p">)</span> <span class="o">%</span> <span class="mf">360.0</span><span class="p">)</span> <span class="o">-</span> <span class="mf">180.0</span>
        <span class="n">ha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">ha</span><span class="p">)</span>

        <span class="n">max_ha_off_source</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ha</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_hour_angle</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">min_ha_off_source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="o">*</span> <span class="n">max_ha_off_source</span>
        <span class="n">off_source</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ha</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">min_ha_off_source</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ha</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_ha_off_source</span>
        <span class="p">)</span>

        <span class="n">itrans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ha</span><span class="p">))</span>

        <span class="n">src_dec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">src_dec</span><span class="p">)</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">chime</span><span class="o">.</span><span class="n">latitude</span><span class="p">)</span>

        <span class="c1"># Dereference datasets</span>
        <span class="n">evec</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;evec&quot;</span><span class="p">][:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">evalue</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;eval&quot;</span><span class="p">][:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">erms</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;erms&quot;</span><span class="p">][:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">vis</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;vis&quot;</span><span class="p">][:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;vis_weight&quot;</span><span class="p">][:]</span><span class="o">.</span><span class="n">local_array</span>

        <span class="c1"># Check for negative autocorrelations (bug observed in older data)</span>
        <span class="n">negative_auto</span> <span class="o">=</span> <span class="n">vis</span><span class="o">.</span><span class="n">real</span> <span class="o">&lt;</span> <span class="mf">0.0</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">negative_auto</span><span class="p">):</span>
            <span class="n">vis</span><span class="p">[</span><span class="n">negative_auto</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="o">+</span> <span class="mf">0.0</span><span class="n">j</span>
            <span class="n">weight</span><span class="p">[</span><span class="n">negative_auto</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Find inputs that were not included in the eigenvalue decomposition</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">evec</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
        <span class="n">evec_all_zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">evec</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="n">input_flags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ninput</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ninput</span><span class="p">):</span>
            <span class="n">input_flags</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span>
                <span class="n">mpiutil</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="n">evec_all_zero</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">op</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">LAND</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">comm</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">input_flags</span><span class="p">)</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> inputs missing from eigenvalue decomposition.&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Check that we have data for the phase reference</span>
        <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_ref</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">input_flags</span><span class="p">[</span><span class="n">ref</span><span class="p">]:</span>
                <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Requested phase reference (</span><span class="si">{</span><span class="n">ref</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">) &quot;</span>
                    <span class="s2">&quot;was not included in decomposition.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Update input_flags to include feeds not present in database</span>
        <span class="k">for</span> <span class="n">idf</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inputmap</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">tools</span><span class="o">.</span><span class="n">is_chime</span><span class="p">(</span><span class="n">inp</span><span class="p">):</span>
                <span class="n">input_flags</span><span class="p">[</span><span class="n">idf</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Determine x and y pol index</span>
        <span class="n">xfeeds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">idf</span>
                <span class="k">for</span> <span class="n">idf</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inputmap</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">input_flags</span><span class="p">[</span><span class="n">idf</span><span class="p">]</span> <span class="ow">and</span> <span class="n">tools</span><span class="o">.</span><span class="n">is_array_x</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">yfeeds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">idf</span>
                <span class="k">for</span> <span class="n">idf</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inputmap</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">input_flags</span><span class="p">[</span><span class="n">idf</span><span class="p">]</span> <span class="ow">and</span> <span class="n">tools</span><span class="o">.</span><span class="n">is_array_y</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="n">pol</span> <span class="o">=</span> <span class="p">[</span><span class="n">yfeeds</span><span class="p">,</span> <span class="n">xfeeds</span><span class="p">]</span>
        <span class="n">npol</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pol</span><span class="p">)</span>

        <span class="n">phase_ref_by_pol</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">pol</span><span class="p">[</span><span class="n">pp</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_ref</span><span class="p">[</span><span class="n">pp</span><span class="p">])</span> <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npol</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># Create new product map for the output container that has `input_b` set to</span>
        <span class="c1"># the phase reference feed.  Necessary to apply the timing correction later.</span>
        <span class="n">prod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">prod</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">pp</span><span class="p">,</span> <span class="n">feeds</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pol</span><span class="p">):</span>
            <span class="n">prod</span><span class="p">[</span><span class="s2">&quot;input_b&quot;</span><span class="p">][</span><span class="n">feeds</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_ref</span><span class="p">[</span><span class="n">pp</span><span class="p">]</span>

        <span class="c1"># Compute distances</span>
        <span class="n">tools</span><span class="o">.</span><span class="n">change_chime_location</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">telescope_rotation</span><span class="p">)</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">get_feed_positions</span><span class="p">(</span><span class="n">inputmap</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">pp</span><span class="p">,</span> <span class="n">feeds</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pol</span><span class="p">):</span>
            <span class="n">dist</span><span class="p">[</span><span class="n">feeds</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-=</span> <span class="n">dist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_ref</span><span class="p">[</span><span class="n">pp</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># Check for feeds that do not have a valid distance (feedpos are set to nan)</span>
        <span class="n">no_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dist</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">no_distance</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">input_flags</span><span class="p">[</span><span class="n">no_distance</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Do not have positions for feeds: </span><span class="si">{</span><span class="n">no_distance</span><span class="p">[</span><span class="n">input_flags</span><span class="p">[</span><span class="n">no_distance</span><span class="p">]]</span><span class="si">!s}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Determine the number of eigenvalues to include in the orthogonalization</span>
        <span class="n">neigen</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">npol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">neigen</span><span class="p">),</span> <span class="n">neigen</span><span class="p">)</span>

        <span class="c1"># Calculate dynamic range</span>
        <span class="n">eval0_off_source</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">evalue</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">off_source</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">dyn</span> <span class="o">=</span> <span class="n">evalue</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">eval0_off_source</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>

        <span class="c1"># Determine frequencies and times to mask</span>
        <span class="n">not_rfi</span> <span class="o">=</span> <span class="o">~</span><span class="n">rfi</span><span class="o">.</span><span class="n">frequency_mask</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
        <span class="n">not_rfi</span> <span class="o">=</span> <span class="n">not_rfi</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Using a dynamic range threshold of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dyn_rng_threshold</span><span class="si">:</span><span class="s2">0.2f</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>
        <span class="n">dyn_flag</span> <span class="o">=</span> <span class="n">dyn</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn_rng_threshold</span>

        <span class="n">converged</span> <span class="o">=</span> <span class="n">erms</span> <span class="o">&gt;</span> <span class="mf">0.0</span>

        <span class="n">flag</span> <span class="o">=</span> <span class="n">converged</span> <span class="o">&amp;</span> <span class="n">dyn_flag</span> <span class="o">&amp;</span> <span class="n">not_rfi</span>

        <span class="c1"># Calculate base error</span>
        <span class="n">base_err</span> <span class="o">=</span> <span class="n">erms</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># Check for sign flips</span>
        <span class="n">ref_resp</span> <span class="o">=</span> <span class="n">evec</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">neigen</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigen_ref</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">sign0</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">ref_resp</span><span class="o">.</span><span class="n">real</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">)</span>

        <span class="c1"># Check that we have the correct reference feed</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ref_resp</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">):</span>
            <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Reference feed </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">eigen_ref</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> is incorrect.&quot;</span><span class="p">)</span>

        <span class="c1"># Create output container</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealStream</span><span class="p">(</span>
            <span class="n">ra</span><span class="o">=</span><span class="n">ra</span><span class="p">,</span>
            <span class="n">prod</span><span class="o">=</span><span class="n">prod</span><span class="p">,</span>
            <span class="n">stack</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">attrs_from</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">axes_from</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">distributed</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">distributed</span><span class="p">,</span>
            <span class="n">comm</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">response</span><span class="o">.</span><span class="n">input_flags</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">input_flags</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="c1"># Create attributes identifying the transit</span>
        <span class="n">response</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;source_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">source_name</span>
        <span class="n">response</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;transit_time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ttrans</span>
        <span class="n">response</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;lsd&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">csd</span>
        <span class="n">response</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">source_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="si">}</span><span class="s2">_lsd_</span><span class="si">{</span><span class="n">csd</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="c1"># Add an attribute that indicates if the transit occured during the daytime</span>
        <span class="n">is_daytime</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">solar_rise</span> <span class="o">=</span> <span class="n">chime</span><span class="o">.</span><span class="n">solar_rising</span><span class="p">(</span><span class="n">ttrans</span> <span class="o">-</span> <span class="mf">86400.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sr</span> <span class="ow">in</span> <span class="n">solar_rise</span><span class="p">:</span>
            <span class="n">ss</span> <span class="o">=</span> <span class="n">chime</span><span class="o">.</span><span class="n">solar_setting</span><span class="p">(</span><span class="n">sr</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ttrans</span> <span class="o">&gt;=</span> <span class="n">sr</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ttrans</span> <span class="o">&lt;=</span> <span class="n">ss</span><span class="p">):</span>
                <span class="n">is_daytime</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">break</span>
        <span class="n">response</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;daytime_transit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">is_daytime</span>

        <span class="c1"># Dereference the output datasets</span>
        <span class="n">out_vis</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span>
        <span class="n">out_weight</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span>

        <span class="c1"># Loop over polarizations</span>
        <span class="k">for</span> <span class="n">pp</span><span class="p">,</span> <span class="n">feeds</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pol</span><span class="p">):</span>
            <span class="c1"># Create the polarization masking vector</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">ninput</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">P</span><span class="p">[:,</span> <span class="n">feeds</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span>

            <span class="c1"># Loop over frequencies</span>
            <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nfreq</span><span class="p">):</span>
                <span class="n">ww</span> <span class="o">=</span> <span class="n">weight</span><span class="p">[</span><span class="n">ff</span><span class="p">,</span> <span class="n">feeds</span><span class="p">,</span> <span class="p">:]</span>

                <span class="c1"># Normalize by eigenvalue and correct for pi phase flips in process.</span>
                <span class="n">resp</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">sign0</span><span class="p">[</span><span class="n">ff</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="o">*</span> <span class="n">evec</span><span class="p">[</span><span class="n">ff</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">neigen</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
                    <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">evalue</span><span class="p">[</span><span class="n">ff</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">neigen</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:])</span>
                <span class="p">)</span>

                <span class="c1"># Rotate to single-pol response</span>
                <span class="c1"># Move time to first axis for the matrix multiplication</span>
                <span class="n">invL</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">evalue</span><span class="p">[</span><span class="n">ff</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">neigen</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">UT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">resp</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">UT</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>

                <span class="n">mu</span><span class="p">,</span> <span class="n">vp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">UT</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">P</span> <span class="o">*</span> <span class="n">U</span><span class="p">))</span>

                <span class="n">rsign0</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">vp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">real</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">)</span>

                <span class="n">resp</span> <span class="o">=</span> <span class="n">mu</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">rsign0</span> <span class="o">*</span> <span class="n">vp</span> <span class="o">*</span> <span class="n">invL</span><span class="p">)</span>

                <span class="c1"># Extract feeds of this pol</span>
                <span class="c1"># Transpose so that time is back to last axis</span>
                <span class="n">resp</span> <span class="o">=</span> <span class="n">resp</span><span class="p">[:,</span> <span class="n">feeds</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>

                <span class="c1"># Compute error on response</span>
                <span class="n">dataflg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">flag</span><span class="p">[</span><span class="n">ff</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">resp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>
                    <span class="o">&amp;</span> <span class="p">(</span><span class="n">ww</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>
                    <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">ww</span><span class="p">)</span>
                <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

                <span class="n">resp_err</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">dataflg</span>
                    <span class="o">*</span> <span class="n">base_err</span><span class="p">[</span><span class="n">ff</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
                    <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">vis</span><span class="p">[</span><span class="n">ff</span><span class="p">,</span> <span class="n">feeds</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
                    <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mu</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
                <span class="p">)</span>

                <span class="c1"># Reference to specific input</span>
                <span class="n">resp</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
                    <span class="o">-</span><span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">resp</span><span class="p">[</span><span class="n">phase_ref_by_pol</span><span class="p">[</span><span class="n">pp</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:])</span>
                <span class="p">)</span>

                <span class="c1"># Fringestop</span>
                <span class="n">lmbda</span> <span class="o">=</span> <span class="n">speed_of_light</span> <span class="o">*</span> <span class="mf">1e-6</span> <span class="o">/</span> <span class="n">freq</span><span class="p">[</span><span class="n">ff</span><span class="p">]</span>

                <span class="n">resp</span> <span class="o">*=</span> <span class="n">tools</span><span class="o">.</span><span class="n">fringestop_phase</span><span class="p">(</span>
                    <span class="n">ha</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span>
                    <span class="n">lat</span><span class="p">,</span>
                    <span class="n">src_dec</span><span class="p">,</span>
                    <span class="n">dist</span><span class="p">[</span><span class="n">feeds</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">/</span> <span class="n">lmbda</span><span class="p">,</span>
                    <span class="n">dist</span><span class="p">[</span><span class="n">feeds</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">/</span> <span class="n">lmbda</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># Normalize by source flux</span>
                <span class="n">resp</span> <span class="o">*=</span> <span class="n">inv_rt_flux_density</span><span class="p">[</span><span class="n">ff</span><span class="p">]</span>
                <span class="n">resp_err</span> <span class="o">*=</span> <span class="n">inv_rt_flux_density</span><span class="p">[</span><span class="n">ff</span><span class="p">]</span>

                <span class="c1"># If requested, reference phase to the median value</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">med_phase_ref</span><span class="p">:</span>
                    <span class="n">phi0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">resp</span><span class="p">[:,</span> <span class="n">itrans</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
                    <span class="n">resp</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">phi0</span><span class="p">)</span>
                    <span class="n">resp</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
                        <span class="o">-</span><span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">resp</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">resp</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">phi0</span><span class="p">)</span>

                <span class="n">out_vis</span><span class="p">[</span><span class="n">ff</span><span class="p">,</span> <span class="n">feeds</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">resp</span>
                <span class="n">out_weight</span><span class="p">[</span><span class="n">ff</span><span class="p">,</span> <span class="n">feeds</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">resp_err</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">response</span></div>
</div>



<div class="viewcode-block" id="TransitFit">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.TransitFit">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">TransitFit</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fit model to the transit of a point source.</span>

<span class="sd">    Multiple model choices are available and can be specified through the `model`</span>
<span class="sd">    config property.  Default is `gauss_amp_poly_phase`, a nonlinear fit</span>
<span class="sd">    of a gaussian in amplitude and a polynomial in phase to the complex data.</span>
<span class="sd">    There is also `poly_log_amp_poly_phase`, an iterative weighted least squares</span>
<span class="sd">    fit of a polynomial to log amplitude and phase.  The type of polynomial can be</span>
<span class="sd">    chosen through the `poly_type`, `poly_deg_amp`, and `poly_deg_phi` config properties.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    model : str</span>
<span class="sd">        Name of the model to fit.  One of &#39;gauss_amp_poly_phase&#39; or</span>
<span class="sd">        &#39;poly_log_amp_poly_phase&#39;.</span>
<span class="sd">    nsigma : float</span>
<span class="sd">        Number of standard deviations away from transit to fit.</span>
<span class="sd">    absolute_sigma : bool</span>
<span class="sd">        Set to True if the errors provided are absolute.  Set to False if</span>
<span class="sd">        the errors provided are relative, in which case the parameter covariance</span>
<span class="sd">        will be scaled by the chi-squared per degree-of-freedom.</span>
<span class="sd">    poly_type : str</span>
<span class="sd">        Type of polynomial.  Either &#39;standard&#39;, &#39;hermite&#39;, or &#39;chebychev&#39;.</span>
<span class="sd">        Relevant if `poly = True`.</span>
<span class="sd">    poly_deg_amp : int</span>
<span class="sd">        Degree of the polynomial to fit to amplitude.</span>
<span class="sd">        Relevant if `poly = True`.</span>
<span class="sd">    poly_deg_phi : int</span>
<span class="sd">        Degree of the polynomial to fit to phase.</span>
<span class="sd">        Relevant if `poly = True`.</span>
<span class="sd">    niter : int</span>
<span class="sd">        Number of times to update the errors using model amplitude.</span>
<span class="sd">        Relevant if `poly = True`.</span>
<span class="sd">    moving_window : int</span>
<span class="sd">        Number of standard deviations away from peak to fit.</span>
<span class="sd">        The peak location is updated with each iteration.</span>
<span class="sd">        Must be less than `nsigma`.  Relevant if `poly = True`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">model</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">enum</span><span class="p">(</span>
        <span class="p">[</span><span class="s2">&quot;gauss_amp_poly_phase&quot;</span><span class="p">,</span> <span class="s2">&quot;poly_log_amp_poly_phase&quot;</span><span class="p">],</span>
        <span class="n">default</span><span class="o">=</span><span class="s2">&quot;gauss_amp_poly_phase&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">nsigma</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span>
        <span class="n">proptype</span><span class="o">=</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.60</span>
    <span class="p">)</span>
    <span class="n">absolute_sigma</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">poly_type</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;standard&quot;</span><span class="p">)</span>
    <span class="n">poly_deg_amp</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">poly_deg_phi</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">niter</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">moving_window</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span>
        <span class="n">proptype</span><span class="o">=</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.30</span>
    <span class="p">)</span>

<div class="viewcode-block" id="TransitFit.setup">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.TransitFit.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Define model to fit to transit.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;absolute_sigma&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">absolute_sigma</span><span class="p">}</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">==</span> <span class="s2">&quot;gauss_amp_poly_phase&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ModelClass</span> <span class="o">=</span> <span class="n">cal_utils</span><span class="o">.</span><span class="n">FitGaussAmpPolyPhase</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model_kwargs</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;poly_type&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_type</span><span class="p">,</span>
                <span class="s2">&quot;poly_deg_phi&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_deg_phi</span><span class="p">,</span>
            <span class="p">}</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">==</span> <span class="s2">&quot;poly_log_amp_poly_phase&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ModelClass</span> <span class="o">=</span> <span class="n">cal_utils</span><span class="o">.</span><span class="n">FitPolyLogAmpPolyPhase</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model_kwargs</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;poly_type&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_type</span><span class="p">,</span>
                <span class="s2">&quot;poly_deg_amp&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_deg_amp</span><span class="p">,</span>
                <span class="s2">&quot;poly_deg_phi&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly_deg_phi</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="p">{</span><span class="s2">&quot;niter&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">niter</span><span class="p">,</span> <span class="s2">&quot;moving_window&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">moving_window</span><span class="p">}</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Do not recognize model </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="si">}</span><span class="s2">.  Options are &quot;</span>
                <span class="s2">&quot;`gauss_amp_poly_phase` and `poly_log_amp_poly_phase`.&quot;</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="TransitFit.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.TransitFit.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="n">inputmap</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fit model to the point source response for each feed and frequency.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        response : containers.SiderealStream</span>
<span class="sd">            SiderealStream covering the source transit.  Must contain</span>
<span class="sd">            `source_name` and `transit_time` attributes.</span>
<span class="sd">        inputmap : list of CorrInput&#39;s</span>
<span class="sd">            List describing the inputs as ordered in response.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fit : ccontainers.TransitFitParams</span>
<span class="sd">            Parameters of the model fit and their covariance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure that we are distributed over frequency</span>
        <span class="n">response</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Determine local dimensions</span>
        <span class="n">nfreq</span><span class="p">,</span> <span class="n">ninput</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">local_shape</span>

        <span class="c1"># Find the local frequencies</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="n">response</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_bounds</span><span class="p">]</span>

        <span class="c1"># Calculate the hour angle using the source and transit time saved to attributes</span>
        <span class="n">source_obj</span> <span class="o">=</span> <span class="n">sources</span><span class="o">.</span><span class="n">source_dictionary</span><span class="p">[</span><span class="n">response</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;source_name&quot;</span><span class="p">]]</span>
        <span class="n">ttrans</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;transit_time&quot;</span><span class="p">]</span>

        <span class="n">src_ra</span><span class="p">,</span> <span class="n">src_dec</span> <span class="o">=</span> <span class="n">chime</span><span class="o">.</span><span class="n">object_coords</span><span class="p">(</span><span class="n">source_obj</span><span class="p">,</span> <span class="n">date</span><span class="o">=</span><span class="n">ttrans</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">ha</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">ra</span><span class="p">[:]</span> <span class="o">-</span> <span class="n">src_ra</span>
        <span class="n">ha</span> <span class="o">=</span> <span class="p">((</span><span class="n">ha</span> <span class="o">+</span> <span class="mf">180.0</span><span class="p">)</span> <span class="o">%</span> <span class="mf">360.0</span><span class="p">)</span> <span class="o">-</span> <span class="mf">180.0</span>

        <span class="c1"># Determine the fit window</span>
        <span class="n">input_flags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">input_flags</span><span class="p">[:],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">xfeeds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">idf</span>
                <span class="k">for</span> <span class="n">idf</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inputmap</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">input_flags</span><span class="p">[</span><span class="n">idf</span><span class="p">]</span> <span class="ow">and</span> <span class="n">tools</span><span class="o">.</span><span class="n">is_array_x</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">yfeeds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">idf</span>
                <span class="k">for</span> <span class="n">idf</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inputmap</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">input_flags</span><span class="p">[</span><span class="n">idf</span><span class="p">]</span> <span class="ow">and</span> <span class="n">tools</span><span class="o">.</span><span class="n">is_array_y</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="n">pol</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">xfeeds</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">yfeeds</span><span class="p">}</span>

        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">ninput</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">pstr</span><span class="p">,</span> <span class="n">feed</span> <span class="ow">in</span> <span class="n">pol</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">sigma</span><span class="p">[:,</span> <span class="n">feed</span><span class="p">]</span> <span class="o">=</span> <span class="n">cal_utils</span><span class="o">.</span><span class="n">guess_fwhm</span><span class="p">(</span>
                <span class="n">freq</span><span class="p">,</span> <span class="n">pol</span><span class="o">=</span><span class="n">pstr</span><span class="p">,</span> <span class="n">dec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">src_dec</span><span class="p">),</span> <span class="n">sigma</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">voltage</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="c1"># Dereference datasets</span>
        <span class="n">vis</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">weight</span><span class="p">))</span>

        <span class="c1"># Flag data that is outside the fit window set by nsigma config parameter</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">err</span> <span class="o">*=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ha</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:])</span>
                <span class="o">&lt;=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsigma</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
            <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">err</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Instantiate the model fitter</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ModelClass</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">model_kwargs</span><span class="p">)</span>

        <span class="c1"># Fit the model</span>
        <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">vis</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_kwargs</span><span class="p">)</span>

        <span class="c1"># Create an output container</span>
        <span class="n">fit</span> <span class="o">=</span> <span class="n">ccontainers</span><span class="o">.</span><span class="n">TransitFitParams</span><span class="p">(</span>
            <span class="n">param</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">parameter_names</span><span class="p">,</span>
            <span class="n">component</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">component</span><span class="p">,</span>
            <span class="n">axes_from</span><span class="o">=</span><span class="n">response</span><span class="p">,</span>
            <span class="n">attrs_from</span><span class="o">=</span><span class="n">response</span><span class="p">,</span>
            <span class="n">distributed</span><span class="o">=</span><span class="n">response</span><span class="o">.</span><span class="n">distributed</span><span class="p">,</span>
            <span class="n">comm</span><span class="o">=</span><span class="n">response</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">fit</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;chisq&quot;</span><span class="p">)</span>
        <span class="n">fit</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;ndof&quot;</span><span class="p">)</span>

        <span class="c1"># Transfer fit information to container attributes</span>
        <span class="n">fit</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;model_kwargs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">model_kwargs</span><span class="p">)</span>
        <span class="n">fit</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;model_class&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ModelClass</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;__module__&quot;</span><span class="p">,</span> <span class="s2">&quot;__name__&quot;</span><span class="p">]]</span>
        <span class="p">)</span>

        <span class="c1"># Save datasets</span>
        <span class="n">fit</span><span class="o">.</span><span class="n">parameter</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">param</span><span class="p">[:]</span>
        <span class="n">fit</span><span class="o">.</span><span class="n">parameter_cov</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">param_cov</span><span class="p">[:]</span>
        <span class="n">fit</span><span class="o">.</span><span class="n">chisq</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">chisq</span><span class="p">[:]</span>
        <span class="n">fit</span><span class="o">.</span><span class="n">ndof</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">ndof</span><span class="p">[:]</span>

        <span class="k">return</span> <span class="n">fit</span></div>
</div>



<div class="viewcode-block" id="GainFromTransitFit">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.GainFromTransitFit">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">GainFromTransitFit</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Determine gain by evaluating the best-fit model for the point source transit.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    evaluate : str</span>
<span class="sd">        Evaluate the model at this location, either &#39;transit&#39; or &#39;peak&#39;.</span>
<span class="sd">    chisq_per_dof_threshold : float</span>
<span class="sd">        Set gain and weight to zero if the chisq per degree of freedom</span>
<span class="sd">        of the fit is less than this threshold.</span>
<span class="sd">    alpha : float</span>
<span class="sd">        Use confidence level 1 - alpha for the uncertainty on the gain.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">evaluate</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">enum</span><span class="p">([</span><span class="s2">&quot;transit&quot;</span><span class="p">,</span> <span class="s2">&quot;peak&quot;</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;transit&quot;</span><span class="p">)</span>
    <span class="n">chisq_per_dof_threshold</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">20.0</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.32</span><span class="p">)</span>

<div class="viewcode-block" id="GainFromTransitFit.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.GainFromTransitFit.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fit</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine gain from best-fit model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fit : ccontainers.TransitFitParams</span>
<span class="sd">            Parameters of the model fit and their covariance.</span>
<span class="sd">            Must also contain &#39;model_class&#39; and &#39;model_kwargs&#39;</span>
<span class="sd">            attributes that can be used to evaluate the model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gain : containers.StaticGainData</span>
<span class="sd">            Gain and uncertainty on the gain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">pydoc</span><span class="w"> </span><span class="kn">import</span> <span class="n">locate</span>

        <span class="c1"># Distribute over frequency</span>
        <span class="n">fit</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Import the function for evaluating the model and keyword arguments</span>
        <span class="n">ModelClass</span> <span class="o">=</span> <span class="n">locate</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;model_class&quot;</span><span class="p">])</span>
        <span class="n">model_kwargs</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;model_kwargs&quot;</span><span class="p">])</span>

        <span class="c1"># Create output container</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">StaticGainData</span><span class="p">(</span>
            <span class="n">axes_from</span><span class="o">=</span><span class="n">fit</span><span class="p">,</span> <span class="n">attrs_from</span><span class="o">=</span><span class="n">fit</span><span class="p">,</span> <span class="n">distributed</span><span class="o">=</span><span class="n">fit</span><span class="o">.</span><span class="n">distributed</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">fit</span><span class="o">.</span><span class="n">comm</span>
        <span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;weight&quot;</span><span class="p">)</span>

        <span class="c1"># Dereference datasets</span>
        <span class="n">param</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">parameter</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">param_cov</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">parameter_cov</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">chisq</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">chisq</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">ndof</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">ndof</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

        <span class="n">chisq_per_dof</span> <span class="o">=</span> <span class="n">chisq</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">ndof</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>

        <span class="n">gain</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">gain</span><span class="p">[:]</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span>

        <span class="c1"># Instantiate the model object</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">ModelClass</span><span class="p">(</span>
            <span class="n">param</span><span class="o">=</span><span class="n">param</span><span class="p">,</span> <span class="n">param_cov</span><span class="o">=</span><span class="n">param_cov</span><span class="p">,</span> <span class="n">chisq</span><span class="o">=</span><span class="n">chisq</span><span class="p">,</span> <span class="n">ndof</span><span class="o">=</span><span class="n">ndof</span><span class="p">,</span> <span class="o">**</span><span class="n">model_kwargs</span>
        <span class="p">)</span>

        <span class="c1"># Suppress numpy floating errors</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
            <span class="c1"># Determine hour angle of evaluation</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span> <span class="o">==</span> <span class="s2">&quot;peak&quot;</span><span class="p">:</span>
                <span class="n">ha</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">peak</span><span class="p">()</span>
                <span class="n">elementwise</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ha</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">elementwise</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Predict model and uncertainty at desired hour angle</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">elementwise</span><span class="o">=</span><span class="n">elementwise</span><span class="p">)</span>

            <span class="n">gerr</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">uncertainty</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="n">elementwise</span><span class="o">=</span><span class="n">elementwise</span><span class="p">)</span>

            <span class="c1"># Use convention that you multiply by gain to calibrate</span>
            <span class="n">gain</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
            <span class="n">weight</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">gerr</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">**</span> <span class="mi">4</span>

            <span class="c1"># Can occassionally get Infs when evaluating fits to anomalous data.</span>
            <span class="c1"># Replace with zeros. Also zero data where the chi-squared per</span>
            <span class="c1"># degree of freedom is greater than threshold.</span>
            <span class="n">not_valid</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">gain</span><span class="p">)</span>
                <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
                <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">chisq_per_dof</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chisq_per_dof_threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">not_valid</span><span class="p">):</span>
                <span class="n">gain</span><span class="p">[</span><span class="n">not_valid</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="o">+</span> <span class="mf">0.0</span><span class="n">j</span>
                <span class="n">weight</span><span class="p">[</span><span class="n">not_valid</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">return</span> <span class="n">out</span></div>
</div>



<div class="viewcode-block" id="FlagAmplitude">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.FlagAmplitude">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FlagAmplitude</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Flag feeds and frequencies with outlier gain amplitude.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    min_amp_scale_factor : float</span>
<span class="sd">        Flag feeds and frequencies where the amplitude of the gain</span>
<span class="sd">        is less than `min_amp_scale_factor` times the median amplitude</span>
<span class="sd">        over all feeds and frequencies.</span>
<span class="sd">    max_amp_scale_factor : float</span>
<span class="sd">        Flag feeds and frequencies where the amplitude of the gain</span>
<span class="sd">        is greater than `max_amp_scale_factor` times the median amplitude</span>
<span class="sd">        over all feeds and frequencies.</span>
<span class="sd">    nsigma_outlier : float</span>
<span class="sd">        Flag a feed at a particular frequency if the gain amplitude</span>
<span class="sd">        is greater than `nsigma_outlier` from the median value over</span>
<span class="sd">        all feeds of the same polarisation at that frequency.</span>
<span class="sd">    nsigma_med_outlier : float</span>
<span class="sd">        Flag a frequency if the median gain amplitude over all feeds of a</span>
<span class="sd">        given polarisation is `nsigma_med_outlier` away from the local median.</span>
<span class="sd">    window_med_outlier : int</span>
<span class="sd">        Number of frequency bins to use to determine the local median for</span>
<span class="sd">        the test outlined in the description of `nsigma_med_outlier`.</span>
<span class="sd">    threshold_good_freq: float</span>
<span class="sd">        If a frequency has less than this fraction of good inputs, then</span>
<span class="sd">        it is considered bad and the data for all inputs is flagged.</span>
<span class="sd">    threshold_good_input : float</span>
<span class="sd">        If an input has less than this fraction of good frequencies, then</span>
<span class="sd">        it is considered bad and the data for all frequencies is flagged.</span>
<span class="sd">        Note that the fraction is relative to the number of frequencies</span>
<span class="sd">        that pass the test described in `threshold_good_freq`.</span>
<span class="sd">    valid_gains_frac_good_freq : float</span>
<span class="sd">        If the fraction of frequencies that remain after flagging is less than</span>
<span class="sd">        this value, then the task will return None and the processing of the</span>
<span class="sd">        sidereal day will not proceed further.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">min_amp_scale_factor</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
    <span class="n">max_amp_scale_factor</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">20.0</span><span class="p">)</span>
    <span class="n">nsigma_outlier</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">10.0</span><span class="p">)</span>
    <span class="n">nsigma_med_outlier</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">10.0</span><span class="p">)</span>
    <span class="n">window_med_outlier</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">24</span><span class="p">)</span>
    <span class="n">threshold_good_freq</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.70</span><span class="p">)</span>
    <span class="n">threshold_good_input</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.80</span><span class="p">)</span>
    <span class="n">valid_gains_frac_good_freq</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>

<div class="viewcode-block" id="FlagAmplitude.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.FlagAmplitude.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gain</span><span class="p">,</span> <span class="n">inputmap</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set weight to zero for feeds and frequencies with outlier gain amplitude.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gain : containers.StaticGainData</span>
<span class="sd">            Gain derived from point source transit.</span>
<span class="sd">        inputmap : list of CorrInput&#39;s</span>
<span class="sd">            List describing the inputs as ordered in gain.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gain : containers.StaticGainData</span>
<span class="sd">            The input gain container with modified weights.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Distribute over frequency</span>
        <span class="n">gain</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="n">nfreq</span><span class="p">,</span> <span class="n">ninput</span> <span class="o">=</span> <span class="n">gain</span><span class="o">.</span><span class="n">gain</span><span class="o">.</span><span class="n">local_shape</span>

        <span class="n">sfreq</span> <span class="o">=</span> <span class="n">gain</span><span class="o">.</span><span class="n">gain</span><span class="o">.</span><span class="n">local_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">efreq</span> <span class="o">=</span> <span class="n">sfreq</span> <span class="o">+</span> <span class="n">nfreq</span>

        <span class="c1"># Dereference datasets</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="n">gain</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span> <span class="o">&gt;</span> <span class="mf">0.0</span>
        <span class="n">amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">gain</span><span class="o">.</span><span class="n">gain</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">)</span>

        <span class="c1"># Determine x and y pol index</span>
        <span class="n">xfeeds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">idf</span> <span class="k">for</span> <span class="n">idf</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inputmap</span><span class="p">)</span> <span class="k">if</span> <span class="n">tools</span><span class="o">.</span><span class="n">is_array_x</span><span class="p">(</span><span class="n">inp</span><span class="p">)]</span>
        <span class="p">)</span>
        <span class="n">yfeeds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">idf</span> <span class="k">for</span> <span class="n">idf</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inputmap</span><span class="p">)</span> <span class="k">if</span> <span class="n">tools</span><span class="o">.</span><span class="n">is_array_y</span><span class="p">(</span><span class="n">inp</span><span class="p">)]</span>
        <span class="p">)</span>
        <span class="n">pol</span> <span class="o">=</span> <span class="p">[</span><span class="n">yfeeds</span><span class="p">,</span> <span class="n">xfeeds</span><span class="p">]</span>
        <span class="n">polstr</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">]</span>

        <span class="c1"># Hard cutoffs on the amplitude</span>
        <span class="n">med_amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">amp</span><span class="p">[</span><span class="n">flag</span><span class="p">])</span>
        <span class="n">min_amp</span> <span class="o">=</span> <span class="n">med_amp</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_amp_scale_factor</span>
        <span class="n">max_amp</span> <span class="o">=</span> <span class="n">med_amp</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_amp_scale_factor</span>

        <span class="n">flag</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">amp</span> <span class="o">&gt;=</span> <span class="n">min_amp</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">amp</span> <span class="o">&lt;=</span> <span class="n">max_amp</span><span class="p">)</span>

        <span class="c1"># Flag outliers in amplitude for each frequency</span>
        <span class="k">for</span> <span class="n">pp</span><span class="p">,</span> <span class="n">feeds</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pol</span><span class="p">):</span>
            <span class="n">med_amp_by_pol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">sig_amp_by_pol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nfreq</span><span class="p">):</span>
                <span class="n">this_flag</span> <span class="o">=</span> <span class="n">flag</span><span class="p">[</span><span class="n">ff</span><span class="p">,</span> <span class="n">feeds</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">this_flag</span><span class="p">):</span>
                    <span class="n">med</span><span class="p">,</span> <span class="n">slow</span><span class="p">,</span> <span class="n">shigh</span> <span class="o">=</span> <span class="n">cal_utils</span><span class="o">.</span><span class="n">estimate_directional_scale</span><span class="p">(</span>
                        <span class="n">amp</span><span class="p">[</span><span class="n">ff</span><span class="p">,</span> <span class="n">feeds</span><span class="p">[</span><span class="n">this_flag</span><span class="p">]]</span>
                    <span class="p">)</span>
                    <span class="n">lower</span> <span class="o">=</span> <span class="n">med</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsigma_outlier</span> <span class="o">*</span> <span class="n">slow</span>
                    <span class="n">upper</span> <span class="o">=</span> <span class="n">med</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsigma_outlier</span> <span class="o">*</span> <span class="n">shigh</span>

                    <span class="n">flag</span><span class="p">[</span><span class="n">ff</span><span class="p">,</span> <span class="n">feeds</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">amp</span><span class="p">[</span><span class="n">ff</span><span class="p">,</span> <span class="n">feeds</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">lower</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span>
                        <span class="n">amp</span><span class="p">[</span><span class="n">ff</span><span class="p">,</span> <span class="n">feeds</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">upper</span>
                    <span class="p">)</span>

                    <span class="n">med_amp_by_pol</span><span class="p">[</span><span class="n">ff</span><span class="p">]</span> <span class="o">=</span> <span class="n">med</span>
                    <span class="n">sig_amp_by_pol</span><span class="p">[</span><span class="n">ff</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="mf">0.5</span>
                        <span class="o">*</span> <span class="p">(</span><span class="n">shigh</span> <span class="o">-</span> <span class="n">slow</span><span class="p">)</span>
                        <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">this_flag</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
                    <span class="p">)</span>

            <span class="c1"># Flag frequencies that are outliers with respect to local median</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsigma_med_outlier</span><span class="p">:</span>
                <span class="c1"># Collect med_amp_by_pol for all frequencies on rank 0</span>
                <span class="k">if</span> <span class="n">gain</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">full_med_amp_by_pol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">gain</span><span class="o">.</span><span class="n">freq</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">full_med_amp_by_pol</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="n">mpiutil</span><span class="o">.</span><span class="n">gather_local</span><span class="p">(</span>
                    <span class="n">full_med_amp_by_pol</span><span class="p">,</span>
                    <span class="n">med_amp_by_pol</span><span class="p">,</span>
                    <span class="p">(</span><span class="n">sfreq</span><span class="p">,),</span>
                    <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">comm</span><span class="o">=</span><span class="n">gain</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># Flag outlier frequencies on rank 0</span>
                <span class="n">not_outlier</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">gain</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">med_flag</span> <span class="o">=</span> <span class="n">full_med_amp_by_pol</span> <span class="o">&gt;</span> <span class="mf">0.0</span>

                    <span class="n">not_outlier</span> <span class="o">=</span> <span class="n">cal_utils</span><span class="o">.</span><span class="n">flag_outliers</span><span class="p">(</span>
                        <span class="n">full_med_amp_by_pol</span><span class="p">,</span>
                        <span class="n">med_flag</span><span class="p">,</span>
                        <span class="n">window</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">window_med_outlier</span><span class="p">,</span>
                        <span class="n">nsigma</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nsigma_med_outlier</span><span class="p">,</span>
                    <span class="p">)</span>

                    <span class="n">noutlier</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">not_outlier</span> <span class="o">&amp;</span> <span class="n">med_flag</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Pol </span><span class="si">{</span><span class="n">polstr</span><span class="p">[</span><span class="n">pp</span><span class="p">]</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">noutlier</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> frequencies are outliers.&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># Broadcast outlier frequencies to other ranks</span>
                <span class="n">not_outlier</span> <span class="o">=</span> <span class="n">gain</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">not_outlier</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">gain</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>

                <span class="n">flag</span><span class="p">[:,</span> <span class="n">feeds</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">not_outlier</span><span class="p">[</span><span class="n">sfreq</span><span class="p">:</span><span class="n">efreq</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="c1"># Determine bad frequencies</span>
        <span class="n">flag_freq</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">ninput</span><span class="p">)</span>
        <span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold_good_freq</span>

        <span class="n">good_freq</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sfreq</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">flag_freq</span><span class="p">))</span>
        <span class="n">good_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mpiutil</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="n">good_freq</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">SUM</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">gain</span><span class="o">.</span><span class="n">comm</span><span class="p">))</span>

        <span class="n">flag</span> <span class="o">&amp;=</span> <span class="n">flag_freq</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">good_freq</span><span class="o">.</span><span class="n">size</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> good frequencies after flagging amplitude.&quot;</span><span class="p">)</span>

        <span class="c1"># If fraction of good frequencies is less than threshold, stop and return None</span>
        <span class="n">frac_good_freq</span> <span class="o">=</span> <span class="n">good_freq</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">gain</span><span class="o">.</span><span class="n">freq</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">frac_good_freq</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">valid_gains_frac_good_freq</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Only </span><span class="si">{</span><span class="mf">100.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">frac_good_freq</span><span class="si">:</span><span class="s2">0.1f</span><span class="si">}</span><span class="s2">% of frequencies remain after flagging amplitude.  Will &quot;</span>
                <span class="s2">&quot;not process this sidereal day further.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Determine bad inputs</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">gain</span><span class="o">.</span><span class="n">comm</span><span class="p">)</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="n">flag</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">fraction_good</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="n">flag</span><span class="p">[</span><span class="n">good_freq</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">good_freq</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="n">flag_input</span> <span class="o">=</span> <span class="n">fraction_good</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold_good_input</span>

        <span class="n">good_input</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">flag</span><span class="o">.</span><span class="n">local_offset</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">flag_input</span><span class="p">))</span>
        <span class="n">good_input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mpiutil</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="n">good_input</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">SUM</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">gain</span><span class="o">.</span><span class="n">comm</span><span class="p">))</span>

        <span class="n">flag</span><span class="p">[:]</span> <span class="o">&amp;=</span> <span class="n">flag_input</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">good_input</span><span class="o">.</span><span class="n">size</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> good inputs after flagging amplitude.&quot;</span><span class="p">)</span>

        <span class="c1"># Redistribute flags back over frequencies and update container</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="n">flag</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">gain</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">flag</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">gain</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">gain</span></div>
</div>



<div class="viewcode-block" id="InterpolateGainOverFrequency">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.InterpolateGainOverFrequency">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">InterpolateGainOverFrequency</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Replace gain at flagged frequencies with interpolated values.</span>

<span class="sd">    Uses a gaussian process regression to perform the interpolation</span>
<span class="sd">    with a Matern function describing the covariance between frequencies.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    interp_scale : float</span>
<span class="sd">        Correlation length of the gain with frequency in MHz.</span>
<span class="sd">    in_place: bool</span>
<span class="sd">        Save the interpolated gains to the input container.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">interp_scale</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">30.0</span><span class="p">)</span>
    <span class="n">in_place</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="InterpolateGainOverFrequency.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.InterpolateGainOverFrequency.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gain</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interpolate the gain over the frequency axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gain : containers.StaticGainData</span>
<span class="sd">            Complex gains at single time.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gain : containers.StaticGainData</span>
<span class="sd">            Complex gains with flagged frequencies (`weight = 0.0`)</span>
<span class="sd">            replaced with interpolated values and `weight` dataset</span>
<span class="sd">            updated to reflect the uncertainty on the interpolation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Redistribute over input</span>
        <span class="n">gain</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;input&quot;</span><span class="p">)</span>

        <span class="c1"># Deference datasets</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">gain</span><span class="o">.</span><span class="n">gain</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">gain</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

        <span class="c1"># Determine flagged frequencies</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="mf">0.0</span>

        <span class="c1"># Interpolate the gain at non-flagged frequencies to the flagged frequencies</span>
        <span class="n">ginterp</span><span class="p">,</span> <span class="n">winterp</span> <span class="o">=</span> <span class="n">cal_utils</span><span class="o">.</span><span class="n">interpolate_gain_quiet</span><span class="p">(</span>
            <span class="n">gain</span><span class="o">.</span><span class="n">freq</span><span class="p">[:],</span> <span class="n">g</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="n">flag</span><span class="p">,</span> <span class="n">length_scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">interp_scale</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_place</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">gain</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">StaticGainData</span><span class="p">(</span>
                <span class="n">axes_from</span><span class="o">=</span><span class="n">gain</span><span class="p">,</span>
                <span class="n">attrs_from</span><span class="o">=</span><span class="n">gain</span><span class="p">,</span>
                <span class="n">distributed</span><span class="o">=</span><span class="n">gain</span><span class="o">.</span><span class="n">distributed</span><span class="p">,</span>
                <span class="n">comm</span><span class="o">=</span><span class="n">gain</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;weight&quot;</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;input&quot;</span><span class="p">)</span>
            <span class="n">gain</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Replace the gain and weight datasets with the interpolated arrays</span>
        <span class="c1"># Note that the gain and weight for non-flagged frequencies have not changed</span>
        <span class="n">out</span><span class="o">.</span><span class="n">gain</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">ginterp</span>
        <span class="n">out</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">winterp</span>

        <span class="n">out</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>
</div>



<div class="viewcode-block" id="SiderealCalibration">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.SiderealCalibration">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SiderealCalibration</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Use point source as a calibrator for a sidereal stack.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    source : str</span>
<span class="sd">        Name of the point source to use as calibrator.</span>
<span class="sd">        Default CygA.</span>
<span class="sd">    model_fit : bool</span>
<span class="sd">        Fit a model to the point source transit.</span>
<span class="sd">        Default False.</span>
<span class="sd">    use_peak : bool</span>
<span class="sd">        Relevant if model_fit is True.  If set to True,</span>
<span class="sd">        estimate the gain as the response at the</span>
<span class="sd">        actual peak location. If set to False, estimate</span>
<span class="sd">        the gain as the response at the expected peak location.</span>
<span class="sd">        Default False.</span>
<span class="sd">    threshold : float</span>
<span class="sd">        Relevant if model_fit is True.  The model is only fit to</span>
<span class="sd">        time samples with dynamic range greater than threshold.</span>
<span class="sd">        Default is 3.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">source</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;CygA&quot;</span><span class="p">)</span>
    <span class="n">model_fit</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">use_peak</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">3.0</span><span class="p">)</span>

<div class="viewcode-block" id="SiderealCalibration.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.SiderealCalibration.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sstream</span><span class="p">,</span> <span class="n">inputmap</span><span class="p">,</span> <span class="n">inputmask</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine calibration from a sidereal stream.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sstream : containers.SiderealStream</span>
<span class="sd">            Rigidized sidereal timestream to calibrate.</span>
<span class="sd">        inputmap : list of :class:`CorrInput`</span>
<span class="sd">            List describing the inputs as they are in the file.</span>
<span class="sd">        inputmask : ccontainers.CorrInputMask</span>
<span class="sd">            Mask indicating which correlator inputs to use in the</span>
<span class="sd">            eigenvalue decomposition.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gains : containers.PointSourceTransit or containers.StaticGainData</span>
<span class="sd">            Response of each feed to the point source and best-fit model</span>
<span class="sd">            (model_fit is True), or gains at the expected peak location</span>
<span class="sd">            (model_fit is False).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure that we are distributed over frequency</span>
        <span class="n">sstream</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Get the local frequency axis</span>
        <span class="n">nfreq</span> <span class="o">=</span> <span class="n">sstream</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">local_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">sstream</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="s2">&quot;centre&quot;</span><span class="p">][</span><span class="n">sstream</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_bounds</span><span class="p">]</span>

        <span class="c1"># Fetch source</span>
        <span class="n">source</span> <span class="o">=</span> <span class="n">sources</span><span class="o">.</span><span class="n">source_dictionary</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">]</span>

        <span class="c1"># Estimate the RA at which the transiting source peaks</span>
        <span class="n">peak_ra</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">peak_ra</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Find closest array index</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sstream</span><span class="o">.</span><span class="n">ra</span> <span class="o">-</span> <span class="n">peak_ra</span><span class="p">))</span>

        <span class="c1"># Fetch the transit into this visibility array</span>
        <span class="c1"># Cut out a snippet of the timestream</span>
        <span class="n">slice_width_deg</span> <span class="o">=</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="n">cal_utils</span><span class="o">.</span><span class="n">guess_fwhm</span><span class="p">(</span>
            <span class="mf">400.0</span><span class="p">,</span> <span class="n">pol</span><span class="o">=</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="n">dec</span><span class="o">=</span><span class="n">source</span><span class="o">.</span><span class="n">_dec</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">slice_width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">slice_width_deg</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">sstream</span><span class="o">.</span><span class="n">ra</span><span class="p">))))</span>
        <span class="n">slice_centre</span> <span class="o">=</span> <span class="n">slice_width</span>
        <span class="n">st</span><span class="p">,</span> <span class="n">et</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">-</span> <span class="n">slice_width</span><span class="p">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">slice_width</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">vis_slice</span> <span class="o">=</span> <span class="n">sstream</span><span class="o">.</span><span class="n">vis</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">st</span><span class="p">:</span><span class="n">et</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ra_slice</span> <span class="o">=</span> <span class="n">sstream</span><span class="o">.</span><span class="n">ra</span><span class="p">[</span><span class="n">st</span><span class="p">:</span><span class="n">et</span><span class="p">]</span>

        <span class="n">nra</span> <span class="o">=</span> <span class="n">vis_slice</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Determine good inputs</span>
        <span class="n">nfeed</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputmap</span><span class="p">)</span>
        <span class="n">good_input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nfeed</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)[</span>
            <span class="n">inputmask</span><span class="o">.</span><span class="n">datasets</span><span class="p">[</span><span class="s2">&quot;input_mask&quot;</span><span class="p">][:]</span>
        <span class="p">]</span>

        <span class="c1"># Use input map to figure out which are the X and Y feeds</span>
        <span class="n">xfeeds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">idx</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inputmap</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="ow">in</span> <span class="n">good_input</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tools</span><span class="o">.</span><span class="n">is_chime_x</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">yfeeds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">idx</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inputmap</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="ow">in</span> <span class="n">good_input</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tools</span><span class="o">.</span><span class="n">is_chime_y</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Performing sidereal calibration with </span><span class="si">%d</span><span class="s2">/</span><span class="si">%d</span><span class="s2"> good feeds (</span><span class="si">%d</span><span class="s2"> xpol, </span><span class="si">%d</span><span class="s2"> ypol).&quot;</span><span class="p">,</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">good_input</span><span class="p">),</span>
            <span class="n">nfeed</span><span class="p">,</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">xfeeds</span><span class="p">),</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">yfeeds</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="c1"># Extract the diagonal (to be used for weighting)</span>
        <span class="c1"># prior to differencing on-source and off-source</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">_extract_diagonal</span><span class="p">(</span><span class="n">vis_slice</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>

        <span class="c1"># Subtract the average visibility at the start and end of the slice (off source)</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">slice_width</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">vis_slice</span> <span class="o">=</span> <span class="n">_adiff</span><span class="p">(</span><span class="n">vis_slice</span><span class="p">,</span> <span class="n">diff</span><span class="p">)</span>

        <span class="c1"># Fringestop the data</span>
        <span class="n">vis_slice</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">fringestop_pathfinder</span><span class="p">(</span>
            <span class="n">vis_slice</span><span class="p">,</span> <span class="n">ra_slice</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">inputmap</span><span class="p">,</span> <span class="n">source</span>
        <span class="p">)</span>

        <span class="c1"># Create arrays to hold point source response</span>
        <span class="n">resp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">nfeed</span><span class="p">,</span> <span class="n">nra</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
        <span class="n">resp_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">nfeed</span><span class="p">,</span> <span class="n">nra</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># Solve for the point source response of each set of polarisations</span>
        <span class="n">evalue_x</span><span class="p">,</span> <span class="n">resp</span><span class="p">[:,</span> <span class="n">xfeeds</span><span class="p">,</span> <span class="p">:],</span> <span class="n">resp_err</span><span class="p">[:,</span> <span class="n">xfeeds</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">solve_gain</span><span class="p">(</span>
            <span class="n">vis_slice</span><span class="p">,</span> <span class="n">feeds</span><span class="o">=</span><span class="n">xfeeds</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">[:,</span> <span class="n">xfeeds</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">evalue_y</span><span class="p">,</span> <span class="n">resp</span><span class="p">[:,</span> <span class="n">yfeeds</span><span class="p">,</span> <span class="p">:],</span> <span class="n">resp_err</span><span class="p">[:,</span> <span class="n">yfeeds</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">solve_gain</span><span class="p">(</span>
            <span class="n">vis_slice</span><span class="p">,</span> <span class="n">feeds</span><span class="o">=</span><span class="n">yfeeds</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">[:,</span> <span class="n">yfeeds</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Extract flux density of the source</span>
        <span class="n">rt_flux_density</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">fluxcat</span><span class="o">.</span><span class="n">FluxCatalog</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">]</span><span class="o">.</span><span class="n">predict_flux</span><span class="p">(</span><span class="n">freq</span><span class="p">))</span>

        <span class="c1"># Divide by the flux density of the point source</span>
        <span class="c1"># to convert the response and response_error into</span>
        <span class="c1"># units of &#39;sqrt(correlator units / Jy)&#39;</span>
        <span class="n">resp</span> <span class="o">/=</span> <span class="n">rt_flux_density</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">resp_err</span> <span class="o">/=</span> <span class="n">rt_flux_density</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="c1"># Define units</span>
        <span class="n">unit_in</span> <span class="o">=</span> <span class="n">sstream</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;units&quot;</span><span class="p">,</span> <span class="s2">&quot;rt-correlator-units&quot;</span><span class="p">)</span>
        <span class="n">unit_out</span> <span class="o">=</span> <span class="s2">&quot;rt-Jy&quot;</span>

        <span class="c1"># Construct the final gain array from the point source response at transit</span>
        <span class="n">gain</span> <span class="o">=</span> <span class="n">resp</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">slice_centre</span><span class="p">]</span>

        <span class="c1"># Construct the dynamic range estimate as the ratio of the first to second</span>
        <span class="c1"># largest eigenvalue at the time of transit</span>
        <span class="n">dr_x</span> <span class="o">=</span> <span class="n">evalue_x</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">evalue_x</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">dr_y</span> <span class="o">=</span> <span class="n">evalue_y</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">evalue_y</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span>

        <span class="c1"># If requested, fit a model to the point source transit</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_fit</span><span class="p">:</span>
            <span class="c1"># Only fit ra values above the specified dynamic range threshold</span>
            <span class="c1"># that are contiguous about the expected peak position.</span>
            <span class="n">fit_flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">nfeed</span><span class="p">,</span> <span class="n">nra</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">fit_flag</span><span class="p">[:,</span> <span class="n">xfeeds</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">_contiguous_flag</span><span class="p">(</span>
                <span class="n">dr_x</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">,</span> <span class="n">centre</span><span class="o">=</span><span class="n">slice_centre</span>
            <span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">fit_flag</span><span class="p">[:,</span> <span class="n">yfeeds</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">_contiguous_flag</span><span class="p">(</span>
                <span class="n">dr_y</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">,</span> <span class="n">centre</span><span class="o">=</span><span class="n">slice_centre</span>
            <span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

            <span class="c1"># Fit model for the complex response of each feed to the point source</span>
            <span class="n">param</span><span class="p">,</span> <span class="n">param_cov</span> <span class="o">=</span> <span class="n">cal_utils</span><span class="o">.</span><span class="n">fit_point_source_transit</span><span class="p">(</span>
                <span class="n">ra_slice</span><span class="p">,</span> <span class="n">resp</span><span class="p">,</span> <span class="n">resp_err</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="n">fit_flag</span>
            <span class="p">)</span>

            <span class="c1"># Overwrite the initial gain estimates for frequencies/feeds</span>
            <span class="c1"># where the model fit was successful</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_peak</span><span class="p">:</span>
                <span class="n">gain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">param</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]),</span>
                    <span class="n">gain</span><span class="p">,</span>
                    <span class="n">param</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">param</span><span class="p">[:,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">2</span><span class="p">])),</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">nfeed</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">param</span><span class="p">[</span><span class="n">index</span><span class="p">])):</span>
                        <span class="n">gain</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">cal_utils</span><span class="o">.</span><span class="n">model_point_source_transit</span><span class="p">(</span>
                            <span class="n">peak_ra</span><span class="p">,</span> <span class="o">*</span><span class="n">param</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                        <span class="p">)</span>

            <span class="c1"># Create container to hold results of fit</span>
            <span class="n">gain_data</span> <span class="o">=</span> <span class="n">ccontainers</span><span class="o">.</span><span class="n">PointSourceTransit</span><span class="p">(</span>
                <span class="n">ra</span><span class="o">=</span><span class="n">ra_slice</span><span class="p">,</span> <span class="n">pol_x</span><span class="o">=</span><span class="n">xfeeds</span><span class="p">,</span> <span class="n">pol_y</span><span class="o">=</span><span class="n">yfeeds</span><span class="p">,</span> <span class="n">axes_from</span><span class="o">=</span><span class="n">sstream</span>
            <span class="p">)</span>

            <span class="n">gain_data</span><span class="o">.</span><span class="n">evalue_x</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">evalue_x</span>
            <span class="n">gain_data</span><span class="o">.</span><span class="n">evalue_y</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">evalue_y</span>
            <span class="n">gain_data</span><span class="o">.</span><span class="n">response</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">resp</span>
            <span class="n">gain_data</span><span class="o">.</span><span class="n">response_error</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">resp_err</span>
            <span class="n">gain_data</span><span class="o">.</span><span class="n">flag</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">fit_flag</span>
            <span class="n">gain_data</span><span class="o">.</span><span class="n">parameter</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">param</span>
            <span class="n">gain_data</span><span class="o">.</span><span class="n">parameter_cov</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">param_cov</span>

            <span class="c1"># Update units</span>
            <span class="n">gain_data</span><span class="o">.</span><span class="n">response</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unit_in</span> <span class="o">+</span> <span class="s2">&quot; / &quot;</span> <span class="o">+</span> <span class="n">unit_out</span>
            <span class="n">gain_data</span><span class="o">.</span><span class="n">response_error</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unit_in</span> <span class="o">+</span> <span class="s2">&quot; / &quot;</span> <span class="o">+</span> <span class="n">unit_out</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Create container to hold gains</span>
            <span class="n">gain_data</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">StaticGainData</span><span class="p">(</span><span class="n">axes_from</span><span class="o">=</span><span class="n">sstream</span><span class="p">)</span>

        <span class="c1"># Combine dynamic range estimates for both polarizations</span>
        <span class="n">dr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">dr_x</span><span class="p">[:,</span> <span class="n">slice_centre</span><span class="p">],</span> <span class="n">dr_y</span><span class="p">[:,</span> <span class="n">slice_centre</span><span class="p">])</span>

        <span class="c1"># Copy to container all quantities that are common to both</span>
        <span class="c1"># StaticGainData and PointSourceTransit containers</span>
        <span class="n">gain_data</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;weight&quot;</span><span class="p">)</span>

        <span class="n">gain_data</span><span class="o">.</span><span class="n">gain</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">gain</span>
        <span class="n">gain_data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">dr</span>

        <span class="c1"># Update units and unit conversion</span>
        <span class="n">gain_data</span><span class="o">.</span><span class="n">gain</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unit_in</span> <span class="o">+</span> <span class="s2">&quot; / &quot;</span> <span class="o">+</span> <span class="n">unit_out</span>
        <span class="n">gain_data</span><span class="o">.</span><span class="n">gain</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;converts_units_to&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Jy&quot;</span>

        <span class="c1"># Add attribute with the name of the point source</span>
        <span class="c1"># that was used for calibration</span>
        <span class="n">gain_data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span>

        <span class="c1"># Return gain data</span>
        <span class="k">return</span> <span class="n">gain_data</span></div>
</div>



<div class="viewcode-block" id="find_contiguous_time_ranges">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.find_contiguous_time_ranges">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">find_contiguous_time_ranges</span><span class="p">(</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">3600.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find contiguous ranges within an array of unix timestamps.</span>

<span class="sd">    Used by ThermalCalibration to determine the ranges of time</span>
<span class="sd">    to load temperature data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    timestamp: np.ndarray[ntime,]</span>
<span class="sd">        Unix timestamps.</span>
<span class="sd">    dt: float</span>
<span class="sd">        Maximum time difference in seconds.</span>
<span class="sd">        If consecutive timestamps are separated</span>
<span class="sd">        by more than 2 * dt, then they will be</span>
<span class="sd">        placed into separate time ranges. Note that</span>
<span class="sd">        each time range will be expanded by dt</span>
<span class="sd">        on either end.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    time_ranges: [(start_time, stop_time), ...]</span>
<span class="sd">        List of 2 element tuples, which each tuple</span>
<span class="sd">        containing the start and stop time covering</span>
<span class="sd">        a contiguous range of timestamps.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">timestamp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">timestamp</span><span class="p">)</span>

    <span class="n">start</span> <span class="o">=</span> <span class="p">[</span><span class="n">timestamp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span><span class="p">]</span>
    <span class="n">stop</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">timestamp</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">timestamp</span><span class="p">[</span><span class="n">tt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">timestamp</span><span class="p">[</span><span class="n">tt</span><span class="p">])</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dt</span><span class="p">):</span>
            <span class="n">stop</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">timestamp</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="p">)</span>
            <span class="n">start</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">timestamp</span><span class="p">[</span><span class="n">tt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span><span class="p">)</span>

    <span class="n">stop</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">timestamp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">))</span></div>



<div class="viewcode-block" id="ThermalCalibration">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.ThermalCalibration">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ThermalCalibration</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Use weather temperature to correct calibration in between point source transits.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    caltime_path : string</span>
<span class="sd">        Full path to file describing the calibration times.</span>
<span class="sd">    node_spoof : dictionary</span>
<span class="sd">        (default: {&#39;fir_online&#39;: &#39;/project/rpp-chime/chime/chime_online/&#39;} )</span>
<span class="sd">        host and directory in which to find data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">caltime_path</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
    <span class="n">node_spoof</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">dict</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">_DEFAULT_NODE_SPOOF</span><span class="p">)</span>

    <span class="n">caltime_file</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="ThermalCalibration.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.ThermalCalibration.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine thermal calibration for a sidereal stream or time stream.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : `containers.SiderealStream` or `containers.TimeStream`</span>
<span class="sd">            Data to generate calibration for.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gain : Either `containers.SiderealGainData` or `containers.GainData`</span>
<span class="sd">            The type depends on the type of `data`. Returns `None` if a thermal</span>
<span class="sd">            correction could not be determined.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Frequencies and RA/time</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">freq</span><span class="p">[:]</span>
        <span class="k">if</span> <span class="s2">&quot;ra&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ra2unix</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;lsd&quot;</span><span class="p">],</span> <span class="n">data</span><span class="o">.</span><span class="n">ra</span><span class="p">[:])</span>
            <span class="c1"># Create container</span>
            <span class="n">gain</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">CommonModeSiderealGainData</span><span class="p">(</span>
                <span class="n">axes_from</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">distributed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">comm</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="p">[:]</span>
            <span class="n">gain</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">CommonModeGainData</span><span class="p">(</span>
                <span class="n">axes_from</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">distributed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">comm</span>
            <span class="p">)</span>
        <span class="c1"># Redistribute</span>
        <span class="n">gain</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>
        <span class="n">lo</span> <span class="o">=</span> <span class="n">gain</span><span class="o">.</span><span class="n">gain</span><span class="o">.</span><span class="n">local_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ls</span> <span class="o">=</span> <span class="n">gain</span><span class="o">.</span><span class="n">gain</span><span class="o">.</span><span class="n">local_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Find reference times for each timestamp.</span>
        <span class="c1"># This is the time of the transit from which the gains</span>
        <span class="c1"># applied to the data were derived.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Getting reference times&quot;</span><span class="p">)</span>

        <span class="n">reftime_result</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Try and lookup the cal times. Only do this on rank = 0, and then broadcast the</span>
        <span class="c1"># results</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># First attempt to group all dataset_ids for all frequencies on</span>
            <span class="c1"># rank=0 so it can do the full lookup</span>
            <span class="n">dataset_ids</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dataset_id</span><span class="p">[:]</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">rank</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Try to use the dataset ID scheme in here, if the time range passed won&#39;t</span>
                <span class="c1"># work an exception will be raised...</span>
                <span class="n">reftime_result</span> <span class="o">=</span> <span class="n">cal_utils</span><span class="o">.</span><span class="n">get_reference_times_dataset_id</span><span class="p">(</span>
                    <span class="n">timestamp</span><span class="p">,</span> <span class="n">dataset_ids</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">log</span>
                <span class="p">)</span>

        <span class="c1"># ... catch it and then try to load a calibration time file</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s2">&quot;Could not get cal times via dataset IDs, trying caltime file.&quot;</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">caltime_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_load_cal_file</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">timestamp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_file_start</span> <span class="ow">and</span> <span class="n">timestamp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_file_end</span><span class="p">:</span>
                    <span class="n">reftime_result</span> <span class="o">=</span> <span class="n">cal_utils</span><span class="o">.</span><span class="n">get_reference_times_file</span><span class="p">(</span>
                        <span class="n">timestamp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">caltime_file</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">log</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Cal time file does not cover the period requested.&quot;</span><span class="p">)</span>

        <span class="n">reftime_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">reftime_result</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">reftime_result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;Could not find cal time for incoming data. Check the logs for rank=0 &quot;</span>
                <span class="s2">&quot;to see why.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Compute gain corrections</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Computing gains corrections&quot;</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reftime2gain</span><span class="p">(</span><span class="n">reftime_result</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">freq</span><span class="p">[</span><span class="n">lo</span> <span class="p">:</span> <span class="n">lo</span> <span class="o">+</span> <span class="n">ls</span><span class="p">])</span>

        <span class="c1"># Copy data into container</span>
        <span class="n">gain</span><span class="o">.</span><span class="n">gain</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[:]</span>

        <span class="k">return</span> <span class="n">gain</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_load_cal_file</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load the cal time file.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">caltime_file</span> <span class="o">=</span> <span class="n">memh5</span><span class="o">.</span><span class="n">MemGroup</span><span class="o">.</span><span class="n">from_hdf5</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">caltime_path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_file_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">caltime_file</span><span class="p">[</span><span class="s2">&quot;tstart&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_file_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">caltime_file</span><span class="p">[</span><span class="s2">&quot;tend&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_ra2unix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">csd</span><span class="p">,</span> <span class="n">ra</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Csd must be integer.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">chime</span><span class="o">.</span><span class="n">lsd_to_unix</span><span class="p">(</span><span class="n">csd</span> <span class="o">+</span> <span class="n">ra</span> <span class="o">/</span> <span class="mf">360.0</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_reftime2gain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reftime_result</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">frequency</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get gain corrections based on source transit times.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reftime_result : array of floats</span>
<span class="sd">            Unix time of same length as `timestamp&#39;. Reference times of transit of the</span>
<span class="sd">            source used to calibrate the data at each time in `times&#39;.</span>
<span class="sd">        timestamp : array of foats</span>
<span class="sd">            Unix time of data points to be calibrated.</span>
<span class="sd">        frequency : array of floats</span>
<span class="sd">            Frequencies to obtain the gain corrections for, in MHz.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        g : 2D array of floats of shape (nfreq, ntimes)</span>
<span class="sd">            Per-input gain amplitude corrections. Multiply by data</span>
<span class="sd">            to correct it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ntimes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">timestamp</span><span class="p">)</span>
        <span class="n">nfreq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frequency</span><span class="p">)</span>

        <span class="n">reftime</span> <span class="o">=</span> <span class="n">reftime_result</span><span class="p">[</span><span class="s2">&quot;reftime&quot;</span><span class="p">]</span>
        <span class="n">reftime_prev</span> <span class="o">=</span> <span class="n">reftime_result</span><span class="p">[</span><span class="s2">&quot;reftime_prev&quot;</span><span class="p">]</span>
        <span class="n">interp_start</span> <span class="o">=</span> <span class="n">reftime_result</span><span class="p">[</span><span class="s2">&quot;interp_start&quot;</span><span class="p">]</span>
        <span class="n">interp_stop</span> <span class="o">=</span> <span class="n">reftime_result</span><span class="p">[</span><span class="s2">&quot;interp_stop&quot;</span><span class="p">]</span>

        <span class="c1"># Ones. Don&#39;t modify data where there are no gains</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">ntimes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># Simple gains. No interpolation.</span>
        <span class="n">direct_gains</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">reftime</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">reftime_prev</span><span class="p">))</span>
        <span class="c1"># Gains that need interpolation</span>
        <span class="n">to_interpolate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">reftime_prev</span><span class="p">)</span>

        <span class="c1"># Load weather data for this time range</span>
        <span class="c1">#######################################################</span>
        <span class="n">trng</span> <span class="o">=</span> <span class="n">find_contiguous_time_ranges</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">reftime</span><span class="p">,</span> <span class="n">reftime_prev</span><span class="p">[</span><span class="n">to_interpolate</span><span class="p">]))</span>
        <span class="p">)</span>
        <span class="n">wtime</span><span class="p">,</span> <span class="n">wtemp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_weather</span><span class="p">(</span><span class="n">trng</span><span class="p">)</span>

        <span class="c1"># Exclude NaNs and Infs in weather data from the interpolation</span>
        <span class="n">weather_sel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">wtemp</span><span class="p">)</span>
        <span class="n">wtime</span> <span class="o">=</span> <span class="n">wtime</span><span class="p">[</span><span class="n">weather_sel</span><span class="p">]</span>
        <span class="n">wtemp</span> <span class="o">=</span> <span class="n">wtemp</span><span class="p">[</span><span class="n">weather_sel</span><span class="p">]</span>

        <span class="c1"># Gain corrections for direct gains (no interpolation).</span>
        <span class="c1">#######################################################</span>
        <span class="c1"># Reference temperatures</span>
        <span class="n">reftemp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpolate_temperature</span><span class="p">(</span><span class="n">wtime</span><span class="p">,</span> <span class="n">wtemp</span><span class="p">,</span> <span class="n">reftime</span><span class="p">[</span><span class="n">direct_gains</span><span class="p">])</span>
        <span class="c1"># Current temperatures</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpolate_temperature</span><span class="p">(</span><span class="n">wtime</span><span class="p">,</span> <span class="n">wtemp</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">[</span><span class="n">direct_gains</span><span class="p">])</span>
        <span class="c1"># Gain corrections</span>
        <span class="n">g</span><span class="p">[:,</span> <span class="n">direct_gains</span><span class="p">]</span> <span class="o">=</span> <span class="n">cal_utils</span><span class="o">.</span><span class="n">thermal_amplitude</span><span class="p">(</span>
            <span class="n">temp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">reftemp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="n">frequency</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Gain corrections for interpolated gains.</span>
        <span class="c1">##########################################</span>
        <span class="c1"># Reference temperatures</span>
        <span class="n">reftemp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpolate_temperature</span><span class="p">(</span><span class="n">wtime</span><span class="p">,</span> <span class="n">wtemp</span><span class="p">,</span> <span class="n">reftime</span><span class="p">[</span><span class="n">to_interpolate</span><span class="p">])</span>
        <span class="c1"># Reference temperatures of previous update</span>
        <span class="n">reftemp_prev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpolate_temperature</span><span class="p">(</span>
            <span class="n">wtime</span><span class="p">,</span> <span class="n">wtemp</span><span class="p">,</span> <span class="n">reftime_prev</span><span class="p">[</span><span class="n">to_interpolate</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="c1"># Current temperatures</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpolate_temperature</span><span class="p">(</span><span class="n">wtime</span><span class="p">,</span> <span class="n">wtemp</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">[</span><span class="n">to_interpolate</span><span class="p">])</span>
        <span class="c1"># Current gain corrections</span>
        <span class="n">current_gain</span> <span class="o">=</span> <span class="n">cal_utils</span><span class="o">.</span><span class="n">thermal_amplitude</span><span class="p">(</span>
            <span class="n">temp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">reftemp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="n">frequency</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="c1"># Previous gain corrections</span>
        <span class="n">previous_gain</span> <span class="o">=</span> <span class="n">cal_utils</span><span class="o">.</span><span class="n">thermal_amplitude</span><span class="p">(</span>
            <span class="n">temp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">reftemp_prev</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="n">frequency</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="c1"># Compute interpolation coefficient. Use a Hanning (cos^2) function.</span>
        <span class="c1"># The same that is used for gain interpolation in the real-time pipeline.</span>
        <span class="n">transition_period</span> <span class="o">=</span> <span class="n">interp_stop</span><span class="p">[</span><span class="n">to_interpolate</span><span class="p">]</span> <span class="o">-</span> <span class="n">interp_start</span><span class="p">[</span><span class="n">to_interpolate</span><span class="p">]</span>
        <span class="n">time_into_transition</span> <span class="o">=</span> <span class="n">timestamp</span><span class="p">[</span><span class="n">to_interpolate</span><span class="p">]</span> <span class="o">-</span> <span class="n">interp_start</span><span class="p">[</span><span class="n">to_interpolate</span><span class="p">]</span>
        <span class="n">interpolation_factor</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">time_into_transition</span> <span class="o">/</span> <span class="n">transition_period</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="p">)</span>
        <span class="n">g</span><span class="p">[:,</span> <span class="n">to_interpolate</span><span class="p">]</span> <span class="o">=</span> <span class="n">previous_gain</span> <span class="o">*</span> <span class="n">interpolation_factor</span> <span class="o">+</span> <span class="n">current_gain</span> <span class="o">*</span> <span class="p">(</span>
            <span class="mi">1</span> <span class="o">-</span> <span class="n">interpolation_factor</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">g</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_interpolate_temperature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">temperature_time</span><span class="p">,</span> <span class="n">temperature_data</span><span class="p">,</span> <span class="n">times</span><span class="p">):</span>
        <span class="c1"># Interpolate temperatures</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">temperature_time</span><span class="p">,</span> <span class="n">temperature_data</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_load_weather</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_ranges</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load the chime_weather acquisitions covering the input time ranges.&quot;&quot;&quot;</span>
        <span class="n">ntime</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Can only query the database from one rank.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="n">Finder</span><span class="p">(</span><span class="n">node_spoof</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">node_spoof</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">only_chime_weather</span><span class="p">()</span>  <span class="c1"># Excludes MingunWeather</span>
            <span class="k">for</span> <span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span> <span class="ow">in</span> <span class="n">time_ranges</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">include_time_interval</span><span class="p">(</span><span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">accept_all_global_flags</span><span class="p">()</span>

            <span class="n">times</span><span class="p">,</span> <span class="n">temperatures</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="n">results_list</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">get_results</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results_list</span><span class="p">:</span>
                <span class="n">wdata</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">as_loaded_data</span><span class="p">()</span>
                <span class="n">times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wdata</span><span class="o">.</span><span class="n">time</span><span class="p">[:])</span>
                <span class="n">temperatures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wdata</span><span class="o">.</span><span class="n">temperature</span><span class="p">[:])</span>

            <span class="n">wtime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
            <span class="n">wtemp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">temperatures</span><span class="p">)</span>

            <span class="n">ntime</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wtime</span><span class="p">)</span>

        <span class="c1"># Broadcast the times and temperatures to all ranks.</span>
        <span class="n">ntime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">ntime</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">wtime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">ntime</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">wtemp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">ntime</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="n">wtime</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="n">wtemp</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Ensure times are increasing. Needed for np.interp().</span>
        <span class="n">sort_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">wtime</span><span class="p">)</span>
        <span class="n">wtime</span> <span class="o">=</span> <span class="n">wtime</span><span class="p">[</span><span class="n">sort_index</span><span class="p">]</span>
        <span class="n">wtemp</span> <span class="o">=</span> <span class="n">wtemp</span><span class="p">[</span><span class="n">sort_index</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">wtime</span><span class="p">,</span> <span class="n">wtemp</span></div>



<div class="viewcode-block" id="ApplyDigitalGain">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.ApplyDigitalGain">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ApplyDigitalGain</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Multiply calibration gains by the digital gains.</span>

<span class="sd">    This yields the complex number that was applied</span>
<span class="sd">    to the voltage data by the real-time pipeline.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    invert: bool</span>
<span class="sd">        Multiply calibration gains by the *inverse* of the</span>
<span class="sd">        digital gains.</span>

<span class="sd">    normalize: bool</span>
<span class="sd">        Normalize the digital gains by the median value over</span>
<span class="sd">        input and frequency, so that the overall magnitude of</span>
<span class="sd">        the calibration gains does not change.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">invert</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">normalize</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="ApplyDigitalGain.setup">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.ApplyDigitalGain.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load digital gain files that cover full span of time to be processed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        files: list of str</span>
<span class="sd">            List of paths to files containing the digital gains.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Load all of the digital gains into a single container</span>
        <span class="n">digi_gain_data</span> <span class="o">=</span> <span class="n">andata</span><span class="o">.</span><span class="n">DigitalGainData</span><span class="o">.</span><span class="n">from_acq_h5</span><span class="p">(</span><span class="n">files</span><span class="p">)</span>

        <span class="c1"># Save as class attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">digi_gain_data</span> <span class="o">=</span> <span class="n">digi_gain_data</span>

        <span class="c1"># Extract the gain</span>
        <span class="n">dg</span> <span class="o">=</span> <span class="n">digi_gain_data</span><span class="o">.</span><span class="n">gain</span><span class="p">[:]</span>

        <span class="c1"># If requested, normalize the digital gains by the</span>
        <span class="c1"># median over frequency and input.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Normalizing the digital gains.&quot;</span><span class="p">)</span>
            <span class="n">med_dg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dg</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">dg</span> <span class="o">=</span> <span class="n">dg</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">med_dg</span><span class="p">)</span>

        <span class="c1"># If requested, invert the digital gains.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">invert</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Inverting the digital gains.&quot;</span><span class="p">)</span>
            <span class="n">dg</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">dg</span><span class="p">)</span>

        <span class="c1"># Save digital gains as class attribute.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dg</span> <span class="o">=</span> <span class="n">dg</span></div>


<div class="viewcode-block" id="ApplyDigitalGain.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.ApplyDigitalGain.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gain</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Lookup and apply the relevant digital gain update.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gain: StaticGainData</span>
<span class="sd">            The calibration gains at a particular time.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gain: StaticGainData</span>
<span class="sd">            The input container with the gain and weight dataset</span>
<span class="sd">            scaled by the appropriate digital gains.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gain</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Find the local frequencies</span>
        <span class="n">fsel</span> <span class="o">=</span> <span class="n">gain</span><span class="o">.</span><span class="n">gain</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_bounds</span>

        <span class="c1"># Look up the most recent digital gain update using</span>
        <span class="c1"># the timestamp in the input container</span>
        <span class="n">tindex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">digi_gain_data</span><span class="o">.</span><span class="n">search_update_time</span><span class="p">(</span><span class="n">gain</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Apply in place</span>
        <span class="n">dg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dg</span><span class="p">[</span><span class="n">tindex</span><span class="p">][</span><span class="n">fsel</span><span class="p">]</span>

        <span class="n">gain</span><span class="o">.</span><span class="n">gain</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">dg</span>
        <span class="n">gain</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dg</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Save digital gain update_id as attribute</span>
        <span class="n">gain</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;digitalgain_update_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">digi_gain_data</span><span class="o">.</span><span class="n">update_id</span><span class="p">[</span>
            <span class="n">tindex</span>
        <span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>

        <span class="c1"># Return the scaled gains</span>
        <span class="k">return</span> <span class="n">gain</span></div>
</div>



<div class="viewcode-block" id="InvertGain">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.InvertGain">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">InvertGain</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Invert gains.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="InvertGain.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.InvertGain.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gain</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Invert gains.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gain: StaticGainData or GainData</span>
<span class="sd">            gain data container</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gain: StaticGainData or GainData</span>
<span class="sd">            The input container with the gain dataset</span>
<span class="sd">            inverted and the uncertainty contained</span>
<span class="sd">            in the weight dataset propagated appropriately.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">gain</span><span class="o">.</span><span class="n">gain</span><span class="p">[:]</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">gain</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">**</span> <span class="mi">4</span>

        <span class="n">gain</span><span class="o">.</span><span class="n">gain</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="n">gain</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">w</span>

        <span class="k">return</span> <span class="n">gain</span></div>
</div>



<div class="viewcode-block" id="BaseCommonMode">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.BaseCommonMode">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BaseCommonMode</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for calculating the common-mode gain.&quot;&quot;&quot;</span>

    <span class="n">use_cylinder</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<div class="viewcode-block" id="BaseCommonMode.setup">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.BaseCommonMode.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pm</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Use telescope instance to identify groups of similar feeds.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pm : ProductManager</span>
<span class="sd">            Object describing the telescope.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_map</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">telescope</span><span class="o">.</span><span class="n">feeds</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_groups</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_map</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">containers</span><span class="o">.</span><span class="n">GainData</span><span class="p">:</span> <span class="s2">&quot;gain&quot;</span><span class="p">,</span>
            <span class="n">containers</span><span class="o">.</span><span class="n">StaticGainData</span><span class="p">:</span> <span class="s2">&quot;gain&quot;</span><span class="p">,</span>
            <span class="n">containers</span><span class="o">.</span><span class="n">TrackBeam</span><span class="p">:</span> <span class="s2">&quot;beam&quot;</span><span class="p">,</span>
        <span class="p">}</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_set_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputmap</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Group inputs based on their cylinder and polarisation.</span>

<span class="sd">        Override to define a different grouping.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inputmap: list of CorrInput</span>
<span class="sd">            map of inputs</span>

<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        groups: np.ndarray[ngroup,]</span>
<span class="sd">            Names of the groups that will be averaged over.</span>
<span class="sd">        gindex: dict</span>
<span class="sd">            Dictionary of the format {group_id: group_indices}.</span>
<span class="sd">            Each entry in gindex contains the indices of all inputs</span>
<span class="sd">            of a particular polarisation and (optionally) on a</span>
<span class="sd">            particular cylinder.</span>
<span class="sd">        glookup: dict</span>
<span class="sd">            Dictionary of the format {input_index: group_index}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">([</span><span class="n">tools</span><span class="o">.</span><span class="n">is_chime</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span> <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">inputmap</span><span class="p">])</span>

        <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{inp.pol}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_cylinder</span><span class="p">:</span>
            <span class="n">fmt</span> <span class="o">+=</span> <span class="s2">&quot;-</span><span class="si">{inp.cyl}</span><span class="s2">&quot;</span>

        <span class="n">idd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inp</span><span class="o">=</span><span class="n">inputmap</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">index</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">groups</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">idd</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gindex</span> <span class="o">=</span> <span class="p">{</span><span class="n">ug</span><span class="p">:</span> <span class="n">index</span><span class="p">[</span><span class="n">idd</span> <span class="o">==</span> <span class="n">ug</span><span class="p">]</span> <span class="k">for</span> <span class="n">ug</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">glookup</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">ii</span><span class="p">:</span> <span class="n">gg</span> <span class="k">for</span> <span class="n">gg</span><span class="p">,</span> <span class="n">ug</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gindex</span><span class="p">[</span><span class="n">ug</span><span class="p">]</span>
        <span class="p">}</span></div>



<div class="viewcode-block" id="ComputeCommonMode">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.ComputeCommonMode">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ComputeCommonMode</span><span class="p">(</span><span class="n">BaseCommonMode</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the common-mode gain amplitude.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    use_amplitude: bool</span>
<span class="sd">        Take the absolute value before calculating the</span>
<span class="sd">        average/percentile over inputs.</span>
<span class="sd">    use_percentile: bool</span>
<span class="sd">        If False, then calculate the average over inputs.</span>
<span class="sd">        If True, then calculate a percentile over inputs.</span>
<span class="sd">    percentile: float</span>
<span class="sd">        Percentile over inputs to calculate.</span>
<span class="sd">        Only used if use_percentile is True.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">use_amplitude</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">use_percentile</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">percentile</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">50.0</span><span class="p">)</span>

<div class="viewcode-block" id="ComputeCommonMode.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.ComputeCommonMode.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the common-mode gain.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data: StaticGainData or GainData</span>
<span class="sd">            gain data container</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        group: StaticGainData or GainData</span>
<span class="sd">            The common-mode gain *amplitude* for the different</span>
<span class="sd">            groups of inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Determine what dataset we are dealing with based on the</span>
        <span class="c1"># input container type and find the input axis of that dataset.</span>
        <span class="n">dset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_map</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="vm">__class__</span><span class="p">]</span>
        <span class="n">inp_axis</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">dset</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;input&quot;</span><span class="p">)</span>

        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Dereference datasets.</span>
        <span class="n">vis</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">dset</span><span class="p">][:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_amplitude</span><span class="p">:</span>
            <span class="c1"># If requested use only the amplitude.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Taking the amplitude of the gain.&quot;</span><span class="p">)</span>
            <span class="n">vis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">vis</span><span class="p">)</span>

        <span class="n">iscomplex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">iscomplex</span><span class="p">(</span><span class="n">vis</span><span class="p">))</span>

        <span class="n">weight</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="n">weight</span> <span class="o">&gt;</span> <span class="mf">0.0</span>

        <span class="c1"># Create output container</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There are </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">)</span><span class="si">:</span><span class="s2">0.0f</span><span class="si">}</span><span class="s2"> groups in total.&quot;</span><span class="p">)</span>

        <span class="n">group</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">attrs_from</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">axes_from</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">,</span>
            <span class="n">distributed</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">distributed</span><span class="p">,</span>
            <span class="n">comm</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">group</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;weight&quot;</span><span class="p">)</span>
        <span class="n">group</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="n">grp_vis</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="n">dset</span><span class="p">][:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">grp_weight</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

        <span class="c1"># Calculate the mean (or percentile) for each group of inputs</span>
        <span class="k">for</span> <span class="n">gg</span><span class="p">,</span> <span class="n">glbl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">):</span>
            <span class="n">gind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gindex</span><span class="p">[</span><span class="n">glbl</span><span class="p">]</span>

            <span class="n">gsi</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">inp_axis</span> <span class="o">+</span> <span class="p">[</span><span class="n">gind</span><span class="p">])</span>
            <span class="n">gso</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">inp_axis</span> <span class="o">+</span> <span class="p">[</span><span class="n">gg</span><span class="p">])</span>

            <span class="n">norm</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">gsi</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">inp_axis</span><span class="p">))</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_percentile</span><span class="p">:</span>
                <span class="n">temp_re</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">gsi</span><span class="p">],</span> <span class="n">vis</span><span class="p">[</span><span class="n">gsi</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">percentile</span><span class="p">,</span>
                    <span class="n">axis</span><span class="o">=</span><span class="n">inp_axis</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">iscomplex</span><span class="p">:</span>
                    <span class="n">temp_im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">gsi</span><span class="p">],</span> <span class="n">vis</span><span class="p">[</span><span class="n">gsi</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">percentile</span><span class="p">,</span>
                        <span class="n">axis</span><span class="o">=</span><span class="n">inp_axis</span><span class="p">,</span>
                    <span class="p">)</span>

                    <span class="n">temp</span> <span class="o">=</span> <span class="n">temp_re</span> <span class="o">+</span> <span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">temp_im</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">temp</span> <span class="o">=</span> <span class="n">temp_re</span>

                <span class="n">grp_vis</span><span class="p">[</span><span class="n">gso</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">temp</span><span class="p">),</span> <span class="n">temp</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

                <span class="n">grp_weight</span><span class="p">[</span><span class="n">gso</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">norm</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">grp_vis</span><span class="p">[</span><span class="n">gso</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">gsi</span><span class="p">]</span> <span class="o">*</span> <span class="n">vis</span><span class="p">[</span><span class="n">gsi</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">inp_axis</span><span class="p">)</span> <span class="o">*</span> <span class="n">norm</span>

                <span class="n">grp_weight</span><span class="p">[</span><span class="n">gso</span><span class="p">]</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">gsi</span><span class="p">]</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">weight</span><span class="p">[</span><span class="n">gsi</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="n">inp_axis</span><span class="p">)</span>
                    <span class="o">*</span> <span class="n">norm</span><span class="o">**</span><span class="mi">2</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">group</span></div>
</div>



<div class="viewcode-block" id="ExpandCommonMode">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.ExpandCommonMode">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ExpandCommonMode</span><span class="p">(</span><span class="n">BaseCommonMode</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Expand the common mode so that it can be applied to the original input axis.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="ExpandCommonMode.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.ExpandCommonMode.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmn</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Expand the common mode gain amplitude.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cmn: StaticGainData or GainData</span>
<span class="sd">            The common-mode gain *amplitude* for the different</span>
<span class="sd">            groups of inputs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out: StaticGainData or GainData</span>
<span class="sd">            The common-mode gain amplitude replicated for all inputs</span>
<span class="sd">            in a group.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_map</span><span class="p">[</span><span class="n">cmn</span><span class="o">.</span><span class="vm">__class__</span><span class="p">]</span>
        <span class="n">inp_axis</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cmn</span><span class="p">[</span><span class="n">dset</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;input&quot;</span><span class="p">)</span>

        <span class="n">cmn</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="n">cvis</span> <span class="o">=</span> <span class="n">cmn</span><span class="p">[</span><span class="n">dset</span><span class="p">][:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">cweight</span> <span class="o">=</span> <span class="n">cmn</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

        <span class="c1"># Create output container</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">inp</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">inp</span><span class="o">.</span><span class="n">input_sn</span><span class="p">)</span> <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_map</span><span class="p">],</span>
            <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;chan_id&quot;</span><span class="p">,</span> <span class="s2">&quot;u2&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;correlator_input&quot;</span><span class="p">,</span> <span class="s2">&quot;U32&quot;</span><span class="p">)],</span>
        <span class="p">)</span>
        <span class="n">ninput</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">size</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">cmn</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">attrs_from</span><span class="o">=</span><span class="n">cmn</span><span class="p">,</span>
            <span class="n">axes_from</span><span class="o">=</span><span class="n">cmn</span><span class="p">,</span>
            <span class="nb">input</span><span class="o">=</span><span class="n">inputs</span><span class="p">,</span>
            <span class="n">distributed</span><span class="o">=</span><span class="n">cmn</span><span class="o">.</span><span class="n">distributed</span><span class="p">,</span>
            <span class="n">comm</span><span class="o">=</span><span class="n">cmn</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;weight&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">out</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;weight&quot;</span><span class="p">)</span>

        <span class="n">out</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Dereference datasets</span>
        <span class="n">ovis</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="n">dset</span><span class="p">][:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">oweight</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

        <span class="c1"># Loop over local inputs</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ninput</span><span class="p">):</span>
            <span class="n">gso</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">inp_axis</span> <span class="o">+</span> <span class="p">[</span><span class="n">ii</span><span class="p">])</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">gg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">glookup</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>

            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">ovis</span><span class="p">[</span><span class="n">gso</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
                <span class="n">oweight</span><span class="p">[</span><span class="n">gso</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">gsi</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">inp_axis</span> <span class="o">+</span> <span class="p">[</span><span class="n">gg</span><span class="p">])</span>

                <span class="n">ovis</span><span class="p">[</span><span class="n">gso</span><span class="p">]</span> <span class="o">=</span> <span class="n">cvis</span><span class="p">[</span><span class="n">gsi</span><span class="p">]</span>
                <span class="n">oweight</span><span class="p">[</span><span class="n">gso</span><span class="p">]</span> <span class="o">=</span> <span class="n">cweight</span><span class="p">[</span><span class="n">gsi</span><span class="p">]</span>

        <span class="c1"># Return</span>
        <span class="k">return</span> <span class="n">out</span></div>
</div>



<div class="viewcode-block" id="IdentifyNarrowbandFeatures">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.IdentifyNarrowbandFeatures">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">IdentifyNarrowbandFeatures</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Identify and flag narrowband features in gains.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    tau_cut: float</span>
<span class="sd">        Cutoff of the high-pass filter in microseconds.</span>
<span class="sd">    epsilon: float</span>
<span class="sd">        Stop-band rejection of the filter.</span>
<span class="sd">    window: int</span>
<span class="sd">        Width of the window, in number of frequency channnels,</span>
<span class="sd">        used to estimate the noise by calculating a local</span>
<span class="sd">        median absolute deviation.</span>
<span class="sd">    threshold: float</span>
<span class="sd">        Number of median absolute deviations beyond which</span>
<span class="sd">        a frequency channel is considered an outlier.</span>
<span class="sd">    nperiter: int</span>
<span class="sd">        Maximum number of frequency channels to flag</span>
<span class="sd">        on any iteration.</span>
<span class="sd">    niter: int</span>
<span class="sd">        Maximum number of iterations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">tau_cut</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.6</span><span class="p">)</span>
    <span class="n">epsilon</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">)</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">151</span><span class="p">)</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">6.0</span><span class="p">)</span>
    <span class="n">nperiter</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">niter</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>

<div class="viewcode-block" id="IdentifyNarrowbandFeatures.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.IdentifyNarrowbandFeatures.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Identify and flag narrowband features in the gain.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data: StaticGainData</span>
<span class="sd">            Gain applied to the voltage data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out: StaticGainData</span>
<span class="sd">            Copy of the input container with the weight</span>
<span class="sd">            dataset set to zero if a narrowband feature</span>
<span class="sd">            has been identified for that frequency and input.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create output container.  Problems with copy when distributed over inputs.</span>
        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">out</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;input&quot;</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;input&quot;</span><span class="p">)</span>

        <span class="c1"># Dereference datasets and calculate amplitude</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">freq</span>
        <span class="n">amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">gain</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">)</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

        <span class="n">oweight</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

        <span class="n">ninput</span> <span class="o">=</span> <span class="n">amp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Flag RFI</span>
        <span class="n">rfi_flag</span> <span class="o">=</span> <span class="o">~</span><span class="n">rfi</span><span class="o">.</span><span class="n">frequency_mask</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="p">(</span><span class="n">weight</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">rfi_flag</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="c1"># Loop over local inputs</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ninput</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing input </span><span class="si">{</span><span class="n">ii</span><span class="si">}</span><span class="s2"> of </span><span class="si">{</span><span class="n">ninput</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">flag</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">]):</span>
                <span class="n">oweight</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">continue</span>

            <span class="c1"># Generate the mask</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">flag_hpf</span> <span class="o">=</span> <span class="n">rfi</span><span class="o">.</span><span class="n">iterative_hpf_masking</span><span class="p">(</span>
                    <span class="n">freq</span><span class="p">,</span>
                    <span class="n">amp</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">],</span>
                    <span class="n">flag</span><span class="o">=</span><span class="n">flag</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">],</span>
                    <span class="n">tau_cut</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tau_cut</span><span class="p">,</span>
                    <span class="n">epsilon</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span><span class="p">,</span>
                    <span class="n">window</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">,</span>
                    <span class="n">threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">,</span>
                    <span class="n">nperiter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nperiter</span><span class="p">,</span>
                    <span class="n">niter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">niter</span><span class="p">,</span>
                <span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Failed to create delay filter for input </span><span class="si">{</span><span class="n">ii</span><span class="si">}</span><span class="s2"> (of </span><span class="si">{</span><span class="n">ninput</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">exc</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">oweight</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Update the weight dataset to flag the narrowband features</span>
                <span class="n">oweight</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">*=</span> <span class="n">flag_hpf</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="c1"># Return the original gain container with modified weights</span>
        <span class="k">return</span> <span class="n">out</span></div>
</div>



<div class="viewcode-block" id="ReconstructGainError">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.ReconstructGainError">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ReconstructGainError</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Estimate the fractional error in the calibration gain.</span>

<span class="sd">    The &quot;true&quot; gain is estimated by low-pass filtering the</span>
<span class="sd">    applied gain along the frequency axis.  The ratio of the</span>
<span class="sd">    applied gain to the true gain is then output.</span>

<span class="sd">    The low-pass filtering is sensitive to narrowband features in</span>
<span class="sd">    the gain due to RFI.  An iterative algorithm is used to</span>
<span class="sd">    identify these narrowband features by low-pass filtering,</span>
<span class="sd">    taking the ratio, averaging over all baselines, masking the</span>
<span class="sd">    `nperiter` largest absolute deviations relative to the</span>
<span class="sd">    median absolute deviation, and then repeating the procedure.</span>
<span class="sd">    The frequencies identified as containing narrowband features</span>
<span class="sd">    should be masked in the visibility dataset.</span>

<span class="sd">    This procedure requires access to all frequencies and inputs.</span>
<span class="sd">    For this reason, it is recommended to provide the gain over</span>
<span class="sd">    many nights so that the procedure can be distributed over time.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    full_output : bool</span>
<span class="sd">        If False, then only output the fractional error in the</span>
<span class="sd">        calibration gains.  If True, then the low-pass filtered gains,</span>
<span class="sd">        frequency-time mask, and an archive of the baseline-averaged</span>
<span class="sd">        fractional error at each iteration will be output as well.</span>
<span class="sd">    simple_lpf : bool</span>
<span class="sd">        If True, then use a simple FIR low-pass filter.  If False,</span>
<span class="sd">        then use the DAYENUREST technique to construct the filter.</span>
<span class="sd">    numtaps : float</span>
<span class="sd">        Number of taps in the FIR low-pass filter if simple_lpf is True.</span>
<span class="sd">        Note this is specified in MHz with the actual number of taps</span>
<span class="sd">        obtained by dividing this number by the frequency channel width.</span>
<span class="sd">    remove_hpf : bool</span>
<span class="sd">        Remove a high-pass filtered version of the gains using DAYENU</span>
<span class="sd">        prior to fitting DPSS modes to obtain the low-pass filtered version.</span>
<span class="sd">        Can suffer from numerical issues when inverting the signal covariance.</span>
<span class="sd">        Only relevant if simple_lpf is False.</span>
<span class="sd">    rcond : float</span>
<span class="sd">        The condition number used to calculate the pseudo-inverse of the masked</span>
<span class="sd">        frequency-frequency covariance matrix when using DAYENU.  Only relevant</span>
<span class="sd">        if remove_hpf is True and simple_lpf is False.</span>
<span class="sd">    niter : int</span>
<span class="sd">        Maximum number of iterations used to mask narrowband features in the gains.</span>
<span class="sd">    window: int</span>
<span class="sd">        Width of the window, in number of frequency channnels, used to estimate</span>
<span class="sd">        the noise by calculating a local median absolute deviation. If not provided,</span>
<span class="sd">        then will use the entire band.</span>
<span class="sd">    nsigma_outlier : float</span>
<span class="sd">        Number of median absolute deviations beyond which a frequency channel</span>
<span class="sd">        is considered an outlier.  The algorithm terminates when there are</span>
<span class="sd">        no longer any frequency channels that exceed this threshold</span>
<span class="sd">        or the maximum number of iterations is reached.</span>
<span class="sd">    nperiter: int</span>
<span class="sd">        Maximum number of frequency channels to flag on any iteration. Note that</span>
<span class="sd">        the low-pass filtering will leak power from outliers to neighboring</span>
<span class="sd">        frequencies, so it is recommended to keep this number small in order to</span>
<span class="sd">        avoid accidentally masking good frequencies contaminated by a neighbor.</span>
<span class="sd">    mask_rfi_bands : bool</span>
<span class="sd">        Ignore the persistent RFI bands when calculating the gain error.</span>
<span class="sd">        These bands are specified in ch_util.rfi.frequency_mask.</span>
<span class="sd">    tau_centre : float or np.ndarray[nstopband,]</span>
<span class="sd">        The centre of the pass-band regions in micro-seconds.</span>
<span class="sd">    tau_width : float or np.ndarray[nstopband,]</span>
<span class="sd">        The half width of the pass-band regions in micro-seconds.</span>
<span class="sd">    epsilon: float</span>
<span class="sd">        Stop-band rejection of the filter.</span>
<span class="sd">    threshold: float</span>
<span class="sd">        Filter is constructed from eigenmodes of the signal covariance whose</span>
<span class="sd">        eigenvalue is larger than this factor times the maximum eigenvalue.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">full_output</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">simple_lpf</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">numtaps</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">20.0</span><span class="p">)</span>

    <span class="n">remove_hpf</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">rcond</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0e-15</span><span class="p">)</span>

    <span class="n">niter</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">nsigma_outlier</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">4.0</span><span class="p">)</span>
    <span class="n">nperiter</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">mask_rfi_bands</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">tau_centre</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="n">tau_width</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
    <span class="n">epsilon</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0e-12</span><span class="p">)</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0e-12</span><span class="p">)</span>

<div class="viewcode-block" id="ReconstructGainError.setup">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.ReconstructGainError.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine the frequency axis.</span>

<span class="sd">        This is necessary because the frequency axis in the gains is saved</span>
<span class="sd">        as float32 instead of float64, which causes issues when constructing</span>
<span class="sd">        the delay filter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">800.0</span><span class="p">,</span> <span class="mf">400.0</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dfreq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">)))</span></div>


<div class="viewcode-block" id="ReconstructGainError.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.ReconstructGainError.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gain</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Identify features in the gains at high delay.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gain: GainData</span>
<span class="sd">            Original gain data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out_err: GainData</span>
<span class="sd">            Ratio of the original gain and a low-pass filtered version of the gain.</span>
<span class="sd">        out_lpf: GainData</span>
<span class="sd">            Low-pass filtered version of the gain.  Only output if full_output is True.</span>
<span class="sd">        out_mask: RFIMask</span>
<span class="sd">            Frequencies and times that were identified as outliers by the iterative</span>
<span class="sd">            high-pass-filter masking algorithm.  Only output if full_output is True.</span>
<span class="sd">        archive: GainData</span>
<span class="sd">            The gain error averaged over all baselines for each iteration of the</span>
<span class="sd">            high-pass-filter masking algorithm.  The input axis of this container is</span>
<span class="sd">            used to accomodate iteration number.  Only output if full_output is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Redistribute over time</span>
        <span class="n">gain</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span>

        <span class="c1"># Dereference datasets</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">gain</span><span class="o">.</span><span class="n">gain</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">gain</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

        <span class="n">nfreq</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">ntime</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_freq</span><span class="p">(</span><span class="n">gain</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span>

        <span class="n">unix_times</span> <span class="o">=</span> <span class="n">gain</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">gain</span><span class="o">.</span><span class="n">gain</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_bounds</span><span class="p">]</span>

        <span class="c1"># Create a mask that identifies flagged data</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="mf">0.0</span>

        <span class="c1"># Create output gain errors</span>
        <span class="n">out_err</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">GainData</span><span class="p">(</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">axes_from</span><span class="o">=</span><span class="n">gain</span><span class="p">,</span>
            <span class="n">attrs_from</span><span class="o">=</span><span class="n">gain</span><span class="p">,</span>
            <span class="n">distributed</span><span class="o">=</span><span class="n">gain</span><span class="o">.</span><span class="n">distributed</span><span class="p">,</span>
            <span class="n">comm</span><span class="o">=</span><span class="n">gain</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">out_err</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;weight&quot;</span><span class="p">)</span>
        <span class="n">out_err</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;update_id&quot;</span><span class="p">)</span>
        <span class="n">out_err</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span>

        <span class="n">out_err</span><span class="o">.</span><span class="n">update_id</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">gain</span><span class="o">.</span><span class="n">update_id</span><span class="p">[:]</span>

        <span class="n">gout_err</span> <span class="o">=</span> <span class="n">out_err</span><span class="o">.</span><span class="n">gain</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">wout_err</span> <span class="o">=</span> <span class="n">out_err</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

        <span class="n">gout_err</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">wout_err</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># The following containers are only output if requested</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_output</span><span class="p">:</span>

            <span class="c1"># Create output LPF gain</span>
            <span class="n">out_lpf</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">GainData</span><span class="p">(</span>
                <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
                <span class="n">axes_from</span><span class="o">=</span><span class="n">gain</span><span class="p">,</span>
                <span class="n">attrs_from</span><span class="o">=</span><span class="n">gain</span><span class="p">,</span>
                <span class="n">distributed</span><span class="o">=</span><span class="n">gain</span><span class="o">.</span><span class="n">distributed</span><span class="p">,</span>
                <span class="n">comm</span><span class="o">=</span><span class="n">gain</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">out_lpf</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;weight&quot;</span><span class="p">)</span>
            <span class="n">out_lpf</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;update_id&quot;</span><span class="p">)</span>
            <span class="n">out_lpf</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span>

            <span class="n">out_lpf</span><span class="o">.</span><span class="n">update_id</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">gain</span><span class="o">.</span><span class="n">update_id</span><span class="p">[:]</span>

            <span class="n">gout_lpf</span> <span class="o">=</span> <span class="n">out_lpf</span><span class="o">.</span><span class="n">gain</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
            <span class="n">wout_lpf</span> <span class="o">=</span> <span class="n">out_lpf</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

            <span class="n">gout_lpf</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">wout_lpf</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="c1"># Create archive of iterations</span>
            <span class="n">archive</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">GainData</span><span class="p">(</span>
                <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
                <span class="nb">input</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">niter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span>
                <span class="n">axes_from</span><span class="o">=</span><span class="n">gain</span><span class="p">,</span>
                <span class="n">attrs_from</span><span class="o">=</span><span class="n">gain</span><span class="p">,</span>
                <span class="n">distributed</span><span class="o">=</span><span class="n">gain</span><span class="o">.</span><span class="n">distributed</span><span class="p">,</span>
                <span class="n">comm</span><span class="o">=</span><span class="n">gain</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">archive</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;weight&quot;</span><span class="p">)</span>
            <span class="n">archive</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span>

            <span class="n">garch</span> <span class="o">=</span> <span class="n">archive</span><span class="o">.</span><span class="n">gain</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
            <span class="n">warch</span> <span class="o">=</span> <span class="n">archive</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

            <span class="n">garch</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">warch</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="c1"># Create output RFI mask</span>
            <span class="n">out_mask</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">RFIMask</span><span class="p">(</span><span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">axes_from</span><span class="o">=</span><span class="n">gain</span><span class="p">,</span> <span class="n">attrs_from</span><span class="o">=</span><span class="n">gain</span><span class="p">)</span>
            <span class="n">out_mask</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">ntime</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="c1"># Determine eigen-modes of the signal covariance</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">out_err</span><span class="o">.</span><span class="n">freq</span>

        <span class="n">cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_cov</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
        <span class="n">evalue</span><span class="p">,</span> <span class="n">evec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span>

        <span class="n">isort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">evalue</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">evalue</span> <span class="o">=</span> <span class="n">evalue</span><span class="p">[</span><span class="n">isort</span><span class="p">]</span> <span class="o">/</span> <span class="n">evalue</span><span class="p">[</span><span class="n">isort</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">evec</span> <span class="o">=</span> <span class="n">evec</span><span class="p">[:,</span> <span class="n">isort</span><span class="p">]</span>

        <span class="n">imax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">evalue</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fitting </span><span class="si">{</span><span class="n">imax</span><span class="si">}</span><span class="s2"> DPSS modes (of </span><span class="si">{</span><span class="n">evalue</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">)</span>

        <span class="n">A</span> <span class="o">=</span> <span class="n">evec</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">imax</span><span class="p">]</span>
        <span class="n">AT</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>

        <span class="c1"># Loop over times</span>
        <span class="k">for</span> <span class="n">tt</span><span class="p">,</span> <span class="n">timestamp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unix_times</span><span class="p">):</span>

            <span class="c1"># Make sure the flags can be factorized into an input flag and frequency flag</span>
            <span class="n">fmeas</span> <span class="o">=</span> <span class="n">flag</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">tt</span><span class="p">]</span>

            <span class="n">input_flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">fmeas</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">good_input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">input_flag</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">fmeas</span><span class="p">[:,</span> <span class="n">good_input</span><span class="p">]</span> <span class="o">==</span> <span class="n">fmeas</span><span class="p">[:,</span> <span class="n">good_input</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Must have the same frequency mask for all good inputs.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Extact gain for good inputs and global frequency mask</span>
            <span class="n">gmeas</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">tt</span><span class="p">][:,</span> <span class="n">good_input</span><span class="p">]</span>
            <span class="n">wmeas</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">tt</span><span class="p">][:,</span> <span class="n">good_input</span><span class="p">]</span>
            <span class="n">vmeas</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">wmeas</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_rfi_bands</span><span class="p">:</span>
                <span class="n">freq_flag0</span> <span class="o">=</span> <span class="n">fmeas</span><span class="p">[:,</span> <span class="n">good_input</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">rfi</span><span class="o">.</span><span class="n">frequency_mask</span><span class="p">(</span>
                    <span class="n">freq</span><span class="p">,</span> <span class="n">timestamp</span><span class="o">=</span><span class="n">timestamp</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">freq_flag0</span> <span class="o">=</span> <span class="n">fmeas</span><span class="p">[:,</span> <span class="n">good_input</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

            <span class="n">freq_flag</span> <span class="o">=</span> <span class="n">freq_flag0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="n">rcond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rcond</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">niter</span><span class="p">):</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Iteration </span><span class="si">{</span><span class="n">ii</span><span class="si">}</span><span class="s2"> of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">niter</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

                <span class="c1"># Low-pass filter the gains</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">simple_lpf</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ii</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">niter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)):</span>

                    <span class="c1"># If the simple LPF was requested, then we first need to interpolate</span>
                    <span class="c1"># over the masked frequencies.  This is slow, so we only do this for</span>
                    <span class="c1"># the last iteration.  Otherwise we use the faster DAYENUREST method</span>
                    <span class="c1"># for identify outlier frequencies.</span>
                    <span class="n">ginterp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpolate</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">gmeas</span><span class="p">,</span> <span class="n">wmeas</span><span class="p">,</span> <span class="n">freq_flag</span><span class="p">)</span>
                    <span class="n">inv_ginterp</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_simple_lpf</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">ginterp</span><span class="p">)</span>
                    <span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># If requested, first subtract off a HPF version of the gains obtained</span>
                    <span class="c1"># by applying DAYENU.  If the signal covariance matrix inversion fails,</span>
                    <span class="c1"># then we increase the condition number (rcond) and try again.</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_hpf</span><span class="p">:</span>

                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hpf</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">freq_flag</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="n">rcond</span><span class="p">)</span>

                        <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                                <span class="s2">&quot;Failed to converge while processing &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;iteration </span><span class="si">{</span><span class="n">ii</span><span class="si">}</span><span class="s2"> (rcond is </span><span class="si">{</span><span class="n">rcond</span><span class="si">:</span><span class="s2">0.1e</span><span class="si">}</span><span class="s2">):  &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">exc</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="p">)</span>
                            <span class="n">rcond</span> <span class="o">=</span> <span class="n">rcond</span> <span class="o">*</span> <span class="mf">10.0</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">rcond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rcond</span>

                        <span class="n">ghpf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">gmeas</span><span class="p">)</span>
                        <span class="n">glpf</span> <span class="o">=</span> <span class="n">freq_flag</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">gmeas</span> <span class="o">-</span> <span class="n">ghpf</span><span class="p">)</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">glpf</span> <span class="o">=</span> <span class="n">freq_flag</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">gmeas</span>

                    <span class="c1"># Obtain low-pass-filtered gains by fitting the DPSS modes,</span>
                    <span class="c1"># ignoring masked frequencies.</span>
                    <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">AT</span><span class="p">,</span> <span class="n">freq_flag</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span><span class="p">)</span>

                    <span class="n">ginterp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">AT</span><span class="p">,</span> <span class="n">glpf</span><span class="p">)))</span>
                    <span class="n">inv_ginterp</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">ginterp</span><span class="p">)</span>

                <span class="c1"># Calculate the ratio of the gains to the low-pass-filtered gains.</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="n">gmeas</span> <span class="o">*</span> <span class="n">inv_ginterp</span>

                <span class="k">if</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">niter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>

                    <span class="c1"># Collapse over feeds</span>
                    <span class="n">avg_ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_average_over_feeds</span><span class="p">(</span><span class="n">ratio</span><span class="p">)</span>

                    <span class="c1"># Flag</span>
                    <span class="n">dratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">freq_flag</span><span class="p">,</span> <span class="n">avg_ratio</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

                    <span class="n">masked_freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_identify_outliers</span><span class="p">(</span><span class="n">dratio</span><span class="p">,</span> <span class="n">freq_flag</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">masked_freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">perc_masked</span> <span class="o">=</span> <span class="mf">100.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="o">~</span><span class="n">freq_flag</span> <span class="o">&amp;</span> <span class="n">freq_flag0</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Iteration </span><span class="si">{</span><span class="n">ii</span><span class="si">}</span><span class="s2">, finished.  &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;Masked </span><span class="si">{</span><span class="n">perc_masked</span><span class="si">:</span><span class="s2">0.3f</span><span class="si">}</span><span class="s2"> percent of frequencies in total.&quot;</span>
                        <span class="p">)</span>
                        <span class="k">break</span>

                    <span class="c1"># Update the frequency mask</span>
                    <span class="n">freq_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">masked_freq</span>

                    <span class="c1"># Print total number off frequencies masked thus far</span>
                    <span class="n">perc_masked</span> <span class="o">=</span> <span class="mf">100.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="o">~</span><span class="n">freq_flag</span> <span class="o">&amp;</span> <span class="n">freq_flag0</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Iteration </span><span class="si">{</span><span class="n">ii</span><span class="si">}</span><span class="s2">, finished.  &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Masked </span><span class="si">{</span><span class="n">perc_masked</span><span class="si">:</span><span class="s2">0.3f</span><span class="si">}</span><span class="s2"> percent of frequencies in total.&quot;</span>
                    <span class="p">)</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_output</span><span class="p">:</span>
                        <span class="n">garch</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">tt</span><span class="p">]</span> <span class="o">=</span> <span class="n">avg_ratio</span>
                        <span class="n">warch</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">tt</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq_flag</span>

            <span class="c1"># Save final result</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">vmeas</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">inv_ginterp</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>

            <span class="n">gout_err</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">tt</span><span class="p">][:,</span> <span class="n">good_input</span><span class="p">]</span> <span class="o">=</span> <span class="n">ratio</span>
            <span class="n">wout_err</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">tt</span><span class="p">][:,</span> <span class="n">good_input</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">freq_flag</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">var</span><span class="p">),</span> <span class="mf">0.0</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_output</span><span class="p">:</span>
                <span class="n">gout_lpf</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">tt</span><span class="p">][:,</span> <span class="n">good_input</span><span class="p">]</span> <span class="o">=</span> <span class="n">ginterp</span>
                <span class="n">wout_lpf</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">tt</span><span class="p">][:,</span> <span class="n">good_input</span><span class="p">]</span> <span class="o">=</span> <span class="n">vmeas</span>

                <span class="n">mask</span><span class="p">[:,</span> <span class="n">tt</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="n">freq_flag</span> <span class="o">&amp;</span> <span class="n">freq_flag0</span>

        <span class="c1"># Prepare output depending on config parameters</span>
        <span class="n">out_err</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_output</span><span class="p">:</span>
            <span class="n">out_mask</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span>
                <span class="n">mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">gain</span><span class="o">.</span><span class="n">comm</span>
            <span class="p">)</span><span class="o">.</span><span class="n">allgather</span><span class="p">()</span>

            <span class="n">out_lpf</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>
            <span class="n">archive</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

            <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">out_err</span><span class="p">,</span> <span class="n">out_lpf</span><span class="p">,</span> <span class="n">out_mask</span><span class="p">,</span> <span class="n">archive</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out_err</span>

        <span class="k">return</span> <span class="n">out</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_average_over_feeds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ratio</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Average the product of the fractional gain error over all pairs of feeds.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ratio : np.ndarray[nfreq, ninput]</span>
<span class="sd">            Gain divided by a low-pass-filtered version of the gain.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        vis : np.ndarray[nfreq,]</span>
<span class="sd">            Effective error in the beamformed visibilities due to gain errors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ratio_conj</span> <span class="o">=</span> <span class="n">ratio</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>

        <span class="n">shp</span> <span class="o">=</span> <span class="n">ratio</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">nfeed</span> <span class="o">=</span> <span class="n">ratio</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">nprod</span> <span class="o">=</span> <span class="p">(</span><span class="n">nfeed</span> <span class="o">*</span> <span class="p">(</span><span class="n">nfeed</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">//</span> <span class="mi">2</span>

        <span class="n">vis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shp</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ratio</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nfeed</span><span class="p">):</span>
            <span class="n">vis</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ratio</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">ratio_conj</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">ii</span><span class="p">:],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">vis</span> <span class="o">/</span> <span class="n">nprod</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_identify_outliers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Identify frequencies where fractional gain error exceeds some threshold.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dy : np.ndarray[nfreq,]</span>
<span class="sd">            Fractional errors in the gain, averaged over all pairs of feeds.</span>
<span class="sd">        flag : np.ndarray[nfreq,]</span>
<span class="sd">            Boolean flag where True indicates good frequency channels and False</span>
<span class="sd">            indicates previously masked frequency channels.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_mask : np.ndarray[nfreq,]</span>
<span class="sd">            Boolean mask where True indicates the frequency channel is an outlier.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the local median absolute deviation</span>
        <span class="n">ady</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dy</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="mf">1.48625</span> <span class="o">*</span> <span class="n">weighted_median</span><span class="o">.</span><span class="n">moving_weighted_median</span><span class="p">(</span>
                <span class="n">ady</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;split&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="mf">1.48625</span> <span class="o">*</span> <span class="n">weighted_median</span><span class="o">.</span><span class="n">weighted_median</span><span class="p">(</span><span class="n">ady</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;split&quot;</span><span class="p">)</span>

        <span class="c1"># Calculate the signal to noise</span>
        <span class="n">s2n</span> <span class="o">=</span> <span class="n">ady</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>

        <span class="c1"># Identify frequency channels that are above the signal to noise threshold</span>
        <span class="n">above_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">s2n</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsigma_outlier</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">above_threshold</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Find the largest nperiter frequency channels that are above the threshold</span>
        <span class="n">ibad</span> <span class="o">=</span> <span class="n">above_threshold</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">ady</span><span class="p">[</span><span class="n">above_threshold</span><span class="p">])[</span><span class="mi">0</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nperiter</span><span class="p">]]</span>

        <span class="c1"># Flag those frequency channels</span>
        <span class="n">new_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>
        <span class="n">new_mask</span><span class="p">[</span><span class="n">ibad</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">new_mask</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_freq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the appropriate float64 representation of the frequencies.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq : np.ndarray[nfreq,]</span>
<span class="sd">            Frequencies in MHz.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        faxis : np.ndarray[nfreq,] with dtype [(&quot;centre&quot;, &lt;f8), (&quot;width&quot;, &lt;f8)]</span>
<span class="sd">            Float64 representation of the frequencies to be used</span>
<span class="sd">            in filter construction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">imatch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">nu</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">))</span> <span class="k">for</span> <span class="n">nu</span> <span class="ow">in</span> <span class="n">freq</span><span class="p">])</span>

        <span class="n">freq_match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="n">imatch</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">freq</span> <span class="o">-</span> <span class="n">freq_match</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfreq</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Frequency axis unexpected.&quot;</span><span class="p">)</span>

        <span class="n">faxis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">freq_match</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;centre&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;width&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)])</span>
        <span class="n">faxis</span><span class="p">[</span><span class="s2">&quot;centre&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq_match</span>
        <span class="n">faxis</span><span class="p">[</span><span class="s2">&quot;width&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfreq</span>

        <span class="k">return</span> <span class="n">faxis</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_cov</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct a model for the signal covariance.</span>

<span class="sd">        Assumes the signal is the sum of one or more</span>
<span class="sd">        top hats in delay space located at tau_centre</span>
<span class="sd">        with half-width tau_width.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq : np.ndarray[nfreq,]</span>
<span class="sd">            Frequency in MHz.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cov : np.ndarray[nfreq, nfreq]</span>
<span class="sd">            Model for the signal covariance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tau_centre</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_width</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span><span class="p">)</span>

        <span class="n">nfreq</span> <span class="o">=</span> <span class="n">freq</span><span class="o">.</span><span class="n">size</span>
        <span class="n">dfreq</span> <span class="o">=</span> <span class="n">freq</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="n">freq</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">nfreq</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">tt</span><span class="p">,</span> <span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">tw</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)):</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Filter component </span><span class="si">{</span><span class="n">tt</span><span class="si">}</span><span class="s2">: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;tau_c = </span><span class="si">{</span><span class="n">tc</span><span class="si">:</span><span class="s2">0.2f</span><span class="si">}</span><span class="s2"> usec, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;tau_w = </span><span class="si">{</span><span class="n">tw</span><span class="si">:</span><span class="s2">0.2f</span><span class="si">}</span><span class="s2"> usec, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;eps = </span><span class="si">{</span><span class="n">eps</span><span class="si">:</span><span class="s2">0.1e</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

            <span class="n">cov</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">tc</span> <span class="o">*</span> <span class="n">dfreq</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">tw</span> <span class="o">*</span> <span class="n">dfreq</span><span class="p">)</span> <span class="o">/</span> <span class="n">eps</span>

        <span class="k">return</span> <span class="n">cov</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_hpf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct a high pass filter from foreground covariance and frequency mask.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cov : np.ndarray[nfreq, nfreq]</span>
<span class="sd">            Model for the signal covariance.</span>
<span class="sd">        flag : np.ndarray[nfreq,]</span>
<span class="sd">            Boolean flag where True indicates a good frequency and</span>
<span class="sd">            False indicates a bad frequency.</span>
<span class="sd">        rcond : float, optional</span>
<span class="sd">            Cutoff for small singular values passed to `np.linalg.pinv`.</span>
<span class="sd">            Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pinv : np.ndarray[nfreq, nfreq]</span>
<span class="sd">            Pseudo-inverse of the foreground covariance times</span>
<span class="sd">            outer product of the mask with itself.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nfreq</span> <span class="o">=</span> <span class="n">flag</span><span class="o">.</span><span class="n">size</span>

        <span class="n">uflag</span> <span class="o">=</span> <span class="n">flag</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">flag</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">ucov</span> <span class="o">=</span> <span class="n">uflag</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cov</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="o">+</span> <span class="n">cov</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">ucov</span><span class="p">,</span> <span class="n">hermitian</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="n">rcond</span><span class="p">)</span> <span class="o">*</span> <span class="n">uflag</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">gain</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Use Gaussian Process Regression to interpolate gains to missing frequencies.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq : np.ndarray[nfreq,]</span>
<span class="sd">            Frequency in MHz.</span>
<span class="sd">        gain : np.ndarray[nfreq, ninput]</span>
<span class="sd">            Complex gain as a function of frequency for each input.</span>
<span class="sd">        weight : np.ndarray[nfreq, ninput]</span>
<span class="sd">            Uncertainty on the gain expressed as an inverse variance.</span>
<span class="sd">        flag : np.ndarray[nfreq,]</span>
<span class="sd">            Boolean flag where True indicates a good frequency and</span>
<span class="sd">            False indicates a bad frequency.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ginterp : np.ndarray[nfreq, ninput]</span>
<span class="sd">            Gain at all frequencies.  Previously flagged frequencies</span>
<span class="sd">            have been interpolated from neighboring channels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flag</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">gain</span>

        <span class="n">flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">weight</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">flag</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="n">ginterp</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cal_utils</span><span class="o">.</span><span class="n">interpolate_gain_quiet</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">gain</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="n">flag</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ginterp</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_apply_simple_lpf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">gain</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply a simple FIR low-pass filter to the gains as a function of frequency.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq : np.ndarray[nfreq,]</span>
<span class="sd">            Frequency in MHz.</span>
<span class="sd">        gain : np.ndarray[nfreq, ninput]</span>
<span class="sd">            Complex gain as a function of frequency for each input.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gfilt : np.ndarray[nfreq, ninput]</span>
<span class="sd">            Gains low-pass filtered along the frequency axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cutoff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau_width</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">dfreq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">freq</span><span class="p">)))</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">dfreq</span>

        <span class="n">numtaps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numtaps</span> <span class="o">/</span> <span class="n">dfreq</span><span class="p">)</span>
        <span class="n">numtaps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numtaps</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="ow">not</span> <span class="p">(</span><span class="n">numtaps</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)))</span>

        <span class="n">coeff</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">firwin</span><span class="p">(</span><span class="n">numtaps</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;dpss&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">],</span> <span class="n">gain</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>



<div class="viewcode-block" id="CorrectGainError">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.CorrectGainError">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CorrectGainError</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Correct stacked visibilities for errors in the gains applied in real-time.</span>

<span class="sd">    This correction is imperfect because the redundant baselines are not actually</span>
<span class="sd">    redundant.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    ignore_input_flags : bool</span>
<span class="sd">        When calculating the correction, do not exclude</span>
<span class="sd">        feeds that were identified as bad and excluded</span>
<span class="sd">        from the stacked visibilities (faster).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ignore_input_flags</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="CorrectGainError.setup">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.CorrectGainError.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gains</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Prepare the gain errors as a function of time.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gains: containers.GainData</span>
<span class="sd">            Narrowband gain errors generated by the</span>
<span class="sd">            ReconstructGainError task.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gains</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">gains</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">gains</span><span class="o">.</span><span class="n">time</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">frac_error</span> <span class="o">=</span> <span class="n">gains</span><span class="o">.</span><span class="n">gain</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flag</span> <span class="o">=</span> <span class="n">gains</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span> <span class="o">&gt;</span> <span class="mf">0.0</span>

        <span class="k">elif</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">gains</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">gains</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">])</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">frac_error</span> <span class="o">=</span> <span class="n">gains</span><span class="o">.</span><span class="n">gain</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flag</span> <span class="o">=</span> <span class="n">gains</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;gain must have a time axis or attribute.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">gains</span> <span class="o">=</span> <span class="n">gains</span></div>


<div class="viewcode-block" id="CorrectGainError.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.CorrectGainError.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Look up gain errors, stack over baselines, and apply to visibilities.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data: TimeStream or SiderealStream</span>
<span class="sd">            Visibilities.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data: TimeStream or SiderealStream</span>
<span class="sd">            Visibilities with the gain errors removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure the frequencies are the same</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gains</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">freq</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Frequencies do not match for gain error and timestream.&quot;</span><span class="p">)</span>

        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="n">stacked_vis</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">stacked_weight</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

        <span class="n">stack</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reverse_map</span><span class="p">[</span><span class="s2">&quot;stack&quot;</span><span class="p">][</span><span class="s2">&quot;stack&quot;</span><span class="p">]</span>
        <span class="n">conj</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reverse_map</span><span class="p">[</span><span class="s2">&quot;stack&quot;</span><span class="p">][</span><span class="s2">&quot;conjugate&quot;</span><span class="p">]</span>
        <span class="n">nstack</span> <span class="o">=</span> <span class="n">stacked_vis</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Determine the time axis.  This will be an (nlsd, ntime) array.</span>
        <span class="k">if</span> <span class="s2">&quot;ra&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
            <span class="n">ra</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">ra</span>
            <span class="n">lsd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span>
                <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;lsd&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;lsd&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span> <span class="k">else</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;csd&quot;</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">lsd</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Currently only able to handle single sidereal days.&quot;</span>
                <span class="p">)</span>

            <span class="n">timestamp</span> <span class="o">=</span> <span class="n">ephemeris</span><span class="o">.</span><span class="n">csd_to_unix</span><span class="p">(</span><span class="n">lsd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ra</span> <span class="o">/</span> <span class="mf">360.0</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The input container has a time axis.</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">time</span>

        <span class="c1"># Determine dimensions</span>
        <span class="n">ntime</span> <span class="o">=</span> <span class="n">timestamp</span><span class="o">.</span><span class="n">size</span>

        <span class="n">nfreq</span><span class="p">,</span> <span class="n">ninput</span><span class="p">,</span> <span class="n">nupdate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frac_error</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># We may want to replace the code below with something</span>
        <span class="c1"># based on the dataset id.</span>
        <span class="n">tindex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">timestamp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unique time indices are: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">tindex</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">before</span> <span class="o">=</span> <span class="n">tindex</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">before</span><span class="p">):</span>
            <span class="n">nbefore</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">before</span><span class="p">)</span>
            <span class="n">tbefore</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">-</span> <span class="n">timestamp</span><span class="p">[</span><span class="n">before</span><span class="p">])</span> <span class="o">/</span> <span class="mf">3600.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">nbefore</span><span class="si">:</span><span class="s2">0.0f</span><span class="si">}</span><span class="s2"> requested timestamps are before the earliest &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;gain update time by as much as </span><span class="si">{</span><span class="n">tbefore</span><span class="si">:</span><span class="s2">0.1f</span><span class="si">}</span><span class="s2"> hours.&quot;</span>
            <span class="p">)</span>

        <span class="n">after</span> <span class="o">=</span> <span class="n">tindex</span> <span class="o">==</span> <span class="p">(</span><span class="n">nupdate</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">after</span><span class="p">):</span>
            <span class="n">nafter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">after</span><span class="p">)</span>
            <span class="n">tafter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">timestamp</span><span class="p">[</span><span class="n">after</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span><span class="o">.</span><span class="n">max</span><span class="p">())</span> <span class="o">/</span> <span class="mf">3600.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">nafter</span><span class="si">:</span><span class="s2">0.0f</span><span class="si">}</span><span class="s2"> requested timestamps are after the latest&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;gain update time by as much as </span><span class="si">{</span><span class="n">tafter</span><span class="si">:</span><span class="s2">0.1f</span><span class="si">}</span><span class="s2"> hours.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Determine if we have valid input flags</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">input_flag</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">input_flags</span><span class="p">[:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">input_flag</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">input_flag</span><span class="p">):</span>
                <span class="n">input_flag</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Different calculation whether or not we have input flags</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ntime</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">index</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tindex</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_input_flags</span> <span class="ow">or</span> <span class="n">input_flag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Ignoring input flags (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ignore_input_flags</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="n">uniq_input_flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">ninput</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">uniq_input_flag</span><span class="p">,</span> <span class="n">windex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">input_flag</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">nuw</span> <span class="o">=</span> <span class="n">uniq_input_flag</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="n">nuw</span><span class="si">}</span><span class="s2"> unique sets of input flags.&quot;</span><span class="p">)</span>

            <span class="n">index</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">windex</span>

        <span class="n">uindex</span><span class="p">,</span> <span class="n">oindex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">nuniq</span> <span class="o">=</span> <span class="n">uindex</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Loop over the unique combinations of gains and input flags</span>
        <span class="k">for</span> <span class="n">uu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nuniq</span><span class="p">):</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Processing unique gains/flags </span><span class="si">{</span><span class="n">uu</span><span class="si">}</span><span class="s2"> of </span><span class="si">{</span><span class="n">nuniq</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Time index is </span><span class="si">{</span><span class="n">uindex</span><span class="p">[</span><span class="n">uu</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">.  Flag index is </span><span class="si">{</span><span class="n">uindex</span><span class="p">[</span><span class="n">uu</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

            <span class="n">oind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">oindex</span> <span class="o">==</span> <span class="n">uu</span><span class="p">)</span>

            <span class="n">flag</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">uniq_input_flag</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="n">uindex</span><span class="p">[</span><span class="n">uu</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
                <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">flag</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">uindex</span><span class="p">[</span><span class="n">uu</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
            <span class="p">)</span>

            <span class="n">ratio</span> <span class="o">=</span> <span class="n">flag</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">frac_error</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">uindex</span><span class="p">[</span><span class="n">uu</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

            <span class="c1"># Calculate outer product</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">fast_pack_product_array</span><span class="p">(</span>
                <span class="n">flag</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">flag</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
            <span class="p">)</span>

            <span class="n">vis</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">fast_pack_product_array</span><span class="p">(</span>
                <span class="n">ratio</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">ratio</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="n">vis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">conj</span><span class="p">,</span> <span class="n">vis</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">vis</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">ff</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nfreq</span><span class="p">):</span>

                <span class="n">corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span>
                    <span class="n">stack</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">vis</span><span class="p">[</span><span class="n">ff</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="n">nstack</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span>
                    <span class="n">stack</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">vis</span><span class="p">[</span><span class="n">ff</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="n">nstack</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="p">)</span>

                <span class="n">count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span>
                    <span class="n">stack</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">flag</span><span class="p">[</span><span class="n">ff</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span> <span class="n">minlength</span><span class="o">=</span><span class="n">nstack</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="p">)</span>

                <span class="n">corr</span> <span class="o">*=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>

                <span class="n">stacked_vis</span><span class="p">[</span><span class="n">ff</span><span class="p">][:,</span> <span class="n">oind</span><span class="p">]</span> <span class="o">*=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span>
                    <span class="n">corr</span><span class="p">[:</span><span class="n">nstack</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">stacked_weight</span><span class="p">[</span><span class="n">ff</span><span class="p">][:,</span> <span class="n">oind</span><span class="p">]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">corr</span><span class="p">[:</span><span class="n">nstack</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="k">return</span> <span class="n">data</span></div>
</div>



<div class="viewcode-block" id="CollapseGainError">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.CollapseGainError">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CollapseGainError</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Average gain errors over all pairs of feeds.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="CollapseGainError.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.CollapseGainError.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gain</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the baseline-averaged gain error.</span>

<span class="sd">        Approximates the effect of the gain errors on</span>
<span class="sd">        the frequency dependence of a ringmap.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gain : StaticGainData</span>
<span class="sd">            Ratio of the applied gain to the &quot;true&quot; gain.</span>
<span class="sd">            The &quot;true&quot; gain is usually estimated by</span>
<span class="sd">            low-pass filtering along the frequency axis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : StaticGainData</span>
<span class="sd">            Baseline-averaged gain error placed into a</span>
<span class="sd">            StaticGainData container with a size 1</span>
<span class="sd">            input axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Redistribute over freq</span>
        <span class="n">gain</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Dereference datasets</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">gain</span><span class="o">.</span><span class="n">gain</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">gain</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>

        <span class="c1"># Identify flagged data</span>
        <span class="n">gflag</span> <span class="o">=</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="mf">0.0</span>

        <span class="c1"># Calculate the outer product of the gains</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">fast_pack_product_array</span><span class="p">(</span>
            <span class="n">gflag</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">gflag</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="p">)</span>
        <span class="n">vis</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">fast_pack_product_array</span><span class="p">(</span>
            <span class="n">g</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">g</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">fast_pack_product_array</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:])</span>

        <span class="n">count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">avg_vis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">flag</span> <span class="o">*</span> <span class="n">vis</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
        <span class="n">avg_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">flag</span> <span class="o">*</span> <span class="n">var</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">count</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Save to output container</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">StaticGainData</span><span class="p">(</span>
            <span class="nb">input</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s2">&quot;baseline-averaged&quot;</span><span class="p">]),</span>
            <span class="n">axes_from</span><span class="o">=</span><span class="n">gain</span><span class="p">,</span>
            <span class="n">attrs_from</span><span class="o">=</span><span class="n">gain</span><span class="p">,</span>
            <span class="n">distributed</span><span class="o">=</span><span class="n">gain</span><span class="o">.</span><span class="n">distributed</span><span class="p">,</span>
            <span class="n">comm</span><span class="o">=</span><span class="n">gain</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">out</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;weight&quot;</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="n">out</span><span class="o">.</span><span class="n">gain</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">avg_vis</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">out</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">avg_var</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">out</span></div>
</div>



<div class="viewcode-block" id="EstimateNarrowbandGainError">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.EstimateNarrowbandGainError">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">EstimateNarrowbandGainError</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Estimate error in gains due to narrowband features.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    ignore_rfi: bool</span>
<span class="sd">        Ignore the persistent RFI bands when calculating</span>
<span class="sd">        the gain error.  These bands are specified in</span>
<span class="sd">        ch_util.rfi.frequency_mask.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ignore_rfi</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<div class="viewcode-block" id="EstimateNarrowbandGainError.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.EstimateNarrowbandGainError.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gain</span><span class="p">,</span> <span class="n">gain_mask</span><span class="p">,</span> <span class="n">gain_smooth</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct the correction for narrowband gain errors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gain: StaticGainData</span>
<span class="sd">            Original (unmasked) gains.</span>
<span class="sd">        gain_mask: StaticGainData</span>
<span class="sd">            Gains after masking.</span>
<span class="sd">        gain_smooth: StaticGainData</span>
<span class="sd">            Gains after masking and interpolating</span>
<span class="sd">            over the narrowband features.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out: StaticGainData</span>
<span class="sd">            Here the gain dataset is the ratio of the original gain</span>
<span class="sd">            and a version of the gain where all narrowband feature have</span>
<span class="sd">            been flagged and smoothly interpolated over.  The weight</span>
<span class="sd">            dataset is 1.0 if a narrowband feature was identified at</span>
<span class="sd">            that (freq, input, time) and 0.0 otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Redistribute over input</span>
        <span class="n">gain</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;input&quot;</span><span class="p">)</span>
        <span class="n">gain_mask</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;input&quot;</span><span class="p">)</span>
        <span class="n">gain_smooth</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;input&quot;</span><span class="p">)</span>

        <span class="c1"># Dereference datasets</span>
        <span class="n">gm</span> <span class="o">=</span> <span class="n">gain_mask</span><span class="o">.</span><span class="n">gain</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">gs</span> <span class="o">=</span> <span class="n">gain_smooth</span><span class="o">.</span><span class="n">gain</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

        <span class="n">wi</span> <span class="o">=</span> <span class="n">gain</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="n">wm</span> <span class="o">=</span> <span class="n">gain_mask</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>

        <span class="c1"># Create a mask that identifies newly flagged data</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">wi</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">wm</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_rfi</span><span class="p">:</span>
            <span class="n">rfi_mask</span> <span class="o">=</span> <span class="n">rfi</span><span class="o">.</span><span class="n">frequency_mask</span><span class="p">(</span><span class="n">gain</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span>

            <span class="n">mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">rfi_mask</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="c1"># Calculate the ratio of the gain and smooth version of the gain</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">StaticGainData</span><span class="p">(</span>
            <span class="n">axes_from</span><span class="o">=</span><span class="n">gain</span><span class="p">,</span>
            <span class="n">attrs_from</span><span class="o">=</span><span class="n">gain</span><span class="p">,</span>
            <span class="n">distributed</span><span class="o">=</span><span class="n">gain</span><span class="o">.</span><span class="n">distributed</span><span class="p">,</span>
            <span class="n">comm</span><span class="o">=</span><span class="n">gain</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">out</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;weight&quot;</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;input&quot;</span><span class="p">)</span>

        <span class="n">out</span><span class="o">.</span><span class="n">gain</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">gm</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">gs</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="c1"># Set the weight to zero for bad inputs</span>
        <span class="n">out</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">wi</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span>

        <span class="c1"># Return the ratio of gains</span>
        <span class="k">return</span> <span class="n">out</span></div>
</div>



<div class="viewcode-block" id="ConcatenateGains">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.ConcatenateGains">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ConcatenateGains</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Repackage a list of StaticGainData/GainData into a single GainData container.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="ConcatenateGains.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.ConcatenateGains.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gains</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Concatenate gain updates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gains: list of GainData or StaticGainData</span>
<span class="sd">            List of gain updates.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out: GainData</span>
<span class="sd">            The list of gain updates sorted by time and</span>
<span class="sd">            placed in a single container with a time axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Sort by time</span>
        <span class="n">timestamp</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">gain</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gains</span><span class="p">):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">gain</span><span class="o">.</span><span class="n">time</span><span class="p">)</span> <span class="k">if</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">gain</span><span class="o">.</span><span class="n">index_map</span> <span class="k">else</span> <span class="p">[</span><span class="n">gain</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]]</span>
            <span class="n">timestamp</span> <span class="o">+=</span> <span class="n">t</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">)</span> <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">))]</span>
            <span class="n">gain</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="n">isort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">timestamp</span><span class="p">)</span>
        <span class="n">timestamp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">timestamp</span><span class="p">)[</span><span class="n">isort</span><span class="p">]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="n">iso</span><span class="p">]</span> <span class="k">for</span> <span class="n">iso</span> <span class="ow">in</span> <span class="n">isort</span><span class="p">]</span>

        <span class="n">g0</span> <span class="o">=</span> <span class="n">gains</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">GainData</span><span class="p">(</span><span class="n">axes_from</span><span class="o">=</span><span class="n">g0</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">g0</span><span class="o">.</span><span class="n">comm</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;weight&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;update_id&quot;</span> <span class="ow">in</span> <span class="n">g0</span><span class="o">.</span><span class="n">datasets</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">add_dataset</span><span class="p">(</span><span class="s2">&quot;update_id&quot;</span><span class="p">)</span>

        <span class="n">out</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">tt</span><span class="p">,</span> <span class="p">(</span><span class="n">gg</span><span class="p">,</span> <span class="n">ii</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>

            <span class="n">gain</span> <span class="o">=</span> <span class="n">gains</span><span class="p">[</span><span class="n">gg</span><span class="p">]</span>

            <span class="k">if</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">gain</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">gain</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">tt</span><span class="p">]</span> <span class="o">=</span> <span class="n">gain</span><span class="o">.</span><span class="n">gain</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ii</span><span class="p">]</span>
                <span class="n">out</span><span class="o">.</span><span class="n">weight</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">tt</span><span class="p">]</span> <span class="o">=</span> <span class="n">gain</span><span class="o">.</span><span class="n">weight</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ii</span><span class="p">]</span>
                <span class="k">if</span> <span class="s2">&quot;update_id&quot;</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">datasets</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">update_id</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span> <span class="o">=</span> <span class="n">gain</span><span class="o">.</span><span class="n">update_id</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">gain</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">tt</span><span class="p">]</span> <span class="o">=</span> <span class="n">gain</span><span class="o">.</span><span class="n">gain</span><span class="p">[:]</span>
                <span class="n">out</span><span class="o">.</span><span class="n">weight</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">tt</span><span class="p">]</span> <span class="o">=</span> <span class="n">gain</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span>
                <span class="k">if</span> <span class="s2">&quot;update_id&quot;</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">datasets</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">update_id</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span> <span class="o">=</span> <span class="n">gain</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;update_id&quot;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">out</span></div>
</div>



<div class="viewcode-block" id="FlagNarrowbandGainError">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.FlagNarrowbandGainError">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FlagNarrowbandGainError</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mask frequencies and times where narrowband gain errors were identified.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    transition: float</span>
<span class="sd">        Duration in seconds over which we transitioned between gains in the</span>
<span class="sd">        real-time pipeline.</span>
<span class="sd">    threshold: float</span>
<span class="sd">        Mask any frequency and time where the fractional gain error is larger</span>
<span class="sd">        than this threshold.</span>
<span class="sd">    ignore_input_flags: bool</span>
<span class="sd">        Ignore the input flags when calculating the average gain error.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">transition</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">600.0</span><span class="p">)</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0e-3</span><span class="p">)</span>
    <span class="n">ignore_input_flags</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="FlagNarrowbandGainError.setup">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.FlagNarrowbandGainError.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gains</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Prepare the gain errors as a function of time.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gains: containers.GainData</span>
<span class="sd">            Narrowband gain errors generated by the</span>
<span class="sd">            EstimateNarrowbandGainError task.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gains</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gains</span> <span class="o">=</span> <span class="n">gains</span>

        <span class="c1"># Identify the bad inputs when the gains were generated</span>
        <span class="n">weight_local</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">gains</span><span class="o">.</span><span class="n">weight</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">weight_local</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Allreduce</span><span class="p">(</span><span class="n">weight_local</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">LOR</span><span class="p">)</span>

        <span class="c1"># Compute the fractional error in the gain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frac_error</span> <span class="o">=</span> <span class="n">gains</span><span class="o">.</span><span class="n">gain</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span> <span class="o">-</span> <span class="mf">1.0</span></div>


<div class="viewcode-block" id="FlagNarrowbandGainError.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.FlagNarrowbandGainError.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Look up appropriate gain errors, construct flag, and apply to weights.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data: TimeStream or SiderealStream</span>
<span class="sd">            Data to flag.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out: RFIMask or SiderealRFIMask</span>
<span class="sd">            Mask that removes frequencies and times.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure the frequencies are the same</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gains</span><span class="o">.</span><span class="n">freq</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">freq</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Frequencies do not match for gain error and timestream.&quot;</span><span class="p">)</span>

        <span class="n">data</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Determine the time axis.  This will be an (nlsd, ntime) array.</span>
        <span class="k">if</span> <span class="s2">&quot;ra&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
            <span class="n">ra</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">ra</span>
            <span class="n">lsd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span>
                <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;lsd&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;lsd&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span> <span class="k">else</span> <span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;csd&quot;</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="n">timestamp</span> <span class="o">=</span> <span class="n">chime</span><span class="o">.</span><span class="n">lsd_to_unix</span><span class="p">(</span>
                <span class="n">lsd</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">ra</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="mf">360.0</span>
            <span class="p">)</span>

            <span class="n">out</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">SiderealRFIMask</span><span class="p">(</span><span class="n">axes_from</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">attrs_from</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The input container has a time axis.  Use a singleton lsd axis.</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>

            <span class="n">out</span> <span class="o">=</span> <span class="n">containers</span><span class="o">.</span><span class="n">RFIMask</span><span class="p">(</span><span class="n">axes_from</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">attrs_from</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>

        <span class="c1"># Determine dimensions</span>
        <span class="n">nfreq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frac_error</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">nlsd</span><span class="p">,</span> <span class="n">ntime</span> <span class="o">=</span> <span class="n">timestamp</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">ftimestamp</span> <span class="o">=</span> <span class="n">timestamp</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">nftime</span> <span class="o">=</span> <span class="n">ftimestamp</span><span class="o">.</span><span class="n">size</span>

        <span class="c1"># We may want to replace the code below with something</span>
        <span class="c1"># based on the dataset id.  However this time-based look up</span>
        <span class="c1"># should work okay if we allow some reasonable transition window</span>
        <span class="c1"># during which we take the maximum possible error.</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">nftime</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">ftimestamp</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gains</span><span class="o">.</span><span class="n">time</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">ftimestamp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gains</span><span class="o">.</span><span class="n">time</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="n">before</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">before</span><span class="p">):</span>
            <span class="n">nbefore</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">before</span><span class="p">)</span>
            <span class="n">tbefore</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gains</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">-</span> <span class="n">ftimestamp</span><span class="p">[</span><span class="n">before</span><span class="p">])</span> <span class="o">/</span> <span class="mf">3600.0</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">nbefore</span><span class="si">:</span><span class="s2">0.0f</span><span class="si">}</span><span class="s2"> requested timestamps are before the earliest &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;gain update time by as much as </span><span class="si">{</span><span class="n">tbefore</span><span class="si">:</span><span class="s2">0.1f</span><span class="si">}</span><span class="s2"> hours.&quot;</span>
            <span class="p">)</span>

        <span class="n">after</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="n">nftime</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">after</span><span class="p">):</span>
            <span class="n">nafter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">after</span><span class="p">)</span>
            <span class="n">tafter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ftimestamp</span><span class="p">[</span><span class="n">after</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">gains</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">max</span><span class="p">())</span> <span class="o">/</span> <span class="mf">3600.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">nafter</span><span class="si">:</span><span class="s2">0.0f</span><span class="si">}</span><span class="s2"> requested timestamps are after the latest&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;gain update time by as much as </span><span class="si">{</span><span class="n">tafter</span><span class="si">:</span><span class="s2">0.1f</span><span class="si">}</span><span class="s2"> hours.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Determine if we have valid input flags</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">input_flags</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_array</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">no_input_flags</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
                <span class="n">no_input_flags</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># The sidereal stacks currently set all input flags to zero.</span>
                <span class="c1"># We want to ignore the input flags in this case.</span>
                <span class="n">no_input_flags</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Different calculation whether or not we have input flags</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_input_flags</span> <span class="ow">or</span> <span class="n">no_input_flags</span><span class="p">:</span>
            <span class="c1"># We do not have an input flag.  Perform a straight average over all good inputs.</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">frac_error</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># Use the gain update with the maximum error for times</span>
            <span class="c1"># where there may have been a transition between two gain updates</span>
            <span class="n">err_avgi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">err</span><span class="p">[:,</span> <span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">err</span><span class="p">[:,</span> <span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">]]),</span>
                <span class="n">err</span><span class="p">[:,</span> <span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                <span class="n">err</span><span class="p">[:,</span> <span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

            <span class="c1"># Caculate the average error for the inputs that were</span>
            <span class="c1"># flagged as good at each time.</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">nfreq</span><span class="p">,</span> <span class="n">nftime</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_error</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="c1"># Loop over the two possible gain updates</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">tt</span><span class="p">,</span> <span class="n">uu</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ind</span><span class="p">):</span>
                    <span class="c1"># The modulus with the number of times is for the</span>
                    <span class="c1"># sidereal stacks where we have gain errors on</span>
                    <span class="c1"># many days, but a single set of input flags.</span>
                    <span class="n">wit</span> <span class="o">=</span> <span class="n">w</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">tt</span> <span class="o">%</span> <span class="n">ntime</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">uu</span><span class="p">]</span>

                    <span class="n">err</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:,</span> <span class="n">tt</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                        <span class="n">wit</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">frac_error</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">uu</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
                    <span class="p">)</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">wit</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

            <span class="c1"># Again, during transitions we take the update with the maximum error.</span>
            <span class="n">err_avgi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">err</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">err</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">err</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">err</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Average over sidereal days</span>
        <span class="n">err_avgi_avgd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">err_avgi</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">nlsd</span><span class="p">,</span> <span class="n">ntime</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Mask any frequency and time where the magnitude</span>
        <span class="c1"># of the input-averaged fractional gain error is greater</span>
        <span class="c1"># than the specified threshold</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">err_avgi_avgd</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span>

        <span class="c1"># The RFIMask containers are not distributed.  Perform an allgather to</span>
        <span class="c1"># acquire the mask for all frequencies.</span>
        <span class="n">out</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">mpiarray</span><span class="o">.</span><span class="n">MPIArray</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">comm</span><span class="p">)</span><span class="o">.</span><span class="n">allgather</span><span class="p">()</span>

        <span class="c1"># Print the total fraction of data flagged</span>
        <span class="n">frac_masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">mask</span><span class="p">[:])</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">mask</span><span class="p">[:]</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Flagging </span><span class="si">{</span><span class="mi">100</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">frac_masked</span><span class="si">:</span><span class="s2">0.2f</span><span class="si">}</span><span class="s2">% &quot;</span>
            <span class="s2">&quot;of data due to narrow band gain errors.&quot;</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>
</div>



<div class="viewcode-block" id="CalibrationCorrection">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.CalibrationCorrection">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CalibrationCorrection</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">SingleTask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for applying multiplicative corrections based on a DataFlag.</span>

<span class="sd">    This task is not functional.  It simply defines `setup` and `process`</span>
<span class="sd">    methods that are common to several subclasses.  All subclasses must</span>
<span class="sd">    define the `_get_correction` and `_correction_is_nonzero` methods.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rotation : float</span>
<span class="sd">        Current best estimate of telescope rotation.</span>
<span class="sd">    name_of_flag : str</span>
<span class="sd">        The name of the DataFlag.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">rotation</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">chime</span><span class="o">.</span><span class="n">rotation</span><span class="p">)</span>
    <span class="n">name_of_flag</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="CalibrationCorrection.setup">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.CalibrationCorrection.setup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Query the database for all DataFlags with name equal to the `name_of_flag` property.&quot;&quot;&quot;</span>
        <span class="n">flags</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Query flag database if on 0th node</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">finder</span><span class="o">.</span><span class="n">connect_database</span><span class="p">()</span>
            <span class="n">flag_types</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="n">DataFlagType</span><span class="o">.</span><span class="n">select</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">ft</span> <span class="ow">in</span> <span class="n">flag_types</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ft</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">name_of_flag</span><span class="p">:</span>
                    <span class="n">ftemp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                        <span class="n">finder</span><span class="o">.</span><span class="n">DataFlag</span><span class="o">.</span><span class="n">select</span><span class="p">()</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">finder</span><span class="o">.</span><span class="n">DataFlag</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">ft</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="c1"># Only keep flags that will produce nonzero corrections, as defined by</span>
                    <span class="c1"># the _correction_is_nonzero method</span>
                    <span class="n">flags</span> <span class="o">+=</span> <span class="p">[</span>
                        <span class="n">flg</span>
                        <span class="k">for</span> <span class="n">flg</span> <span class="ow">in</span> <span class="n">ftemp</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correction_is_nonzero</span><span class="p">(</span><span class="o">**</span><span class="n">flg</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>
                    <span class="p">]</span>

        <span class="c1"># Share flags with other nodes</span>
        <span class="n">flags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Save flags to class attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name_of_flag</span><span class="si">}</span><span class="s2"> flags in total.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span></div>


<div class="viewcode-block" id="CalibrationCorrection.process">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.CalibrationCorrection.process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sstream</span><span class="p">,</span> <span class="n">inputmap</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply a multiplicative correction to visiblities during range of time covered by flags.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sstream : andata.CorrData, containers.SiderealStream, or equivalent</span>
<span class="sd">            Apply a correction to the `vis` dataset in this container.</span>
<span class="sd">        inputmap : list of :class:`CorrInput`</span>
<span class="sd">            List describing the inputs as they are in the file, output from</span>
<span class="sd">            `tools.get_correlator_inputs()`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sstream_out : same as sstream</span>
<span class="sd">            The input container with the correction applied.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Determine if there are flags pertinent to this range of time</span>
        <span class="k">if</span> <span class="s2">&quot;ra&quot;</span> <span class="ow">in</span> <span class="n">sstream</span><span class="o">.</span><span class="n">index_map</span><span class="p">:</span>
            <span class="n">ra</span> <span class="o">=</span> <span class="n">sstream</span><span class="o">.</span><span class="n">ra</span>
            <span class="n">csd</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">sstream</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;lsd&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;lsd&quot;</span> <span class="ow">in</span> <span class="n">sstream</span><span class="o">.</span><span class="n">attrs</span> <span class="k">else</span> <span class="n">sstream</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;csd&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">csd</span><span class="p">,</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">):</span>
                <span class="n">csd</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">csd</span><span class="p">)[</span><span class="nb">len</span><span class="p">(</span><span class="n">csd</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="n">chime</span><span class="o">.</span><span class="n">lsd_to_unix</span><span class="p">(</span><span class="n">csd</span> <span class="o">+</span> <span class="n">ra</span> <span class="o">/</span> <span class="mf">360.0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="n">sstream</span><span class="o">.</span><span class="n">time</span>

        <span class="n">covered</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">flag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">((</span><span class="n">timestamp</span> <span class="o">&gt;=</span> <span class="n">flag</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">timestamp</span> <span class="o">&lt;=</span> <span class="n">flag</span><span class="o">.</span><span class="n">finish_time</span><span class="p">)):</span>
                <span class="n">covered</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

        <span class="c1"># If the flags do not cover this range of time, then do nothing</span>
        <span class="c1"># and return the input container</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">covered</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sstream</span>

        <span class="c1"># We are covered by the flags, so set up for correction</span>
        <span class="n">sstream</span><span class="o">.</span><span class="n">redistribute</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">)</span>

        <span class="c1"># Find the local frequencies</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">sstream</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="n">sstream</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span><span class="o">.</span><span class="n">local_bounds</span><span class="p">]</span>

        <span class="c1"># Extract representative products for the stacked visibilities</span>
        <span class="n">stack_new</span><span class="p">,</span> <span class="n">stack_flag</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">redefine_stack_index_map</span><span class="p">(</span>
            <span class="n">inputmap</span><span class="p">,</span> <span class="n">sstream</span><span class="o">.</span><span class="n">prod</span><span class="p">,</span> <span class="n">sstream</span><span class="o">.</span><span class="n">stack</span><span class="p">,</span> <span class="n">sstream</span><span class="o">.</span><span class="n">reverse_map</span><span class="p">[</span><span class="s2">&quot;stack&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">do_not_apply</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="o">~</span><span class="n">stack_flag</span><span class="p">)</span>
        <span class="n">prod</span> <span class="o">=</span> <span class="n">sstream</span><span class="o">.</span><span class="n">prod</span><span class="p">[</span><span class="n">stack_new</span><span class="p">[</span><span class="s2">&quot;prod&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Swap the product pair order for conjugated stack indices</span>
        <span class="n">cj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">stack_new</span><span class="p">[</span><span class="s2">&quot;conjugate&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">cj</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">prod</span><span class="p">[</span><span class="s2">&quot;input_a&quot;</span><span class="p">][</span><span class="n">cj</span><span class="p">],</span> <span class="n">prod</span><span class="p">[</span><span class="s2">&quot;input_b&quot;</span><span class="p">][</span><span class="n">cj</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">prod</span><span class="p">[</span><span class="s2">&quot;input_b&quot;</span><span class="p">][</span><span class="n">cj</span><span class="p">],</span>
                <span class="n">prod</span><span class="p">[</span><span class="s2">&quot;input_a&quot;</span><span class="p">][</span><span class="n">cj</span><span class="p">],</span>
            <span class="p">)</span>

        <span class="c1"># Dereference dataset</span>
        <span class="n">ssv</span> <span class="o">=</span> <span class="n">sstream</span><span class="o">.</span><span class="n">vis</span><span class="p">[:]</span>

        <span class="c1"># Loop over flags again</span>
        <span class="k">for</span> <span class="n">flag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">:</span>
            <span class="n">in_range</span> <span class="o">=</span> <span class="p">(</span><span class="n">timestamp</span> <span class="o">&gt;=</span> <span class="n">flag</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">timestamp</span> <span class="o">&lt;=</span> <span class="n">flag</span><span class="o">.</span><span class="n">finish_time</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">in_range</span><span class="p">):</span>
                <span class="n">datestr_start</span> <span class="o">=</span> <span class="n">ctime</span><span class="o">.</span><span class="n">unix_to_datetime</span><span class="p">(</span><span class="n">flag</span><span class="o">.</span><span class="n">start_time</span><span class="p">)</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span>
                    <span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">T%H%M%SZ&quot;</span>
                <span class="p">)</span>
                <span class="n">datestr_end</span> <span class="o">=</span> <span class="n">ctime</span><span class="o">.</span><span class="n">unix_to_datetime</span><span class="p">(</span><span class="n">flag</span><span class="o">.</span><span class="n">finish_time</span><span class="p">)</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span>
                    <span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">T%H%M%SZ&quot;</span>
                <span class="p">)</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">in_range</span><span class="p">)</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> (of </span><span class="si">{</span><span class="n">in_range</span><span class="o">.</span><span class="n">size</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">) samples require &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;phase correction according to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name_of_flag</span><span class="si">}</span><span class="s2"> DataFlag &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;covering </span><span class="si">{</span><span class="n">datestr_start</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">datestr_end</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                <span class="n">correction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_correction</span><span class="p">(</span>
                    <span class="n">freq</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">[</span><span class="n">in_range</span><span class="p">],</span> <span class="n">inputmap</span><span class="p">,</span> <span class="o">**</span><span class="n">flag</span><span class="o">.</span><span class="n">metadata</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">do_not_apply</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Do not have valid baseline distance for stack indices: </span><span class="si">{</span><span class="n">do_not_apply</span><span class="si">!s}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="n">correction</span><span class="p">[:,</span> <span class="n">do_not_apply</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="mf">0.0</span><span class="n">j</span>

                <span class="n">ssv</span><span class="o">.</span><span class="n">local_array</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">in_range</span><span class="p">]</span> <span class="o">*=</span> <span class="n">correction</span>

        <span class="c1"># Return input container with phase correction applied</span>
        <span class="k">return</span> <span class="n">sstream</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_correction_is_nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_correction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">inputmap</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">pass</span></div>



<div class="viewcode-block" id="CorrectTimeOffset">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.CorrectTimeOffset">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CorrectTimeOffset</span><span class="p">(</span><span class="n">CalibrationCorrection</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Correct stacked visibilities for a different time standard used during calibration.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name_of_flag : str</span>
<span class="sd">        The name of the DataFlag that contains the time offset.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name_of_flag</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span><span class="n">proptype</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;calibration_time_offset&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_correction_is_nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;time_offset&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">0.0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_correction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">inputmap</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">time_offset</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;time_offset&quot;</span><span class="p">]</span>
        <span class="n">calibrator</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;calibrator&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Applying a phase correction for a </span><span class="si">{</span><span class="n">time_offset</span><span class="si">:</span><span class="s2">0.2f</span><span class="si">}</span><span class="s2"> second &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;time offset on the calibrator </span><span class="si">{</span><span class="n">calibrator</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>

        <span class="n">body</span> <span class="o">=</span> <span class="n">sources</span><span class="o">.</span><span class="n">source_dictionary</span><span class="p">[</span><span class="n">calibrator</span><span class="p">]</span>

        <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">chime</span><span class="o">.</span><span class="n">latitude</span><span class="p">)</span>

        <span class="c1"># Compute feed positions with rotation</span>
        <span class="n">tools</span><span class="o">.</span><span class="n">change_chime_location</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rotation</span><span class="p">)</span>
        <span class="n">uv</span> <span class="o">=</span> <span class="n">_calculate_uv</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="n">inputmap</span><span class="p">)</span>

        <span class="c1"># Return back to default rotation</span>
        <span class="n">tools</span><span class="o">.</span><span class="n">change_chime_location</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Determine location of calibrator</span>
        <span class="n">ttrans</span> <span class="o">=</span> <span class="n">chime</span><span class="o">.</span><span class="n">transit_times</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">24.0</span> <span class="o">*</span> <span class="mf">3600.0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">ra</span><span class="p">,</span> <span class="n">dec</span> <span class="o">=</span> <span class="n">chime</span><span class="o">.</span><span class="n">object_coords</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">date</span><span class="o">=</span><span class="n">ttrans</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">ha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">chime</span><span class="o">.</span><span class="n">unix_to_lsa</span><span class="p">(</span><span class="n">ttrans</span> <span class="o">+</span> <span class="n">time_offset</span><span class="p">))</span> <span class="o">-</span> <span class="n">ra</span>

        <span class="c1"># Calculate and return the phase correction, which is old offset minus new time offset</span>
        <span class="c1"># since we previously divided the chimestack data by the response to the calibrator.</span>
        <span class="n">correction</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">fringestop_phase</span><span class="p">(</span><span class="n">ha</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="o">*</span><span class="n">uv</span><span class="p">)</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span>
            <span class="n">tools</span><span class="o">.</span><span class="n">fringestop_phase</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="o">*</span><span class="n">uv</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">correction</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span></div>



<div class="viewcode-block" id="CorrectTelescopeRotation">
<a class="viewcode-back" href="../../../_autosummary/ch_pipeline.analysis.calibration.html#ch_pipeline.analysis.calibration.CorrectTelescopeRotation">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CorrectTelescopeRotation</span><span class="p">(</span><span class="n">CalibrationCorrection</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Correct stacked visibilities for a different telescope rotation used during calibration.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name_of_flag : str</span>
<span class="sd">        The name of the DataFlag that contains the telescope rotation</span>
<span class="sd">        used was during calibration.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name_of_flag</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">Property</span><span class="p">(</span>
        <span class="n">proptype</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;calibration_telescope_rotation&quot;</span>
    <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_correction_is_nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;rotation&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_correction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">inputmap</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">rotation</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;rotation&quot;</span><span class="p">]</span>
        <span class="n">calibrator</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;calibrator&quot;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Applying a phase correction to convert from a telescope rotation &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;of </span><span class="si">{</span><span class="n">rotation</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> deg to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rotation</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> deg for the calibrator </span><span class="si">{</span><span class="n">calibrator</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>

        <span class="n">body</span> <span class="o">=</span> <span class="n">sources</span><span class="o">.</span><span class="n">source_dictionary</span><span class="p">[</span><span class="n">calibrator</span><span class="p">]</span>

        <span class="n">lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">chime</span><span class="o">.</span><span class="n">latitude</span><span class="p">)</span>

        <span class="c1"># Compute feed positions with old rotation</span>
        <span class="n">tools</span><span class="o">.</span><span class="n">change_chime_location</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="n">rotation</span><span class="p">)</span>
        <span class="n">old_uv</span> <span class="o">=</span> <span class="n">_calculate_uv</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="n">inputmap</span><span class="p">)</span>

        <span class="c1"># Compute feed positions with current rotation</span>
        <span class="n">tools</span><span class="o">.</span><span class="n">change_chime_location</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rotation</span><span class="p">)</span>
        <span class="n">current_uv</span> <span class="o">=</span> <span class="n">_calculate_uv</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="n">inputmap</span><span class="p">)</span>

        <span class="c1"># Return back to default rotation</span>
        <span class="n">tools</span><span class="o">.</span><span class="n">change_chime_location</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Determine location of calibrator</span>
        <span class="n">ttrans</span> <span class="o">=</span> <span class="n">chime</span><span class="o">.</span><span class="n">transit_times</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">24.0</span> <span class="o">*</span> <span class="mf">3600.0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">dec</span> <span class="o">=</span> <span class="n">chime</span><span class="o">.</span><span class="n">object_coords</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">date</span><span class="o">=</span><span class="n">ttrans</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Calculate and return the phase correction, which is old positions minus new positions</span>
        <span class="c1"># since we previously divided the chimestack data by the response to the calibrator.</span>
        <span class="n">correction</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">fringestop_phase</span><span class="p">(</span>
            <span class="mf">0.0</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="o">*</span><span class="n">old_uv</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">tools</span><span class="o">.</span><span class="n">invert_no_zero</span><span class="p">(</span><span class="n">tools</span><span class="o">.</span><span class="n">fringestop_phase</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">dec</span><span class="p">,</span> <span class="o">*</span><span class="n">current_uv</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">correction</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_calculate_uv</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="n">inputmap</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate baseline distances in wavelengths from the frequency, products, and inputmap.&quot;&quot;&quot;</span>
    <span class="n">feedpos</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">get_feed_positions</span><span class="p">(</span><span class="n">inputmap</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">feedpos</span><span class="p">[:,</span> <span class="n">prod</span><span class="p">[</span><span class="s2">&quot;input_a&quot;</span><span class="p">]]</span> <span class="o">-</span> <span class="n">feedpos</span><span class="p">[:,</span> <span class="n">prod</span><span class="p">[</span><span class="s2">&quot;input_b&quot;</span><span class="p">]]</span>

    <span class="n">lmbda</span> <span class="o">=</span> <span class="n">speed_of_light</span> <span class="o">*</span> <span class="mf">1e-6</span> <span class="o">/</span> <span class="n">freq</span>

    <span class="k">return</span> <span class="n">dist</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">lmbda</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015, CHIME collaboration.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>